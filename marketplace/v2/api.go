// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Consumer Fulfillments, Consumer Installations, Consumer Listings, Consumer Personalization Requests, Consumer Providers, Provider Exchange Filters, Provider Exchanges, Provider Files, Provider Listings, Provider Personalization Requests, Provider Provider Analytics Dashboards, Provider Providers, etc.
package marketplace

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/databricks/useragent"
)

type ConsumerFulfillmentsAPI struct {
	consumerFulfillmentsImpl
}

// Get listing content metadata.
//
// Get a high level preview of the metadata of listing installable content.
func (a *ConsumerFulfillmentsAPI) GetByListingId(ctx context.Context, listingId string) (*GetListingContentMetadataResponse, error) {
	return a.consumerFulfillmentsImpl.internalGet(ctx, GetListingContentMetadataRequest{
		ListingId: listingId,
	})
}

// List all listing fulfillments.
//
// Get all listings fulfillments associated with a listing. A _fulfillment_ is a
// potential installation. Standard installations contain metadata about the
// attached share or git repo. Only one of these fields will be present.
// Personalized installations contain metadata about the attached share or git
// repo, as well as the Delta Sharing recipient type.
func (a *ConsumerFulfillmentsAPI) ListByListingId(ctx context.Context, listingId string) (*ListFulfillmentsResponse, error) {
	return a.consumerFulfillmentsImpl.internalList(ctx, ListFulfillmentsRequest{
		ListingId: listingId,
	})
}

type ConsumerInstallationsAPI struct {
	consumerInstallationsImpl
}

// Uninstall from a listing.
//
// Uninstall an installation associated with a Databricks Marketplace listing.
func (a *ConsumerInstallationsAPI) DeleteByListingIdAndInstallationId(ctx context.Context, listingId string, installationId string) (*DeleteInstallationResponse, error) {
	return a.consumerInstallationsImpl.Delete(ctx, DeleteInstallationRequest{
		ListingId:      listingId,
		InstallationId: installationId,
	})
}

// List installations for a listing.
//
// List all installations for a particular listing.
func (a *ConsumerInstallationsAPI) ListListingInstallationsByListingId(ctx context.Context, listingId string) (*ListInstallationsResponse, error) {
	return a.consumerInstallationsImpl.internalListListingInstallations(ctx, ListInstallationsRequest{
		ListingId: listingId,
	})
}

type ConsumerListingsAPI struct {
	consumerListingsImpl
}

// Get listing.
//
// Get a published listing in the Databricks Marketplace that the consumer has
// access to.
func (a *ConsumerListingsAPI) GetById(ctx context.Context, id string) (*GetListingResponse, error) {
	return a.consumerListingsImpl.Get(ctx, GetListingRequest{
		Id: id,
	})
}

// ListingSummaryNameToIdMap calls [ConsumerListingsAPI.ListAll] and creates a map of results with [Listing].Summary.Name as key and [Listing].Id as value.
//
// Returns an error if there's more than one [Listing] with the same .Summary.Name.
//
// Note: All [Listing] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConsumerListingsAPI) ListingSummaryNameToIdMap(ctx context.Context, request ListListingsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Summary.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Summary.Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetBySummaryName calls [ConsumerListingsAPI.ListingSummaryNameToIdMap] and returns a single [Listing].
//
// Returns an error if there's more than one [Listing] with the same .Summary.Name.
//
// Note: All [Listing] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConsumerListingsAPI) GetBySummaryName(ctx context.Context, name string) (*Listing, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListListingsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Listing{}
	for _, v := range result {
		key := v.Summary.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Listing named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Listing named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ConsumerPersonalizationRequestsAPI struct {
	consumerPersonalizationRequestsImpl
}

// Get the personalization request for a listing.
//
// Get the personalization request for a listing. Each consumer can make at
// *most* one personalization request for a listing.
func (a *ConsumerPersonalizationRequestsAPI) GetByListingId(ctx context.Context, listingId string) (*GetPersonalizationRequestResponse, error) {
	return a.consumerPersonalizationRequestsImpl.Get(ctx, GetPersonalizationRequestRequest{
		ListingId: listingId,
	})
}

type ConsumerProvidersAPI struct {
	consumerProvidersImpl
}

// Get a provider.
//
// Get a provider in the Databricks Marketplace with at least one visible
// listing.
func (a *ConsumerProvidersAPI) GetById(ctx context.Context, id string) (*GetProviderResponse, error) {
	return a.consumerProvidersImpl.Get(ctx, GetProviderRequest{
		Id: id,
	})
}

// ProviderInfoNameToIdMap calls [ConsumerProvidersAPI.ListAll] and creates a map of results with [ProviderInfo].Name as key and [ProviderInfo].Id as value.
//
// Returns an error if there's more than one [ProviderInfo] with the same .Name.
//
// Note: All [ProviderInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConsumerProvidersAPI) ProviderInfoNameToIdMap(ctx context.Context, request ListProvidersRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [ConsumerProvidersAPI.ProviderInfoNameToIdMap] and returns a single [ProviderInfo].
//
// Returns an error if there's more than one [ProviderInfo] with the same .Name.
//
// Note: All [ProviderInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConsumerProvidersAPI) GetByName(ctx context.Context, name string) (*ProviderInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListProvidersRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ProviderInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ProviderInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ProviderInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ProviderExchangeFiltersAPI struct {
	providerExchangeFiltersImpl
}

// Delete an exchange filter.
//
// Delete an exchange filter
func (a *ProviderExchangeFiltersAPI) DeleteById(ctx context.Context, id string) (*DeleteExchangeFilterResponse, error) {
	return a.providerExchangeFiltersImpl.Delete(ctx, DeleteExchangeFilterRequest{
		Id: id,
	})
}

// ExchangeFilterNameToIdMap calls [ProviderExchangeFiltersAPI.ListAll] and creates a map of results with [ExchangeFilter].Name as key and [ExchangeFilter].Id as value.
//
// Returns an error if there's more than one [ExchangeFilter] with the same .Name.
//
// Note: All [ExchangeFilter] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangeFiltersAPI) ExchangeFilterNameToIdMap(ctx context.Context, request ListExchangeFiltersRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [ProviderExchangeFiltersAPI.ExchangeFilterNameToIdMap] and returns a single [ExchangeFilter].
//
// Returns an error if there's more than one [ExchangeFilter] with the same .Name.
//
// Note: All [ExchangeFilter] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangeFiltersAPI) GetByName(ctx context.Context, name string) (*ExchangeFilter, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListExchangeFiltersRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ExchangeFilter{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ExchangeFilter named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ExchangeFilter named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ProviderExchangesAPI struct {
	providerExchangesImpl
}

// Delete an exchange.
//
// This removes a listing from marketplace.
func (a *ProviderExchangesAPI) DeleteById(ctx context.Context, id string) (*DeleteExchangeResponse, error) {
	return a.providerExchangesImpl.Delete(ctx, DeleteExchangeRequest{
		Id: id,
	})
}

// Remove an exchange for listing.
//
// Disassociate an exchange with a listing
func (a *ProviderExchangesAPI) DeleteListingFromExchangeById(ctx context.Context, id string) (*RemoveExchangeForListingResponse, error) {
	return a.providerExchangesImpl.DeleteListingFromExchange(ctx, RemoveExchangeForListingRequest{
		Id: id,
	})
}

// Get an exchange.
//
// Get an exchange.
func (a *ProviderExchangesAPI) GetById(ctx context.Context, id string) (*GetExchangeResponse, error) {
	return a.providerExchangesImpl.Get(ctx, GetExchangeRequest{
		Id: id,
	})
}

// ExchangeNameToIdMap calls [ProviderExchangesAPI.ListAll] and creates a map of results with [Exchange].Name as key and [Exchange].Id as value.
//
// Returns an error if there's more than one [Exchange] with the same .Name.
//
// Note: All [Exchange] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangesAPI) ExchangeNameToIdMap(ctx context.Context, request ListExchangesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [ProviderExchangesAPI.ExchangeNameToIdMap] and returns a single [Exchange].
//
// Returns an error if there's more than one [Exchange] with the same .Name.
//
// Note: All [Exchange] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangesAPI) GetByName(ctx context.Context, name string) (*Exchange, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListExchangesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Exchange{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Exchange named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Exchange named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// ExchangeListingExchangeNameToExchangeIdMap calls [ProviderExchangesAPI.ListExchangesForListingAll] and creates a map of results with [ExchangeListing].ExchangeName as key and [ExchangeListing].ExchangeId as value.
//
// Returns an error if there's more than one [ExchangeListing] with the same .ExchangeName.
//
// Note: All [ExchangeListing] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangesAPI) ExchangeListingExchangeNameToExchangeIdMap(ctx context.Context, request ListExchangesForListingRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListExchangesForListingAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.ExchangeName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .ExchangeName: %s", key)
		}
		mapping[key] = v.ExchangeId
	}
	return mapping, nil
}

// GetByExchangeName calls [ProviderExchangesAPI.ExchangeListingExchangeNameToExchangeIdMap] and returns a single [ExchangeListing].
//
// Returns an error if there's more than one [ExchangeListing] with the same .ExchangeName.
//
// Note: All [ExchangeListing] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangesAPI) GetByExchangeName(ctx context.Context, name string) (*ExchangeListing, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListExchangesForListingAll(ctx, ListExchangesForListingRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ExchangeListing{}
	for _, v := range result {
		key := v.ExchangeName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ExchangeListing named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ExchangeListing named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// ExchangeListingListingNameToListingIdMap calls [ProviderExchangesAPI.ListListingsForExchangeAll] and creates a map of results with [ExchangeListing].ListingName as key and [ExchangeListing].ListingId as value.
//
// Returns an error if there's more than one [ExchangeListing] with the same .ListingName.
//
// Note: All [ExchangeListing] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangesAPI) ExchangeListingListingNameToListingIdMap(ctx context.Context, request ListListingsForExchangeRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListListingsForExchangeAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.ListingName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .ListingName: %s", key)
		}
		mapping[key] = v.ListingId
	}
	return mapping, nil
}

// GetByListingName calls [ProviderExchangesAPI.ExchangeListingListingNameToListingIdMap] and returns a single [ExchangeListing].
//
// Returns an error if there's more than one [ExchangeListing] with the same .ListingName.
//
// Note: All [ExchangeListing] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderExchangesAPI) GetByListingName(ctx context.Context, name string) (*ExchangeListing, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListListingsForExchangeAll(ctx, ListListingsForExchangeRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ExchangeListing{}
	for _, v := range result {
		key := v.ListingName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ExchangeListing named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ExchangeListing named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ProviderFilesAPI struct {
	providerFilesImpl
}

// Delete a file.
//
// Delete a file
func (a *ProviderFilesAPI) DeleteByFileId(ctx context.Context, fileId string) (*DeleteFileResponse, error) {
	return a.providerFilesImpl.Delete(ctx, DeleteFileRequest{
		FileId: fileId,
	})
}

// Get a file.
//
// Get a file
func (a *ProviderFilesAPI) GetByFileId(ctx context.Context, fileId string) (*GetFileResponse, error) {
	return a.providerFilesImpl.Get(ctx, GetFileRequest{
		FileId: fileId,
	})
}

// FileInfoDisplayNameToIdMap calls [ProviderFilesAPI.ListAll] and creates a map of results with [FileInfo].DisplayName as key and [FileInfo].Id as value.
//
// Returns an error if there's more than one [FileInfo] with the same .DisplayName.
//
// Note: All [FileInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderFilesAPI) FileInfoDisplayNameToIdMap(ctx context.Context, request ListFilesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [ProviderFilesAPI.FileInfoDisplayNameToIdMap] and returns a single [FileInfo].
//
// Returns an error if there's more than one [FileInfo] with the same .DisplayName.
//
// Note: All [FileInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderFilesAPI) GetByDisplayName(ctx context.Context, name string) (*FileInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListFilesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]FileInfo{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("FileInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of FileInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ProviderListingsAPI struct {
	providerListingsImpl
}

// Delete a listing.
//
// Delete a listing
func (a *ProviderListingsAPI) DeleteById(ctx context.Context, id string) (*DeleteListingResponse, error) {
	return a.providerListingsImpl.Delete(ctx, DeleteListingRequest{
		Id: id,
	})
}

// Get a listing.
//
// Get a listing
func (a *ProviderListingsAPI) GetById(ctx context.Context, id string) (*GetListingResponse, error) {
	return a.providerListingsImpl.Get(ctx, GetListingRequest{
		Id: id,
	})
}

// ListingSummaryNameToIdMap calls [ProviderListingsAPI.ListAll] and creates a map of results with [Listing].Summary.Name as key and [Listing].Id as value.
//
// Returns an error if there's more than one [Listing] with the same .Summary.Name.
//
// Note: All [Listing] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderListingsAPI) ListingSummaryNameToIdMap(ctx context.Context, request GetListingsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Summary.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Summary.Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetBySummaryName calls [ProviderListingsAPI.ListingSummaryNameToIdMap] and returns a single [Listing].
//
// Returns an error if there's more than one [Listing] with the same .Summary.Name.
//
// Note: All [Listing] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderListingsAPI) GetBySummaryName(ctx context.Context, name string) (*Listing, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, GetListingsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Listing{}
	for _, v := range result {
		key := v.Summary.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Listing named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Listing named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ProviderPersonalizationRequestsAPI struct {
	providerPersonalizationRequestsImpl
}

type ProviderProviderAnalyticsDashboardsAPI struct {
	providerProviderAnalyticsDashboardsImpl
}

type ProviderProvidersAPI struct {
	providerProvidersImpl
}

// Delete provider.
//
// Delete provider
func (a *ProviderProvidersAPI) DeleteById(ctx context.Context, id string) (*DeleteProviderResponse, error) {
	return a.providerProvidersImpl.Delete(ctx, DeleteProviderRequest{
		Id: id,
	})
}

// Get provider.
//
// Get provider profile
func (a *ProviderProvidersAPI) GetById(ctx context.Context, id string) (*GetProviderResponse, error) {
	return a.providerProvidersImpl.Get(ctx, GetProviderRequest{
		Id: id,
	})
}

// ProviderInfoNameToIdMap calls [ProviderProvidersAPI.ListAll] and creates a map of results with [ProviderInfo].Name as key and [ProviderInfo].Id as value.
//
// Returns an error if there's more than one [ProviderInfo] with the same .Name.
//
// Note: All [ProviderInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderProvidersAPI) ProviderInfoNameToIdMap(ctx context.Context, request ListProvidersRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [ProviderProvidersAPI.ProviderInfoNameToIdMap] and returns a single [ProviderInfo].
//
// Returns an error if there's more than one [ProviderInfo] with the same .Name.
//
// Note: All [ProviderInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ProviderProvidersAPI) GetByName(ctx context.Context, name string) (*ProviderInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListProvidersRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ProviderInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ProviderInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ProviderInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}
