// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Git Credentials, Repos, Secrets, Workspace, etc.
package workspace

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/databricks/useragent"
)

type GitCredentialsAPI struct {
	gitCredentialsImpl
}

// Delete a credential.
//
// Deletes the specified Git credential.
func (a *GitCredentialsAPI) DeleteByCredentialId(ctx context.Context, credentialId int64) (*DeleteCredentialsResponse, error) {
	return a.gitCredentialsImpl.Delete(ctx, DeleteCredentialsRequest{
		CredentialId: credentialId,
	})
}

// Get a credential entry.
//
// Gets the Git credential with the specified credential ID.
func (a *GitCredentialsAPI) GetByCredentialId(ctx context.Context, credentialId int64) (*GetCredentialsResponse, error) {
	return a.gitCredentialsImpl.Get(ctx, GetCredentialsRequest{
		CredentialId: credentialId,
	})
}

// CredentialInfoGitProviderToCredentialIdMap calls [GitCredentialsAPI.ListAll] and creates a map of results with [CredentialInfo].GitProvider as key and [CredentialInfo].CredentialId as value.
//
// Returns an error if there's more than one [CredentialInfo] with the same .GitProvider.
//
// Note: All [CredentialInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *GitCredentialsAPI) CredentialInfoGitProviderToCredentialIdMap(ctx context.Context) (map[string]int64, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]int64{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.GitProvider
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .GitProvider: %s", key)
		}
		mapping[key] = v.CredentialId
	}
	return mapping, nil
}

// GetByGitProvider calls [GitCredentialsAPI.CredentialInfoGitProviderToCredentialIdMap] and returns a single [CredentialInfo].
//
// Returns an error if there's more than one [CredentialInfo] with the same .GitProvider.
//
// Note: All [CredentialInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *GitCredentialsAPI) GetByGitProvider(ctx context.Context, name string) (*CredentialInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]CredentialInfo{}
	for _, v := range result {
		key := v.GitProvider
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("CredentialInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of CredentialInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ReposAPI struct {
	reposImpl
}

// Delete a repo.
//
// Deletes the specified repo.
func (a *ReposAPI) DeleteByRepoId(ctx context.Context, repoId int64) (*DeleteRepoResponse, error) {
	return a.reposImpl.Delete(ctx, DeleteRepoRequest{
		RepoId: repoId,
	})
}

// Get a repo.
//
// Returns the repo with the given repo ID.
func (a *ReposAPI) GetByRepoId(ctx context.Context, repoId int64) (*GetRepoResponse, error) {
	return a.reposImpl.Get(ctx, GetRepoRequest{
		RepoId: repoId,
	})
}

// Get repo permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *ReposAPI) GetPermissionLevelsByRepoId(ctx context.Context, repoId string) (*GetRepoPermissionLevelsResponse, error) {
	return a.reposImpl.GetPermissionLevels(ctx, GetRepoPermissionLevelsRequest{
		RepoId: repoId,
	})
}

// Get repo permissions.
//
// Gets the permissions of a repo. Repos can inherit permissions from their root
// object.
func (a *ReposAPI) GetPermissionsByRepoId(ctx context.Context, repoId string) (*RepoPermissions, error) {
	return a.reposImpl.GetPermissions(ctx, GetRepoPermissionsRequest{
		RepoId: repoId,
	})
}

// RepoInfoPathToIdMap calls [ReposAPI.ListAll] and creates a map of results with [RepoInfo].Path as key and [RepoInfo].Id as value.
//
// Returns an error if there's more than one [RepoInfo] with the same .Path.
//
// Note: All [RepoInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ReposAPI) RepoInfoPathToIdMap(ctx context.Context, request ListReposRequest) (map[string]int64, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]int64{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Path
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Path: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByPath calls [ReposAPI.RepoInfoPathToIdMap] and returns a single [RepoInfo].
//
// Returns an error if there's more than one [RepoInfo] with the same .Path.
//
// Note: All [RepoInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ReposAPI) GetByPath(ctx context.Context, name string) (*RepoInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListReposRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]RepoInfo{}
	for _, v := range result {
		key := v.Path
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("RepoInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of RepoInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type SecretsAPI struct {
	secretsImpl
}

// Delete a secret scope.
//
// Deletes a secret scope.
//
// Throws `RESOURCE_DOES_NOT_EXIST` if the scope does not exist. Throws
// `PERMISSION_DENIED` if the user does not have permission to make this API
// call.
func (a *SecretsAPI) DeleteScopeByScope(ctx context.Context, scope string) (*DeleteScopeResponse, error) {
	return a.secretsImpl.DeleteScope(ctx, DeleteScope{
		Scope: scope,
	})
}

// Lists ACLs.
//
// List the ACLs for a given secret scope. Users must have the `MANAGE`
// permission to invoke this API.
//
// Throws `RESOURCE_DOES_NOT_EXIST` if no such secret scope exists. Throws
// `PERMISSION_DENIED` if the user does not have permission to make this API
// call.
func (a *SecretsAPI) ListAclsByScope(ctx context.Context, scope string) (*ListAclsResponse, error) {
	return a.secretsImpl.internalListAcls(ctx, ListAclsRequest{
		Scope: scope,
	})
}

// List secret keys.
//
// Lists the secret keys that are stored at this scope. This is a metadata-only
// operation; secret data cannot be retrieved using this API. Users need the
// READ permission to make this call.
//
// The lastUpdatedTimestamp returned is in milliseconds since epoch. Throws
// `RESOURCE_DOES_NOT_EXIST` if no such secret scope exists. Throws
// `PERMISSION_DENIED` if the user does not have permission to make this API
// call.
func (a *SecretsAPI) ListSecretsByScope(ctx context.Context, scope string) (*ListSecretsResponse, error) {
	return a.secretsImpl.internalListSecrets(ctx, ListSecretsRequest{
		Scope: scope,
	})
}

type WorkspaceAPI struct {
	workspaceImpl
}

// Get workspace object permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *WorkspaceAPI) GetPermissionLevelsByWorkspaceObjectTypeAndWorkspaceObjectId(ctx context.Context, workspaceObjectType string, workspaceObjectId string) (*GetWorkspaceObjectPermissionLevelsResponse, error) {
	return a.workspaceImpl.GetPermissionLevels(ctx, GetWorkspaceObjectPermissionLevelsRequest{
		WorkspaceObjectType: workspaceObjectType,
		WorkspaceObjectId:   workspaceObjectId,
	})
}

// Get workspace object permissions.
//
// Gets the permissions of a workspace object. Workspace objects can inherit
// permissions from their parent objects or root object.
func (a *WorkspaceAPI) GetPermissionsByWorkspaceObjectTypeAndWorkspaceObjectId(ctx context.Context, workspaceObjectType string, workspaceObjectId string) (*WorkspaceObjectPermissions, error) {
	return a.workspaceImpl.GetPermissions(ctx, GetWorkspaceObjectPermissionsRequest{
		WorkspaceObjectType: workspaceObjectType,
		WorkspaceObjectId:   workspaceObjectId,
	})
}

// Get status.
//
// Gets the status of an object or a directory. If `path` does not exist, this
// call returns an error `RESOURCE_DOES_NOT_EXIST`.
func (a *WorkspaceAPI) GetStatusByPath(ctx context.Context, path string) (*ObjectInfo, error) {
	return a.workspaceImpl.GetStatus(ctx, GetStatusRequest{
		Path: path,
	})
}

// ObjectInfoPathToObjectIdMap calls [WorkspaceAPI.ListAll] and creates a map of results with [ObjectInfo].Path as key and [ObjectInfo].ObjectId as value.
//
// Returns an error if there's more than one [ObjectInfo] with the same .Path.
//
// Note: All [ObjectInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WorkspaceAPI) ObjectInfoPathToObjectIdMap(ctx context.Context, request ListWorkspaceRequest) (map[string]int64, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]int64{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Path
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Path: %s", key)
		}
		mapping[key] = v.ObjectId
	}
	return mapping, nil
}

// GetByPath calls [WorkspaceAPI.ObjectInfoPathToObjectIdMap] and returns a single [ObjectInfo].
//
// Returns an error if there's more than one [ObjectInfo] with the same .Path.
//
// Note: All [ObjectInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WorkspaceAPI) GetByPath(ctx context.Context, name string) (*ObjectInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListWorkspaceRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ObjectInfo{}
	for _, v := range result {
		key := v.Path
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ObjectInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ObjectInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Create a directory.
//
// Creates the specified directory (and necessary parent directories if they do
// not exist). If there is an object (not a directory) at any prefix of the
// input path, this call returns an error `RESOURCE_ALREADY_EXISTS`.
//
// Note that if this operation fails it may have succeeded in creating some of
// the necessary parent directories.
func (a *WorkspaceAPI) MkdirsByPath(ctx context.Context, path string) (*MkdirsResponse, error) {
	return a.workspaceImpl.Mkdirs(ctx, Mkdirs{
		Path: path,
	})
}
