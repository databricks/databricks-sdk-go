// Code generated by mockery v2.53.2. DO NOT EDIT.

package postgres

import (
	context "context"

	listing "github.com/databricks/databricks-sdk-go/listing"
	mock "github.com/stretchr/testify/mock"

	postgres "github.com/databricks/databricks-sdk-go/service/postgres"
)

// MockPostgresInterface is an autogenerated mock type for the PostgresInterface type
type MockPostgresInterface struct {
	mock.Mock
}

type MockPostgresInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPostgresInterface) EXPECT() *MockPostgresInterface_Expecter {
	return &MockPostgresInterface_Expecter{mock: &_m.Mock}
}

// CreateDatabaseBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) CreateDatabaseBranch(ctx context.Context, request postgres.CreateDatabaseBranchRequest) (postgres.CreateDatabaseBranchOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabaseBranch")
	}

	var r0 postgres.CreateDatabaseBranchOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateDatabaseBranchRequest) (postgres.CreateDatabaseBranchOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateDatabaseBranchRequest) postgres.CreateDatabaseBranchOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.CreateDatabaseBranchOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.CreateDatabaseBranchRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_CreateDatabaseBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDatabaseBranch'
type MockPostgresInterface_CreateDatabaseBranch_Call struct {
	*mock.Call
}

// CreateDatabaseBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.CreateDatabaseBranchRequest
func (_e *MockPostgresInterface_Expecter) CreateDatabaseBranch(ctx interface{}, request interface{}) *MockPostgresInterface_CreateDatabaseBranch_Call {
	return &MockPostgresInterface_CreateDatabaseBranch_Call{Call: _e.mock.On("CreateDatabaseBranch", ctx, request)}
}

func (_c *MockPostgresInterface_CreateDatabaseBranch_Call) Run(run func(ctx context.Context, request postgres.CreateDatabaseBranchRequest)) *MockPostgresInterface_CreateDatabaseBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.CreateDatabaseBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_CreateDatabaseBranch_Call) Return(_a0 postgres.CreateDatabaseBranchOperationInterface, _a1 error) *MockPostgresInterface_CreateDatabaseBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_CreateDatabaseBranch_Call) RunAndReturn(run func(context.Context, postgres.CreateDatabaseBranchRequest) (postgres.CreateDatabaseBranchOperationInterface, error)) *MockPostgresInterface_CreateDatabaseBranch_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDatabaseEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) CreateDatabaseEndpoint(ctx context.Context, request postgres.CreateDatabaseEndpointRequest) (postgres.CreateDatabaseEndpointOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabaseEndpoint")
	}

	var r0 postgres.CreateDatabaseEndpointOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateDatabaseEndpointRequest) (postgres.CreateDatabaseEndpointOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateDatabaseEndpointRequest) postgres.CreateDatabaseEndpointOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.CreateDatabaseEndpointOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.CreateDatabaseEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_CreateDatabaseEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDatabaseEndpoint'
type MockPostgresInterface_CreateDatabaseEndpoint_Call struct {
	*mock.Call
}

// CreateDatabaseEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.CreateDatabaseEndpointRequest
func (_e *MockPostgresInterface_Expecter) CreateDatabaseEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_CreateDatabaseEndpoint_Call {
	return &MockPostgresInterface_CreateDatabaseEndpoint_Call{Call: _e.mock.On("CreateDatabaseEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_CreateDatabaseEndpoint_Call) Run(run func(ctx context.Context, request postgres.CreateDatabaseEndpointRequest)) *MockPostgresInterface_CreateDatabaseEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.CreateDatabaseEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_CreateDatabaseEndpoint_Call) Return(_a0 postgres.CreateDatabaseEndpointOperationInterface, _a1 error) *MockPostgresInterface_CreateDatabaseEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_CreateDatabaseEndpoint_Call) RunAndReturn(run func(context.Context, postgres.CreateDatabaseEndpointRequest) (postgres.CreateDatabaseEndpointOperationInterface, error)) *MockPostgresInterface_CreateDatabaseEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDatabaseProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) CreateDatabaseProject(ctx context.Context, request postgres.CreateDatabaseProjectRequest) (postgres.CreateDatabaseProjectOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabaseProject")
	}

	var r0 postgres.CreateDatabaseProjectOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateDatabaseProjectRequest) (postgres.CreateDatabaseProjectOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateDatabaseProjectRequest) postgres.CreateDatabaseProjectOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.CreateDatabaseProjectOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.CreateDatabaseProjectRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_CreateDatabaseProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDatabaseProject'
type MockPostgresInterface_CreateDatabaseProject_Call struct {
	*mock.Call
}

// CreateDatabaseProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.CreateDatabaseProjectRequest
func (_e *MockPostgresInterface_Expecter) CreateDatabaseProject(ctx interface{}, request interface{}) *MockPostgresInterface_CreateDatabaseProject_Call {
	return &MockPostgresInterface_CreateDatabaseProject_Call{Call: _e.mock.On("CreateDatabaseProject", ctx, request)}
}

func (_c *MockPostgresInterface_CreateDatabaseProject_Call) Run(run func(ctx context.Context, request postgres.CreateDatabaseProjectRequest)) *MockPostgresInterface_CreateDatabaseProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.CreateDatabaseProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_CreateDatabaseProject_Call) Return(_a0 postgres.CreateDatabaseProjectOperationInterface, _a1 error) *MockPostgresInterface_CreateDatabaseProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_CreateDatabaseProject_Call) RunAndReturn(run func(context.Context, postgres.CreateDatabaseProjectRequest) (postgres.CreateDatabaseProjectOperationInterface, error)) *MockPostgresInterface_CreateDatabaseProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDatabaseBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) DeleteDatabaseBranch(ctx context.Context, request postgres.DeleteDatabaseBranchRequest) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDatabaseBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteDatabaseBranchRequest) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockPostgresInterface_DeleteDatabaseBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDatabaseBranch'
type MockPostgresInterface_DeleteDatabaseBranch_Call struct {
	*mock.Call
}

// DeleteDatabaseBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.DeleteDatabaseBranchRequest
func (_e *MockPostgresInterface_Expecter) DeleteDatabaseBranch(ctx interface{}, request interface{}) *MockPostgresInterface_DeleteDatabaseBranch_Call {
	return &MockPostgresInterface_DeleteDatabaseBranch_Call{Call: _e.mock.On("DeleteDatabaseBranch", ctx, request)}
}

func (_c *MockPostgresInterface_DeleteDatabaseBranch_Call) Run(run func(ctx context.Context, request postgres.DeleteDatabaseBranchRequest)) *MockPostgresInterface_DeleteDatabaseBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.DeleteDatabaseBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_DeleteDatabaseBranch_Call) Return(_a0 error) *MockPostgresInterface_DeleteDatabaseBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_DeleteDatabaseBranch_Call) RunAndReturn(run func(context.Context, postgres.DeleteDatabaseBranchRequest) error) *MockPostgresInterface_DeleteDatabaseBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDatabaseEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) DeleteDatabaseEndpoint(ctx context.Context, request postgres.DeleteDatabaseEndpointRequest) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDatabaseEndpoint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteDatabaseEndpointRequest) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockPostgresInterface_DeleteDatabaseEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDatabaseEndpoint'
type MockPostgresInterface_DeleteDatabaseEndpoint_Call struct {
	*mock.Call
}

// DeleteDatabaseEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.DeleteDatabaseEndpointRequest
func (_e *MockPostgresInterface_Expecter) DeleteDatabaseEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_DeleteDatabaseEndpoint_Call {
	return &MockPostgresInterface_DeleteDatabaseEndpoint_Call{Call: _e.mock.On("DeleteDatabaseEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_DeleteDatabaseEndpoint_Call) Run(run func(ctx context.Context, request postgres.DeleteDatabaseEndpointRequest)) *MockPostgresInterface_DeleteDatabaseEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.DeleteDatabaseEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_DeleteDatabaseEndpoint_Call) Return(_a0 error) *MockPostgresInterface_DeleteDatabaseEndpoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_DeleteDatabaseEndpoint_Call) RunAndReturn(run func(context.Context, postgres.DeleteDatabaseEndpointRequest) error) *MockPostgresInterface_DeleteDatabaseEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDatabaseProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) DeleteDatabaseProject(ctx context.Context, request postgres.DeleteDatabaseProjectRequest) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDatabaseProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteDatabaseProjectRequest) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockPostgresInterface_DeleteDatabaseProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDatabaseProject'
type MockPostgresInterface_DeleteDatabaseProject_Call struct {
	*mock.Call
}

// DeleteDatabaseProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.DeleteDatabaseProjectRequest
func (_e *MockPostgresInterface_Expecter) DeleteDatabaseProject(ctx interface{}, request interface{}) *MockPostgresInterface_DeleteDatabaseProject_Call {
	return &MockPostgresInterface_DeleteDatabaseProject_Call{Call: _e.mock.On("DeleteDatabaseProject", ctx, request)}
}

func (_c *MockPostgresInterface_DeleteDatabaseProject_Call) Run(run func(ctx context.Context, request postgres.DeleteDatabaseProjectRequest)) *MockPostgresInterface_DeleteDatabaseProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.DeleteDatabaseProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_DeleteDatabaseProject_Call) Return(_a0 error) *MockPostgresInterface_DeleteDatabaseProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_DeleteDatabaseProject_Call) RunAndReturn(run func(context.Context, postgres.DeleteDatabaseProjectRequest) error) *MockPostgresInterface_DeleteDatabaseProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabaseBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetDatabaseBranch(ctx context.Context, request postgres.GetDatabaseBranchRequest) (*postgres.DatabaseBranch, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabaseBranch")
	}

	var r0 *postgres.DatabaseBranch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetDatabaseBranchRequest) (*postgres.DatabaseBranch, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetDatabaseBranchRequest) *postgres.DatabaseBranch); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.DatabaseBranch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetDatabaseBranchRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetDatabaseBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabaseBranch'
type MockPostgresInterface_GetDatabaseBranch_Call struct {
	*mock.Call
}

// GetDatabaseBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetDatabaseBranchRequest
func (_e *MockPostgresInterface_Expecter) GetDatabaseBranch(ctx interface{}, request interface{}) *MockPostgresInterface_GetDatabaseBranch_Call {
	return &MockPostgresInterface_GetDatabaseBranch_Call{Call: _e.mock.On("GetDatabaseBranch", ctx, request)}
}

func (_c *MockPostgresInterface_GetDatabaseBranch_Call) Run(run func(ctx context.Context, request postgres.GetDatabaseBranchRequest)) *MockPostgresInterface_GetDatabaseBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetDatabaseBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseBranch_Call) Return(_a0 *postgres.DatabaseBranch, _a1 error) *MockPostgresInterface_GetDatabaseBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseBranch_Call) RunAndReturn(run func(context.Context, postgres.GetDatabaseBranchRequest) (*postgres.DatabaseBranch, error)) *MockPostgresInterface_GetDatabaseBranch_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabaseEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetDatabaseEndpoint(ctx context.Context, request postgres.GetDatabaseEndpointRequest) (*postgres.DatabaseEndpoint, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabaseEndpoint")
	}

	var r0 *postgres.DatabaseEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetDatabaseEndpointRequest) (*postgres.DatabaseEndpoint, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetDatabaseEndpointRequest) *postgres.DatabaseEndpoint); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.DatabaseEndpoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetDatabaseEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetDatabaseEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabaseEndpoint'
type MockPostgresInterface_GetDatabaseEndpoint_Call struct {
	*mock.Call
}

// GetDatabaseEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetDatabaseEndpointRequest
func (_e *MockPostgresInterface_Expecter) GetDatabaseEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_GetDatabaseEndpoint_Call {
	return &MockPostgresInterface_GetDatabaseEndpoint_Call{Call: _e.mock.On("GetDatabaseEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_GetDatabaseEndpoint_Call) Run(run func(ctx context.Context, request postgres.GetDatabaseEndpointRequest)) *MockPostgresInterface_GetDatabaseEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetDatabaseEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseEndpoint_Call) Return(_a0 *postgres.DatabaseEndpoint, _a1 error) *MockPostgresInterface_GetDatabaseEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseEndpoint_Call) RunAndReturn(run func(context.Context, postgres.GetDatabaseEndpointRequest) (*postgres.DatabaseEndpoint, error)) *MockPostgresInterface_GetDatabaseEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabaseOperation provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetDatabaseOperation(ctx context.Context, request postgres.GetOperationRequest) (*postgres.Operation, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabaseOperation")
	}

	var r0 *postgres.Operation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetOperationRequest) (*postgres.Operation, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetOperationRequest) *postgres.Operation); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.Operation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetOperationRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetDatabaseOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabaseOperation'
type MockPostgresInterface_GetDatabaseOperation_Call struct {
	*mock.Call
}

// GetDatabaseOperation is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetOperationRequest
func (_e *MockPostgresInterface_Expecter) GetDatabaseOperation(ctx interface{}, request interface{}) *MockPostgresInterface_GetDatabaseOperation_Call {
	return &MockPostgresInterface_GetDatabaseOperation_Call{Call: _e.mock.On("GetDatabaseOperation", ctx, request)}
}

func (_c *MockPostgresInterface_GetDatabaseOperation_Call) Run(run func(ctx context.Context, request postgres.GetOperationRequest)) *MockPostgresInterface_GetDatabaseOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetOperationRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseOperation_Call) Return(_a0 *postgres.Operation, _a1 error) *MockPostgresInterface_GetDatabaseOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseOperation_Call) RunAndReturn(run func(context.Context, postgres.GetOperationRequest) (*postgres.Operation, error)) *MockPostgresInterface_GetDatabaseOperation_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabaseProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetDatabaseProject(ctx context.Context, request postgres.GetDatabaseProjectRequest) (*postgres.DatabaseProject, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabaseProject")
	}

	var r0 *postgres.DatabaseProject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetDatabaseProjectRequest) (*postgres.DatabaseProject, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetDatabaseProjectRequest) *postgres.DatabaseProject); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.DatabaseProject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetDatabaseProjectRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetDatabaseProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabaseProject'
type MockPostgresInterface_GetDatabaseProject_Call struct {
	*mock.Call
}

// GetDatabaseProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetDatabaseProjectRequest
func (_e *MockPostgresInterface_Expecter) GetDatabaseProject(ctx interface{}, request interface{}) *MockPostgresInterface_GetDatabaseProject_Call {
	return &MockPostgresInterface_GetDatabaseProject_Call{Call: _e.mock.On("GetDatabaseProject", ctx, request)}
}

func (_c *MockPostgresInterface_GetDatabaseProject_Call) Run(run func(ctx context.Context, request postgres.GetDatabaseProjectRequest)) *MockPostgresInterface_GetDatabaseProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetDatabaseProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseProject_Call) Return(_a0 *postgres.DatabaseProject, _a1 error) *MockPostgresInterface_GetDatabaseProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetDatabaseProject_Call) RunAndReturn(run func(context.Context, postgres.GetDatabaseProjectRequest) (*postgres.DatabaseProject, error)) *MockPostgresInterface_GetDatabaseProject_Call {
	_c.Call.Return(run)
	return _c
}

// ListDatabaseBranches provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListDatabaseBranches(ctx context.Context, request postgres.ListDatabaseBranchesRequest) listing.Iterator[postgres.DatabaseBranch] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabaseBranches")
	}

	var r0 listing.Iterator[postgres.DatabaseBranch]
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseBranchesRequest) listing.Iterator[postgres.DatabaseBranch]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[postgres.DatabaseBranch])
		}
	}

	return r0
}

// MockPostgresInterface_ListDatabaseBranches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDatabaseBranches'
type MockPostgresInterface_ListDatabaseBranches_Call struct {
	*mock.Call
}

// ListDatabaseBranches is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListDatabaseBranchesRequest
func (_e *MockPostgresInterface_Expecter) ListDatabaseBranches(ctx interface{}, request interface{}) *MockPostgresInterface_ListDatabaseBranches_Call {
	return &MockPostgresInterface_ListDatabaseBranches_Call{Call: _e.mock.On("ListDatabaseBranches", ctx, request)}
}

func (_c *MockPostgresInterface_ListDatabaseBranches_Call) Run(run func(ctx context.Context, request postgres.ListDatabaseBranchesRequest)) *MockPostgresInterface_ListDatabaseBranches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListDatabaseBranchesRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseBranches_Call) Return(_a0 listing.Iterator[postgres.DatabaseBranch]) *MockPostgresInterface_ListDatabaseBranches_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseBranches_Call) RunAndReturn(run func(context.Context, postgres.ListDatabaseBranchesRequest) listing.Iterator[postgres.DatabaseBranch]) *MockPostgresInterface_ListDatabaseBranches_Call {
	_c.Call.Return(run)
	return _c
}

// ListDatabaseBranchesAll provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListDatabaseBranchesAll(ctx context.Context, request postgres.ListDatabaseBranchesRequest) ([]postgres.DatabaseBranch, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabaseBranchesAll")
	}

	var r0 []postgres.DatabaseBranch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseBranchesRequest) ([]postgres.DatabaseBranch, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseBranchesRequest) []postgres.DatabaseBranch); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]postgres.DatabaseBranch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.ListDatabaseBranchesRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_ListDatabaseBranchesAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDatabaseBranchesAll'
type MockPostgresInterface_ListDatabaseBranchesAll_Call struct {
	*mock.Call
}

// ListDatabaseBranchesAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListDatabaseBranchesRequest
func (_e *MockPostgresInterface_Expecter) ListDatabaseBranchesAll(ctx interface{}, request interface{}) *MockPostgresInterface_ListDatabaseBranchesAll_Call {
	return &MockPostgresInterface_ListDatabaseBranchesAll_Call{Call: _e.mock.On("ListDatabaseBranchesAll", ctx, request)}
}

func (_c *MockPostgresInterface_ListDatabaseBranchesAll_Call) Run(run func(ctx context.Context, request postgres.ListDatabaseBranchesRequest)) *MockPostgresInterface_ListDatabaseBranchesAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListDatabaseBranchesRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseBranchesAll_Call) Return(_a0 []postgres.DatabaseBranch, _a1 error) *MockPostgresInterface_ListDatabaseBranchesAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseBranchesAll_Call) RunAndReturn(run func(context.Context, postgres.ListDatabaseBranchesRequest) ([]postgres.DatabaseBranch, error)) *MockPostgresInterface_ListDatabaseBranchesAll_Call {
	_c.Call.Return(run)
	return _c
}

// ListDatabaseEndpoints provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListDatabaseEndpoints(ctx context.Context, request postgres.ListDatabaseEndpointsRequest) listing.Iterator[postgres.DatabaseEndpoint] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabaseEndpoints")
	}

	var r0 listing.Iterator[postgres.DatabaseEndpoint]
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseEndpointsRequest) listing.Iterator[postgres.DatabaseEndpoint]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[postgres.DatabaseEndpoint])
		}
	}

	return r0
}

// MockPostgresInterface_ListDatabaseEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDatabaseEndpoints'
type MockPostgresInterface_ListDatabaseEndpoints_Call struct {
	*mock.Call
}

// ListDatabaseEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListDatabaseEndpointsRequest
func (_e *MockPostgresInterface_Expecter) ListDatabaseEndpoints(ctx interface{}, request interface{}) *MockPostgresInterface_ListDatabaseEndpoints_Call {
	return &MockPostgresInterface_ListDatabaseEndpoints_Call{Call: _e.mock.On("ListDatabaseEndpoints", ctx, request)}
}

func (_c *MockPostgresInterface_ListDatabaseEndpoints_Call) Run(run func(ctx context.Context, request postgres.ListDatabaseEndpointsRequest)) *MockPostgresInterface_ListDatabaseEndpoints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListDatabaseEndpointsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseEndpoints_Call) Return(_a0 listing.Iterator[postgres.DatabaseEndpoint]) *MockPostgresInterface_ListDatabaseEndpoints_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseEndpoints_Call) RunAndReturn(run func(context.Context, postgres.ListDatabaseEndpointsRequest) listing.Iterator[postgres.DatabaseEndpoint]) *MockPostgresInterface_ListDatabaseEndpoints_Call {
	_c.Call.Return(run)
	return _c
}

// ListDatabaseEndpointsAll provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListDatabaseEndpointsAll(ctx context.Context, request postgres.ListDatabaseEndpointsRequest) ([]postgres.DatabaseEndpoint, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabaseEndpointsAll")
	}

	var r0 []postgres.DatabaseEndpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseEndpointsRequest) ([]postgres.DatabaseEndpoint, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseEndpointsRequest) []postgres.DatabaseEndpoint); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]postgres.DatabaseEndpoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.ListDatabaseEndpointsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_ListDatabaseEndpointsAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDatabaseEndpointsAll'
type MockPostgresInterface_ListDatabaseEndpointsAll_Call struct {
	*mock.Call
}

// ListDatabaseEndpointsAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListDatabaseEndpointsRequest
func (_e *MockPostgresInterface_Expecter) ListDatabaseEndpointsAll(ctx interface{}, request interface{}) *MockPostgresInterface_ListDatabaseEndpointsAll_Call {
	return &MockPostgresInterface_ListDatabaseEndpointsAll_Call{Call: _e.mock.On("ListDatabaseEndpointsAll", ctx, request)}
}

func (_c *MockPostgresInterface_ListDatabaseEndpointsAll_Call) Run(run func(ctx context.Context, request postgres.ListDatabaseEndpointsRequest)) *MockPostgresInterface_ListDatabaseEndpointsAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListDatabaseEndpointsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseEndpointsAll_Call) Return(_a0 []postgres.DatabaseEndpoint, _a1 error) *MockPostgresInterface_ListDatabaseEndpointsAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseEndpointsAll_Call) RunAndReturn(run func(context.Context, postgres.ListDatabaseEndpointsRequest) ([]postgres.DatabaseEndpoint, error)) *MockPostgresInterface_ListDatabaseEndpointsAll_Call {
	_c.Call.Return(run)
	return _c
}

// ListDatabaseProjects provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListDatabaseProjects(ctx context.Context, request postgres.ListDatabaseProjectsRequest) listing.Iterator[postgres.DatabaseProject] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabaseProjects")
	}

	var r0 listing.Iterator[postgres.DatabaseProject]
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseProjectsRequest) listing.Iterator[postgres.DatabaseProject]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[postgres.DatabaseProject])
		}
	}

	return r0
}

// MockPostgresInterface_ListDatabaseProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDatabaseProjects'
type MockPostgresInterface_ListDatabaseProjects_Call struct {
	*mock.Call
}

// ListDatabaseProjects is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListDatabaseProjectsRequest
func (_e *MockPostgresInterface_Expecter) ListDatabaseProjects(ctx interface{}, request interface{}) *MockPostgresInterface_ListDatabaseProjects_Call {
	return &MockPostgresInterface_ListDatabaseProjects_Call{Call: _e.mock.On("ListDatabaseProjects", ctx, request)}
}

func (_c *MockPostgresInterface_ListDatabaseProjects_Call) Run(run func(ctx context.Context, request postgres.ListDatabaseProjectsRequest)) *MockPostgresInterface_ListDatabaseProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListDatabaseProjectsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseProjects_Call) Return(_a0 listing.Iterator[postgres.DatabaseProject]) *MockPostgresInterface_ListDatabaseProjects_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseProjects_Call) RunAndReturn(run func(context.Context, postgres.ListDatabaseProjectsRequest) listing.Iterator[postgres.DatabaseProject]) *MockPostgresInterface_ListDatabaseProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListDatabaseProjectsAll provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListDatabaseProjectsAll(ctx context.Context, request postgres.ListDatabaseProjectsRequest) ([]postgres.DatabaseProject, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabaseProjectsAll")
	}

	var r0 []postgres.DatabaseProject
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseProjectsRequest) ([]postgres.DatabaseProject, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListDatabaseProjectsRequest) []postgres.DatabaseProject); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]postgres.DatabaseProject)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.ListDatabaseProjectsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_ListDatabaseProjectsAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDatabaseProjectsAll'
type MockPostgresInterface_ListDatabaseProjectsAll_Call struct {
	*mock.Call
}

// ListDatabaseProjectsAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListDatabaseProjectsRequest
func (_e *MockPostgresInterface_Expecter) ListDatabaseProjectsAll(ctx interface{}, request interface{}) *MockPostgresInterface_ListDatabaseProjectsAll_Call {
	return &MockPostgresInterface_ListDatabaseProjectsAll_Call{Call: _e.mock.On("ListDatabaseProjectsAll", ctx, request)}
}

func (_c *MockPostgresInterface_ListDatabaseProjectsAll_Call) Run(run func(ctx context.Context, request postgres.ListDatabaseProjectsRequest)) *MockPostgresInterface_ListDatabaseProjectsAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListDatabaseProjectsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseProjectsAll_Call) Return(_a0 []postgres.DatabaseProject, _a1 error) *MockPostgresInterface_ListDatabaseProjectsAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_ListDatabaseProjectsAll_Call) RunAndReturn(run func(context.Context, postgres.ListDatabaseProjectsRequest) ([]postgres.DatabaseProject, error)) *MockPostgresInterface_ListDatabaseProjectsAll_Call {
	_c.Call.Return(run)
	return _c
}

// RestartDatabaseEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) RestartDatabaseEndpoint(ctx context.Context, request postgres.RestartDatabaseEndpointRequest) (postgres.RestartDatabaseEndpointOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for RestartDatabaseEndpoint")
	}

	var r0 postgres.RestartDatabaseEndpointOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.RestartDatabaseEndpointRequest) (postgres.RestartDatabaseEndpointOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.RestartDatabaseEndpointRequest) postgres.RestartDatabaseEndpointOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.RestartDatabaseEndpointOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.RestartDatabaseEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_RestartDatabaseEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestartDatabaseEndpoint'
type MockPostgresInterface_RestartDatabaseEndpoint_Call struct {
	*mock.Call
}

// RestartDatabaseEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.RestartDatabaseEndpointRequest
func (_e *MockPostgresInterface_Expecter) RestartDatabaseEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_RestartDatabaseEndpoint_Call {
	return &MockPostgresInterface_RestartDatabaseEndpoint_Call{Call: _e.mock.On("RestartDatabaseEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_RestartDatabaseEndpoint_Call) Run(run func(ctx context.Context, request postgres.RestartDatabaseEndpointRequest)) *MockPostgresInterface_RestartDatabaseEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.RestartDatabaseEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_RestartDatabaseEndpoint_Call) Return(_a0 postgres.RestartDatabaseEndpointOperationInterface, _a1 error) *MockPostgresInterface_RestartDatabaseEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_RestartDatabaseEndpoint_Call) RunAndReturn(run func(context.Context, postgres.RestartDatabaseEndpointRequest) (postgres.RestartDatabaseEndpointOperationInterface, error)) *MockPostgresInterface_RestartDatabaseEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDatabaseBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) UpdateDatabaseBranch(ctx context.Context, request postgres.UpdateDatabaseBranchRequest) (postgres.UpdateDatabaseBranchOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatabaseBranch")
	}

	var r0 postgres.UpdateDatabaseBranchOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateDatabaseBranchRequest) (postgres.UpdateDatabaseBranchOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateDatabaseBranchRequest) postgres.UpdateDatabaseBranchOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.UpdateDatabaseBranchOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.UpdateDatabaseBranchRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_UpdateDatabaseBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDatabaseBranch'
type MockPostgresInterface_UpdateDatabaseBranch_Call struct {
	*mock.Call
}

// UpdateDatabaseBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.UpdateDatabaseBranchRequest
func (_e *MockPostgresInterface_Expecter) UpdateDatabaseBranch(ctx interface{}, request interface{}) *MockPostgresInterface_UpdateDatabaseBranch_Call {
	return &MockPostgresInterface_UpdateDatabaseBranch_Call{Call: _e.mock.On("UpdateDatabaseBranch", ctx, request)}
}

func (_c *MockPostgresInterface_UpdateDatabaseBranch_Call) Run(run func(ctx context.Context, request postgres.UpdateDatabaseBranchRequest)) *MockPostgresInterface_UpdateDatabaseBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.UpdateDatabaseBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_UpdateDatabaseBranch_Call) Return(_a0 postgres.UpdateDatabaseBranchOperationInterface, _a1 error) *MockPostgresInterface_UpdateDatabaseBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_UpdateDatabaseBranch_Call) RunAndReturn(run func(context.Context, postgres.UpdateDatabaseBranchRequest) (postgres.UpdateDatabaseBranchOperationInterface, error)) *MockPostgresInterface_UpdateDatabaseBranch_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDatabaseEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) UpdateDatabaseEndpoint(ctx context.Context, request postgres.UpdateDatabaseEndpointRequest) (postgres.UpdateDatabaseEndpointOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatabaseEndpoint")
	}

	var r0 postgres.UpdateDatabaseEndpointOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateDatabaseEndpointRequest) (postgres.UpdateDatabaseEndpointOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateDatabaseEndpointRequest) postgres.UpdateDatabaseEndpointOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.UpdateDatabaseEndpointOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.UpdateDatabaseEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_UpdateDatabaseEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDatabaseEndpoint'
type MockPostgresInterface_UpdateDatabaseEndpoint_Call struct {
	*mock.Call
}

// UpdateDatabaseEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.UpdateDatabaseEndpointRequest
func (_e *MockPostgresInterface_Expecter) UpdateDatabaseEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_UpdateDatabaseEndpoint_Call {
	return &MockPostgresInterface_UpdateDatabaseEndpoint_Call{Call: _e.mock.On("UpdateDatabaseEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_UpdateDatabaseEndpoint_Call) Run(run func(ctx context.Context, request postgres.UpdateDatabaseEndpointRequest)) *MockPostgresInterface_UpdateDatabaseEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.UpdateDatabaseEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_UpdateDatabaseEndpoint_Call) Return(_a0 postgres.UpdateDatabaseEndpointOperationInterface, _a1 error) *MockPostgresInterface_UpdateDatabaseEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_UpdateDatabaseEndpoint_Call) RunAndReturn(run func(context.Context, postgres.UpdateDatabaseEndpointRequest) (postgres.UpdateDatabaseEndpointOperationInterface, error)) *MockPostgresInterface_UpdateDatabaseEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDatabaseProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) UpdateDatabaseProject(ctx context.Context, request postgres.UpdateDatabaseProjectRequest) (postgres.UpdateDatabaseProjectOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatabaseProject")
	}

	var r0 postgres.UpdateDatabaseProjectOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateDatabaseProjectRequest) (postgres.UpdateDatabaseProjectOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateDatabaseProjectRequest) postgres.UpdateDatabaseProjectOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.UpdateDatabaseProjectOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.UpdateDatabaseProjectRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_UpdateDatabaseProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDatabaseProject'
type MockPostgresInterface_UpdateDatabaseProject_Call struct {
	*mock.Call
}

// UpdateDatabaseProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.UpdateDatabaseProjectRequest
func (_e *MockPostgresInterface_Expecter) UpdateDatabaseProject(ctx interface{}, request interface{}) *MockPostgresInterface_UpdateDatabaseProject_Call {
	return &MockPostgresInterface_UpdateDatabaseProject_Call{Call: _e.mock.On("UpdateDatabaseProject", ctx, request)}
}

func (_c *MockPostgresInterface_UpdateDatabaseProject_Call) Run(run func(ctx context.Context, request postgres.UpdateDatabaseProjectRequest)) *MockPostgresInterface_UpdateDatabaseProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.UpdateDatabaseProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_UpdateDatabaseProject_Call) Return(_a0 postgres.UpdateDatabaseProjectOperationInterface, _a1 error) *MockPostgresInterface_UpdateDatabaseProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_UpdateDatabaseProject_Call) RunAndReturn(run func(context.Context, postgres.UpdateDatabaseProjectRequest) (postgres.UpdateDatabaseProjectOperationInterface, error)) *MockPostgresInterface_UpdateDatabaseProject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPostgresInterface creates a new instance of MockPostgresInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPostgresInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPostgresInterface {
	mock := &MockPostgresInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
