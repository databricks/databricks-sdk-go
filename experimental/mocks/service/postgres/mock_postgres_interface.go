// Code generated by mockery v2.53.2. DO NOT EDIT.

package postgres

import (
	context "context"

	listing "github.com/databricks/databricks-sdk-go/listing"
	mock "github.com/stretchr/testify/mock"

	postgres "github.com/databricks/databricks-sdk-go/service/postgres"
)

// MockPostgresInterface is an autogenerated mock type for the PostgresInterface type
type MockPostgresInterface struct {
	mock.Mock
}

type MockPostgresInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPostgresInterface) EXPECT() *MockPostgresInterface_Expecter {
	return &MockPostgresInterface_Expecter{mock: &_m.Mock}
}

// CreateBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) CreateBranch(ctx context.Context, request postgres.CreateBranchRequest) (postgres.CreateBranchOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranch")
	}

	var r0 postgres.CreateBranchOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateBranchRequest) (postgres.CreateBranchOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateBranchRequest) postgres.CreateBranchOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.CreateBranchOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.CreateBranchRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_CreateBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranch'
type MockPostgresInterface_CreateBranch_Call struct {
	*mock.Call
}

// CreateBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.CreateBranchRequest
func (_e *MockPostgresInterface_Expecter) CreateBranch(ctx interface{}, request interface{}) *MockPostgresInterface_CreateBranch_Call {
	return &MockPostgresInterface_CreateBranch_Call{Call: _e.mock.On("CreateBranch", ctx, request)}
}

func (_c *MockPostgresInterface_CreateBranch_Call) Run(run func(ctx context.Context, request postgres.CreateBranchRequest)) *MockPostgresInterface_CreateBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.CreateBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_CreateBranch_Call) Return(_a0 postgres.CreateBranchOperationInterface, _a1 error) *MockPostgresInterface_CreateBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_CreateBranch_Call) RunAndReturn(run func(context.Context, postgres.CreateBranchRequest) (postgres.CreateBranchOperationInterface, error)) *MockPostgresInterface_CreateBranch_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) CreateEndpoint(ctx context.Context, request postgres.CreateEndpointRequest) (postgres.CreateEndpointOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateEndpoint")
	}

	var r0 postgres.CreateEndpointOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateEndpointRequest) (postgres.CreateEndpointOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateEndpointRequest) postgres.CreateEndpointOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.CreateEndpointOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.CreateEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_CreateEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEndpoint'
type MockPostgresInterface_CreateEndpoint_Call struct {
	*mock.Call
}

// CreateEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.CreateEndpointRequest
func (_e *MockPostgresInterface_Expecter) CreateEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_CreateEndpoint_Call {
	return &MockPostgresInterface_CreateEndpoint_Call{Call: _e.mock.On("CreateEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_CreateEndpoint_Call) Run(run func(ctx context.Context, request postgres.CreateEndpointRequest)) *MockPostgresInterface_CreateEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.CreateEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_CreateEndpoint_Call) Return(_a0 postgres.CreateEndpointOperationInterface, _a1 error) *MockPostgresInterface_CreateEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_CreateEndpoint_Call) RunAndReturn(run func(context.Context, postgres.CreateEndpointRequest) (postgres.CreateEndpointOperationInterface, error)) *MockPostgresInterface_CreateEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) CreateProject(ctx context.Context, request postgres.CreateProjectRequest) (postgres.CreateProjectOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 postgres.CreateProjectOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateProjectRequest) (postgres.CreateProjectOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateProjectRequest) postgres.CreateProjectOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.CreateProjectOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.CreateProjectRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type MockPostgresInterface_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.CreateProjectRequest
func (_e *MockPostgresInterface_Expecter) CreateProject(ctx interface{}, request interface{}) *MockPostgresInterface_CreateProject_Call {
	return &MockPostgresInterface_CreateProject_Call{Call: _e.mock.On("CreateProject", ctx, request)}
}

func (_c *MockPostgresInterface_CreateProject_Call) Run(run func(ctx context.Context, request postgres.CreateProjectRequest)) *MockPostgresInterface_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.CreateProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_CreateProject_Call) Return(_a0 postgres.CreateProjectOperationInterface, _a1 error) *MockPostgresInterface_CreateProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_CreateProject_Call) RunAndReturn(run func(context.Context, postgres.CreateProjectRequest) (postgres.CreateProjectOperationInterface, error)) *MockPostgresInterface_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRole provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) CreateRole(ctx context.Context, request postgres.CreateRoleRequest) (postgres.CreateRoleOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateRole")
	}

	var r0 postgres.CreateRoleOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateRoleRequest) (postgres.CreateRoleOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.CreateRoleRequest) postgres.CreateRoleOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.CreateRoleOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.CreateRoleRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_CreateRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRole'
type MockPostgresInterface_CreateRole_Call struct {
	*mock.Call
}

// CreateRole is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.CreateRoleRequest
func (_e *MockPostgresInterface_Expecter) CreateRole(ctx interface{}, request interface{}) *MockPostgresInterface_CreateRole_Call {
	return &MockPostgresInterface_CreateRole_Call{Call: _e.mock.On("CreateRole", ctx, request)}
}

func (_c *MockPostgresInterface_CreateRole_Call) Run(run func(ctx context.Context, request postgres.CreateRoleRequest)) *MockPostgresInterface_CreateRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.CreateRoleRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_CreateRole_Call) Return(_a0 postgres.CreateRoleOperationInterface, _a1 error) *MockPostgresInterface_CreateRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_CreateRole_Call) RunAndReturn(run func(context.Context, postgres.CreateRoleRequest) (postgres.CreateRoleOperationInterface, error)) *MockPostgresInterface_CreateRole_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) DeleteBranch(ctx context.Context, request postgres.DeleteBranchRequest) (postgres.DeleteBranchOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBranch")
	}

	var r0 postgres.DeleteBranchOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteBranchRequest) (postgres.DeleteBranchOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteBranchRequest) postgres.DeleteBranchOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.DeleteBranchOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.DeleteBranchRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_DeleteBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBranch'
type MockPostgresInterface_DeleteBranch_Call struct {
	*mock.Call
}

// DeleteBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.DeleteBranchRequest
func (_e *MockPostgresInterface_Expecter) DeleteBranch(ctx interface{}, request interface{}) *MockPostgresInterface_DeleteBranch_Call {
	return &MockPostgresInterface_DeleteBranch_Call{Call: _e.mock.On("DeleteBranch", ctx, request)}
}

func (_c *MockPostgresInterface_DeleteBranch_Call) Run(run func(ctx context.Context, request postgres.DeleteBranchRequest)) *MockPostgresInterface_DeleteBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.DeleteBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_DeleteBranch_Call) Return(_a0 postgres.DeleteBranchOperationInterface, _a1 error) *MockPostgresInterface_DeleteBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_DeleteBranch_Call) RunAndReturn(run func(context.Context, postgres.DeleteBranchRequest) (postgres.DeleteBranchOperationInterface, error)) *MockPostgresInterface_DeleteBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) DeleteEndpoint(ctx context.Context, request postgres.DeleteEndpointRequest) (postgres.DeleteEndpointOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEndpoint")
	}

	var r0 postgres.DeleteEndpointOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteEndpointRequest) (postgres.DeleteEndpointOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteEndpointRequest) postgres.DeleteEndpointOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.DeleteEndpointOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.DeleteEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_DeleteEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEndpoint'
type MockPostgresInterface_DeleteEndpoint_Call struct {
	*mock.Call
}

// DeleteEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.DeleteEndpointRequest
func (_e *MockPostgresInterface_Expecter) DeleteEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_DeleteEndpoint_Call {
	return &MockPostgresInterface_DeleteEndpoint_Call{Call: _e.mock.On("DeleteEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_DeleteEndpoint_Call) Run(run func(ctx context.Context, request postgres.DeleteEndpointRequest)) *MockPostgresInterface_DeleteEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.DeleteEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_DeleteEndpoint_Call) Return(_a0 postgres.DeleteEndpointOperationInterface, _a1 error) *MockPostgresInterface_DeleteEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_DeleteEndpoint_Call) RunAndReturn(run func(context.Context, postgres.DeleteEndpointRequest) (postgres.DeleteEndpointOperationInterface, error)) *MockPostgresInterface_DeleteEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) DeleteProject(ctx context.Context, request postgres.DeleteProjectRequest) (postgres.DeleteProjectOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 postgres.DeleteProjectOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteProjectRequest) (postgres.DeleteProjectOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteProjectRequest) postgres.DeleteProjectOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.DeleteProjectOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.DeleteProjectRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type MockPostgresInterface_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.DeleteProjectRequest
func (_e *MockPostgresInterface_Expecter) DeleteProject(ctx interface{}, request interface{}) *MockPostgresInterface_DeleteProject_Call {
	return &MockPostgresInterface_DeleteProject_Call{Call: _e.mock.On("DeleteProject", ctx, request)}
}

func (_c *MockPostgresInterface_DeleteProject_Call) Run(run func(ctx context.Context, request postgres.DeleteProjectRequest)) *MockPostgresInterface_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.DeleteProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_DeleteProject_Call) Return(_a0 postgres.DeleteProjectOperationInterface, _a1 error) *MockPostgresInterface_DeleteProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_DeleteProject_Call) RunAndReturn(run func(context.Context, postgres.DeleteProjectRequest) (postgres.DeleteProjectOperationInterface, error)) *MockPostgresInterface_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRole provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) DeleteRole(ctx context.Context, request postgres.DeleteRoleRequest) (postgres.DeleteRoleOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRole")
	}

	var r0 postgres.DeleteRoleOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteRoleRequest) (postgres.DeleteRoleOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.DeleteRoleRequest) postgres.DeleteRoleOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.DeleteRoleOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.DeleteRoleRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_DeleteRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRole'
type MockPostgresInterface_DeleteRole_Call struct {
	*mock.Call
}

// DeleteRole is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.DeleteRoleRequest
func (_e *MockPostgresInterface_Expecter) DeleteRole(ctx interface{}, request interface{}) *MockPostgresInterface_DeleteRole_Call {
	return &MockPostgresInterface_DeleteRole_Call{Call: _e.mock.On("DeleteRole", ctx, request)}
}

func (_c *MockPostgresInterface_DeleteRole_Call) Run(run func(ctx context.Context, request postgres.DeleteRoleRequest)) *MockPostgresInterface_DeleteRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.DeleteRoleRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_DeleteRole_Call) Return(_a0 postgres.DeleteRoleOperationInterface, _a1 error) *MockPostgresInterface_DeleteRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_DeleteRole_Call) RunAndReturn(run func(context.Context, postgres.DeleteRoleRequest) (postgres.DeleteRoleOperationInterface, error)) *MockPostgresInterface_DeleteRole_Call {
	_c.Call.Return(run)
	return _c
}

// GetBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetBranch(ctx context.Context, request postgres.GetBranchRequest) (*postgres.Branch, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetBranch")
	}

	var r0 *postgres.Branch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetBranchRequest) (*postgres.Branch, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetBranchRequest) *postgres.Branch); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.Branch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetBranchRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBranch'
type MockPostgresInterface_GetBranch_Call struct {
	*mock.Call
}

// GetBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetBranchRequest
func (_e *MockPostgresInterface_Expecter) GetBranch(ctx interface{}, request interface{}) *MockPostgresInterface_GetBranch_Call {
	return &MockPostgresInterface_GetBranch_Call{Call: _e.mock.On("GetBranch", ctx, request)}
}

func (_c *MockPostgresInterface_GetBranch_Call) Run(run func(ctx context.Context, request postgres.GetBranchRequest)) *MockPostgresInterface_GetBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetBranch_Call) Return(_a0 *postgres.Branch, _a1 error) *MockPostgresInterface_GetBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetBranch_Call) RunAndReturn(run func(context.Context, postgres.GetBranchRequest) (*postgres.Branch, error)) *MockPostgresInterface_GetBranch_Call {
	_c.Call.Return(run)
	return _c
}

// GetEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetEndpoint(ctx context.Context, request postgres.GetEndpointRequest) (*postgres.Endpoint, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetEndpoint")
	}

	var r0 *postgres.Endpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetEndpointRequest) (*postgres.Endpoint, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetEndpointRequest) *postgres.Endpoint); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.Endpoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEndpoint'
type MockPostgresInterface_GetEndpoint_Call struct {
	*mock.Call
}

// GetEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetEndpointRequest
func (_e *MockPostgresInterface_Expecter) GetEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_GetEndpoint_Call {
	return &MockPostgresInterface_GetEndpoint_Call{Call: _e.mock.On("GetEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_GetEndpoint_Call) Run(run func(ctx context.Context, request postgres.GetEndpointRequest)) *MockPostgresInterface_GetEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetEndpoint_Call) Return(_a0 *postgres.Endpoint, _a1 error) *MockPostgresInterface_GetEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetEndpoint_Call) RunAndReturn(run func(context.Context, postgres.GetEndpointRequest) (*postgres.Endpoint, error)) *MockPostgresInterface_GetEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// GetOperation provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetOperation(ctx context.Context, request postgres.GetOperationRequest) (*postgres.Operation, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetOperation")
	}

	var r0 *postgres.Operation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetOperationRequest) (*postgres.Operation, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetOperationRequest) *postgres.Operation); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.Operation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetOperationRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOperation'
type MockPostgresInterface_GetOperation_Call struct {
	*mock.Call
}

// GetOperation is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetOperationRequest
func (_e *MockPostgresInterface_Expecter) GetOperation(ctx interface{}, request interface{}) *MockPostgresInterface_GetOperation_Call {
	return &MockPostgresInterface_GetOperation_Call{Call: _e.mock.On("GetOperation", ctx, request)}
}

func (_c *MockPostgresInterface_GetOperation_Call) Run(run func(ctx context.Context, request postgres.GetOperationRequest)) *MockPostgresInterface_GetOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetOperationRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetOperation_Call) Return(_a0 *postgres.Operation, _a1 error) *MockPostgresInterface_GetOperation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetOperation_Call) RunAndReturn(run func(context.Context, postgres.GetOperationRequest) (*postgres.Operation, error)) *MockPostgresInterface_GetOperation_Call {
	_c.Call.Return(run)
	return _c
}

// GetProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetProject(ctx context.Context, request postgres.GetProjectRequest) (*postgres.Project, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 *postgres.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetProjectRequest) (*postgres.Project, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetProjectRequest) *postgres.Project); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetProjectRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProject'
type MockPostgresInterface_GetProject_Call struct {
	*mock.Call
}

// GetProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetProjectRequest
func (_e *MockPostgresInterface_Expecter) GetProject(ctx interface{}, request interface{}) *MockPostgresInterface_GetProject_Call {
	return &MockPostgresInterface_GetProject_Call{Call: _e.mock.On("GetProject", ctx, request)}
}

func (_c *MockPostgresInterface_GetProject_Call) Run(run func(ctx context.Context, request postgres.GetProjectRequest)) *MockPostgresInterface_GetProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetProject_Call) Return(_a0 *postgres.Project, _a1 error) *MockPostgresInterface_GetProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetProject_Call) RunAndReturn(run func(context.Context, postgres.GetProjectRequest) (*postgres.Project, error)) *MockPostgresInterface_GetProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetRole provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) GetRole(ctx context.Context, request postgres.GetRoleRequest) (*postgres.Role, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetRole")
	}

	var r0 *postgres.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetRoleRequest) (*postgres.Role, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.GetRoleRequest) *postgres.Role); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*postgres.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.GetRoleRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_GetRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRole'
type MockPostgresInterface_GetRole_Call struct {
	*mock.Call
}

// GetRole is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.GetRoleRequest
func (_e *MockPostgresInterface_Expecter) GetRole(ctx interface{}, request interface{}) *MockPostgresInterface_GetRole_Call {
	return &MockPostgresInterface_GetRole_Call{Call: _e.mock.On("GetRole", ctx, request)}
}

func (_c *MockPostgresInterface_GetRole_Call) Run(run func(ctx context.Context, request postgres.GetRoleRequest)) *MockPostgresInterface_GetRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.GetRoleRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_GetRole_Call) Return(_a0 *postgres.Role, _a1 error) *MockPostgresInterface_GetRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_GetRole_Call) RunAndReturn(run func(context.Context, postgres.GetRoleRequest) (*postgres.Role, error)) *MockPostgresInterface_GetRole_Call {
	_c.Call.Return(run)
	return _c
}

// ListBranches provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListBranches(ctx context.Context, request postgres.ListBranchesRequest) listing.Iterator[postgres.Branch] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListBranches")
	}

	var r0 listing.Iterator[postgres.Branch]
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListBranchesRequest) listing.Iterator[postgres.Branch]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[postgres.Branch])
		}
	}

	return r0
}

// MockPostgresInterface_ListBranches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBranches'
type MockPostgresInterface_ListBranches_Call struct {
	*mock.Call
}

// ListBranches is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListBranchesRequest
func (_e *MockPostgresInterface_Expecter) ListBranches(ctx interface{}, request interface{}) *MockPostgresInterface_ListBranches_Call {
	return &MockPostgresInterface_ListBranches_Call{Call: _e.mock.On("ListBranches", ctx, request)}
}

func (_c *MockPostgresInterface_ListBranches_Call) Run(run func(ctx context.Context, request postgres.ListBranchesRequest)) *MockPostgresInterface_ListBranches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListBranchesRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListBranches_Call) Return(_a0 listing.Iterator[postgres.Branch]) *MockPostgresInterface_ListBranches_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_ListBranches_Call) RunAndReturn(run func(context.Context, postgres.ListBranchesRequest) listing.Iterator[postgres.Branch]) *MockPostgresInterface_ListBranches_Call {
	_c.Call.Return(run)
	return _c
}

// ListBranchesAll provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListBranchesAll(ctx context.Context, request postgres.ListBranchesRequest) ([]postgres.Branch, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListBranchesAll")
	}

	var r0 []postgres.Branch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListBranchesRequest) ([]postgres.Branch, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListBranchesRequest) []postgres.Branch); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]postgres.Branch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.ListBranchesRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_ListBranchesAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBranchesAll'
type MockPostgresInterface_ListBranchesAll_Call struct {
	*mock.Call
}

// ListBranchesAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListBranchesRequest
func (_e *MockPostgresInterface_Expecter) ListBranchesAll(ctx interface{}, request interface{}) *MockPostgresInterface_ListBranchesAll_Call {
	return &MockPostgresInterface_ListBranchesAll_Call{Call: _e.mock.On("ListBranchesAll", ctx, request)}
}

func (_c *MockPostgresInterface_ListBranchesAll_Call) Run(run func(ctx context.Context, request postgres.ListBranchesRequest)) *MockPostgresInterface_ListBranchesAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListBranchesRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListBranchesAll_Call) Return(_a0 []postgres.Branch, _a1 error) *MockPostgresInterface_ListBranchesAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_ListBranchesAll_Call) RunAndReturn(run func(context.Context, postgres.ListBranchesRequest) ([]postgres.Branch, error)) *MockPostgresInterface_ListBranchesAll_Call {
	_c.Call.Return(run)
	return _c
}

// ListEndpoints provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListEndpoints(ctx context.Context, request postgres.ListEndpointsRequest) listing.Iterator[postgres.Endpoint] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListEndpoints")
	}

	var r0 listing.Iterator[postgres.Endpoint]
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListEndpointsRequest) listing.Iterator[postgres.Endpoint]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[postgres.Endpoint])
		}
	}

	return r0
}

// MockPostgresInterface_ListEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEndpoints'
type MockPostgresInterface_ListEndpoints_Call struct {
	*mock.Call
}

// ListEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListEndpointsRequest
func (_e *MockPostgresInterface_Expecter) ListEndpoints(ctx interface{}, request interface{}) *MockPostgresInterface_ListEndpoints_Call {
	return &MockPostgresInterface_ListEndpoints_Call{Call: _e.mock.On("ListEndpoints", ctx, request)}
}

func (_c *MockPostgresInterface_ListEndpoints_Call) Run(run func(ctx context.Context, request postgres.ListEndpointsRequest)) *MockPostgresInterface_ListEndpoints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListEndpointsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListEndpoints_Call) Return(_a0 listing.Iterator[postgres.Endpoint]) *MockPostgresInterface_ListEndpoints_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_ListEndpoints_Call) RunAndReturn(run func(context.Context, postgres.ListEndpointsRequest) listing.Iterator[postgres.Endpoint]) *MockPostgresInterface_ListEndpoints_Call {
	_c.Call.Return(run)
	return _c
}

// ListEndpointsAll provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListEndpointsAll(ctx context.Context, request postgres.ListEndpointsRequest) ([]postgres.Endpoint, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListEndpointsAll")
	}

	var r0 []postgres.Endpoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListEndpointsRequest) ([]postgres.Endpoint, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListEndpointsRequest) []postgres.Endpoint); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]postgres.Endpoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.ListEndpointsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_ListEndpointsAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEndpointsAll'
type MockPostgresInterface_ListEndpointsAll_Call struct {
	*mock.Call
}

// ListEndpointsAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListEndpointsRequest
func (_e *MockPostgresInterface_Expecter) ListEndpointsAll(ctx interface{}, request interface{}) *MockPostgresInterface_ListEndpointsAll_Call {
	return &MockPostgresInterface_ListEndpointsAll_Call{Call: _e.mock.On("ListEndpointsAll", ctx, request)}
}

func (_c *MockPostgresInterface_ListEndpointsAll_Call) Run(run func(ctx context.Context, request postgres.ListEndpointsRequest)) *MockPostgresInterface_ListEndpointsAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListEndpointsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListEndpointsAll_Call) Return(_a0 []postgres.Endpoint, _a1 error) *MockPostgresInterface_ListEndpointsAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_ListEndpointsAll_Call) RunAndReturn(run func(context.Context, postgres.ListEndpointsRequest) ([]postgres.Endpoint, error)) *MockPostgresInterface_ListEndpointsAll_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListProjects(ctx context.Context, request postgres.ListProjectsRequest) listing.Iterator[postgres.Project] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 listing.Iterator[postgres.Project]
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListProjectsRequest) listing.Iterator[postgres.Project]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[postgres.Project])
		}
	}

	return r0
}

// MockPostgresInterface_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type MockPostgresInterface_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListProjectsRequest
func (_e *MockPostgresInterface_Expecter) ListProjects(ctx interface{}, request interface{}) *MockPostgresInterface_ListProjects_Call {
	return &MockPostgresInterface_ListProjects_Call{Call: _e.mock.On("ListProjects", ctx, request)}
}

func (_c *MockPostgresInterface_ListProjects_Call) Run(run func(ctx context.Context, request postgres.ListProjectsRequest)) *MockPostgresInterface_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListProjectsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListProjects_Call) Return(_a0 listing.Iterator[postgres.Project]) *MockPostgresInterface_ListProjects_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_ListProjects_Call) RunAndReturn(run func(context.Context, postgres.ListProjectsRequest) listing.Iterator[postgres.Project]) *MockPostgresInterface_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsAll provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListProjectsAll(ctx context.Context, request postgres.ListProjectsRequest) ([]postgres.Project, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsAll")
	}

	var r0 []postgres.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListProjectsRequest) ([]postgres.Project, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListProjectsRequest) []postgres.Project); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]postgres.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.ListProjectsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_ListProjectsAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsAll'
type MockPostgresInterface_ListProjectsAll_Call struct {
	*mock.Call
}

// ListProjectsAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListProjectsRequest
func (_e *MockPostgresInterface_Expecter) ListProjectsAll(ctx interface{}, request interface{}) *MockPostgresInterface_ListProjectsAll_Call {
	return &MockPostgresInterface_ListProjectsAll_Call{Call: _e.mock.On("ListProjectsAll", ctx, request)}
}

func (_c *MockPostgresInterface_ListProjectsAll_Call) Run(run func(ctx context.Context, request postgres.ListProjectsRequest)) *MockPostgresInterface_ListProjectsAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListProjectsRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListProjectsAll_Call) Return(_a0 []postgres.Project, _a1 error) *MockPostgresInterface_ListProjectsAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_ListProjectsAll_Call) RunAndReturn(run func(context.Context, postgres.ListProjectsRequest) ([]postgres.Project, error)) *MockPostgresInterface_ListProjectsAll_Call {
	_c.Call.Return(run)
	return _c
}

// ListRoles provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListRoles(ctx context.Context, request postgres.ListRolesRequest) listing.Iterator[postgres.Role] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListRoles")
	}

	var r0 listing.Iterator[postgres.Role]
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListRolesRequest) listing.Iterator[postgres.Role]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[postgres.Role])
		}
	}

	return r0
}

// MockPostgresInterface_ListRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRoles'
type MockPostgresInterface_ListRoles_Call struct {
	*mock.Call
}

// ListRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListRolesRequest
func (_e *MockPostgresInterface_Expecter) ListRoles(ctx interface{}, request interface{}) *MockPostgresInterface_ListRoles_Call {
	return &MockPostgresInterface_ListRoles_Call{Call: _e.mock.On("ListRoles", ctx, request)}
}

func (_c *MockPostgresInterface_ListRoles_Call) Run(run func(ctx context.Context, request postgres.ListRolesRequest)) *MockPostgresInterface_ListRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListRolesRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListRoles_Call) Return(_a0 listing.Iterator[postgres.Role]) *MockPostgresInterface_ListRoles_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPostgresInterface_ListRoles_Call) RunAndReturn(run func(context.Context, postgres.ListRolesRequest) listing.Iterator[postgres.Role]) *MockPostgresInterface_ListRoles_Call {
	_c.Call.Return(run)
	return _c
}

// ListRolesAll provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) ListRolesAll(ctx context.Context, request postgres.ListRolesRequest) ([]postgres.Role, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListRolesAll")
	}

	var r0 []postgres.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListRolesRequest) ([]postgres.Role, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.ListRolesRequest) []postgres.Role); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]postgres.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.ListRolesRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_ListRolesAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRolesAll'
type MockPostgresInterface_ListRolesAll_Call struct {
	*mock.Call
}

// ListRolesAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.ListRolesRequest
func (_e *MockPostgresInterface_Expecter) ListRolesAll(ctx interface{}, request interface{}) *MockPostgresInterface_ListRolesAll_Call {
	return &MockPostgresInterface_ListRolesAll_Call{Call: _e.mock.On("ListRolesAll", ctx, request)}
}

func (_c *MockPostgresInterface_ListRolesAll_Call) Run(run func(ctx context.Context, request postgres.ListRolesRequest)) *MockPostgresInterface_ListRolesAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.ListRolesRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_ListRolesAll_Call) Return(_a0 []postgres.Role, _a1 error) *MockPostgresInterface_ListRolesAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_ListRolesAll_Call) RunAndReturn(run func(context.Context, postgres.ListRolesRequest) ([]postgres.Role, error)) *MockPostgresInterface_ListRolesAll_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBranch provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) UpdateBranch(ctx context.Context, request postgres.UpdateBranchRequest) (postgres.UpdateBranchOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBranch")
	}

	var r0 postgres.UpdateBranchOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateBranchRequest) (postgres.UpdateBranchOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateBranchRequest) postgres.UpdateBranchOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.UpdateBranchOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.UpdateBranchRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_UpdateBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBranch'
type MockPostgresInterface_UpdateBranch_Call struct {
	*mock.Call
}

// UpdateBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.UpdateBranchRequest
func (_e *MockPostgresInterface_Expecter) UpdateBranch(ctx interface{}, request interface{}) *MockPostgresInterface_UpdateBranch_Call {
	return &MockPostgresInterface_UpdateBranch_Call{Call: _e.mock.On("UpdateBranch", ctx, request)}
}

func (_c *MockPostgresInterface_UpdateBranch_Call) Run(run func(ctx context.Context, request postgres.UpdateBranchRequest)) *MockPostgresInterface_UpdateBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.UpdateBranchRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_UpdateBranch_Call) Return(_a0 postgres.UpdateBranchOperationInterface, _a1 error) *MockPostgresInterface_UpdateBranch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_UpdateBranch_Call) RunAndReturn(run func(context.Context, postgres.UpdateBranchRequest) (postgres.UpdateBranchOperationInterface, error)) *MockPostgresInterface_UpdateBranch_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEndpoint provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) UpdateEndpoint(ctx context.Context, request postgres.UpdateEndpointRequest) (postgres.UpdateEndpointOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEndpoint")
	}

	var r0 postgres.UpdateEndpointOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateEndpointRequest) (postgres.UpdateEndpointOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateEndpointRequest) postgres.UpdateEndpointOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.UpdateEndpointOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.UpdateEndpointRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_UpdateEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEndpoint'
type MockPostgresInterface_UpdateEndpoint_Call struct {
	*mock.Call
}

// UpdateEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.UpdateEndpointRequest
func (_e *MockPostgresInterface_Expecter) UpdateEndpoint(ctx interface{}, request interface{}) *MockPostgresInterface_UpdateEndpoint_Call {
	return &MockPostgresInterface_UpdateEndpoint_Call{Call: _e.mock.On("UpdateEndpoint", ctx, request)}
}

func (_c *MockPostgresInterface_UpdateEndpoint_Call) Run(run func(ctx context.Context, request postgres.UpdateEndpointRequest)) *MockPostgresInterface_UpdateEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.UpdateEndpointRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_UpdateEndpoint_Call) Return(_a0 postgres.UpdateEndpointOperationInterface, _a1 error) *MockPostgresInterface_UpdateEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_UpdateEndpoint_Call) RunAndReturn(run func(context.Context, postgres.UpdateEndpointRequest) (postgres.UpdateEndpointOperationInterface, error)) *MockPostgresInterface_UpdateEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProject provides a mock function with given fields: ctx, request
func (_m *MockPostgresInterface) UpdateProject(ctx context.Context, request postgres.UpdateProjectRequest) (postgres.UpdateProjectOperationInterface, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProject")
	}

	var r0 postgres.UpdateProjectOperationInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateProjectRequest) (postgres.UpdateProjectOperationInterface, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, postgres.UpdateProjectRequest) postgres.UpdateProjectOperationInterface); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(postgres.UpdateProjectOperationInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, postgres.UpdateProjectRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPostgresInterface_UpdateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProject'
type MockPostgresInterface_UpdateProject_Call struct {
	*mock.Call
}

// UpdateProject is a helper method to define mock.On call
//   - ctx context.Context
//   - request postgres.UpdateProjectRequest
func (_e *MockPostgresInterface_Expecter) UpdateProject(ctx interface{}, request interface{}) *MockPostgresInterface_UpdateProject_Call {
	return &MockPostgresInterface_UpdateProject_Call{Call: _e.mock.On("UpdateProject", ctx, request)}
}

func (_c *MockPostgresInterface_UpdateProject_Call) Run(run func(ctx context.Context, request postgres.UpdateProjectRequest)) *MockPostgresInterface_UpdateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(postgres.UpdateProjectRequest))
	})
	return _c
}

func (_c *MockPostgresInterface_UpdateProject_Call) Return(_a0 postgres.UpdateProjectOperationInterface, _a1 error) *MockPostgresInterface_UpdateProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPostgresInterface_UpdateProject_Call) RunAndReturn(run func(context.Context, postgres.UpdateProjectRequest) (postgres.UpdateProjectOperationInterface, error)) *MockPostgresInterface_UpdateProject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPostgresInterface creates a new instance of MockPostgresInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPostgresInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPostgresInterface {
	mock := &MockPostgresInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
