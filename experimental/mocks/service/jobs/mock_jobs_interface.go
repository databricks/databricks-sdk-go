// Code generated by mockery v2.43.0. DO NOT EDIT.

package jobs

import (
	context "context"

	listing "github.com/databricks/databricks-sdk-go/listing"
	jobs "github.com/databricks/databricks-sdk-go/service/jobs"

	mock "github.com/stretchr/testify/mock"

	retries "github.com/databricks/databricks-sdk-go/retries"

	time "time"
)

// MockJobsInterface is an autogenerated mock type for the JobsInterface type
type MockJobsInterface struct {
	mock.Mock
}

type MockJobsInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockJobsInterface) EXPECT() *MockJobsInterface_Expecter {
	return &MockJobsInterface_Expecter{mock: &_m.Mock}
}

// BaseJobSettingsNameToJobIdMap provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) BaseJobSettingsNameToJobIdMap(ctx context.Context, request jobs.ListJobsRequest) (map[string]int64, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for BaseJobSettingsNameToJobIdMap")
	}

	var r0 map[string]int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListJobsRequest) (map[string]int64, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListJobsRequest) map[string]int64); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.ListJobsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BaseJobSettingsNameToJobIdMap'
type MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call struct {
	*mock.Call
}

// BaseJobSettingsNameToJobIdMap is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.ListJobsRequest
func (_e *MockJobsInterface_Expecter) BaseJobSettingsNameToJobIdMap(ctx interface{}, request interface{}) *MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call {
	return &MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call{Call: _e.mock.On("BaseJobSettingsNameToJobIdMap", ctx, request)}
}

func (_c *MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call) Run(run func(ctx context.Context, request jobs.ListJobsRequest)) *MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.ListJobsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call) Return(_a0 map[string]int64, _a1 error) *MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call) RunAndReturn(run func(context.Context, jobs.ListJobsRequest) (map[string]int64, error)) *MockJobsInterface_BaseJobSettingsNameToJobIdMap_Call {
	_c.Call.Return(run)
	return _c
}

// CancelAllRuns provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) CancelAllRuns(ctx context.Context, request jobs.CancelAllRuns) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CancelAllRuns")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.CancelAllRuns) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_CancelAllRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelAllRuns'
type MockJobsInterface_CancelAllRuns_Call struct {
	*mock.Call
}

// CancelAllRuns is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.CancelAllRuns
func (_e *MockJobsInterface_Expecter) CancelAllRuns(ctx interface{}, request interface{}) *MockJobsInterface_CancelAllRuns_Call {
	return &MockJobsInterface_CancelAllRuns_Call{Call: _e.mock.On("CancelAllRuns", ctx, request)}
}

func (_c *MockJobsInterface_CancelAllRuns_Call) Run(run func(ctx context.Context, request jobs.CancelAllRuns)) *MockJobsInterface_CancelAllRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.CancelAllRuns))
	})
	return _c
}

func (_c *MockJobsInterface_CancelAllRuns_Call) Return(_a0 error) *MockJobsInterface_CancelAllRuns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_CancelAllRuns_Call) RunAndReturn(run func(context.Context, jobs.CancelAllRuns) error) *MockJobsInterface_CancelAllRuns_Call {
	_c.Call.Return(run)
	return _c
}

// CancelRun provides a mock function with given fields: ctx, cancelRun
func (_m *MockJobsInterface) CancelRun(ctx context.Context, cancelRun jobs.CancelRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[struct{}], error) {
	ret := _m.Called(ctx, cancelRun)

	if len(ret) == 0 {
		panic("no return value specified for CancelRun")
	}

	var r0 *jobs.WaitGetRunJobTerminatedOrSkipped[struct{}]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.CancelRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[struct{}], error)); ok {
		return rf(ctx, cancelRun)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.CancelRun) *jobs.WaitGetRunJobTerminatedOrSkipped[struct{}]); ok {
		r0 = rf(ctx, cancelRun)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.WaitGetRunJobTerminatedOrSkipped[struct{}])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.CancelRun) error); ok {
		r1 = rf(ctx, cancelRun)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_CancelRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelRun'
type MockJobsInterface_CancelRun_Call struct {
	*mock.Call
}

// CancelRun is a helper method to define mock.On call
//   - ctx context.Context
//   - cancelRun jobs.CancelRun
func (_e *MockJobsInterface_Expecter) CancelRun(ctx interface{}, cancelRun interface{}) *MockJobsInterface_CancelRun_Call {
	return &MockJobsInterface_CancelRun_Call{Call: _e.mock.On("CancelRun", ctx, cancelRun)}
}

func (_c *MockJobsInterface_CancelRun_Call) Run(run func(ctx context.Context, cancelRun jobs.CancelRun)) *MockJobsInterface_CancelRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.CancelRun))
	})
	return _c
}

func (_c *MockJobsInterface_CancelRun_Call) Return(_a0 *jobs.WaitGetRunJobTerminatedOrSkipped[struct{}], _a1 error) *MockJobsInterface_CancelRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_CancelRun_Call) RunAndReturn(run func(context.Context, jobs.CancelRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[struct{}], error)) *MockJobsInterface_CancelRun_Call {
	_c.Call.Return(run)
	return _c
}

// CancelRunAndWait provides a mock function with given fields: ctx, cancelRun, options
func (_m *MockJobsInterface) CancelRunAndWait(ctx context.Context, cancelRun jobs.CancelRun, options ...retries.Option[jobs.Run]) (*jobs.Run, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, cancelRun)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelRunAndWait")
	}

	var r0 *jobs.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.CancelRun, ...retries.Option[jobs.Run]) (*jobs.Run, error)); ok {
		return rf(ctx, cancelRun, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.CancelRun, ...retries.Option[jobs.Run]) *jobs.Run); ok {
		r0 = rf(ctx, cancelRun, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.CancelRun, ...retries.Option[jobs.Run]) error); ok {
		r1 = rf(ctx, cancelRun, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_CancelRunAndWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelRunAndWait'
type MockJobsInterface_CancelRunAndWait_Call struct {
	*mock.Call
}

// CancelRunAndWait is a helper method to define mock.On call
//   - ctx context.Context
//   - cancelRun jobs.CancelRun
//   - options ...retries.Option[jobs.Run]
func (_e *MockJobsInterface_Expecter) CancelRunAndWait(ctx interface{}, cancelRun interface{}, options ...interface{}) *MockJobsInterface_CancelRunAndWait_Call {
	return &MockJobsInterface_CancelRunAndWait_Call{Call: _e.mock.On("CancelRunAndWait",
		append([]interface{}{ctx, cancelRun}, options...)...)}
}

func (_c *MockJobsInterface_CancelRunAndWait_Call) Run(run func(ctx context.Context, cancelRun jobs.CancelRun, options ...retries.Option[jobs.Run])) *MockJobsInterface_CancelRunAndWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]retries.Option[jobs.Run], len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(retries.Option[jobs.Run])
			}
		}
		run(args[0].(context.Context), args[1].(jobs.CancelRun), variadicArgs...)
	})
	return _c
}

func (_c *MockJobsInterface_CancelRunAndWait_Call) Return(_a0 *jobs.Run, _a1 error) *MockJobsInterface_CancelRunAndWait_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_CancelRunAndWait_Call) RunAndReturn(run func(context.Context, jobs.CancelRun, ...retries.Option[jobs.Run]) (*jobs.Run, error)) *MockJobsInterface_CancelRunAndWait_Call {
	_c.Call.Return(run)
	return _c
}

// CancelRunByRunId provides a mock function with given fields: ctx, runId
func (_m *MockJobsInterface) CancelRunByRunId(ctx context.Context, runId int64) error {
	ret := _m.Called(ctx, runId)

	if len(ret) == 0 {
		panic("no return value specified for CancelRunByRunId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, runId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_CancelRunByRunId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelRunByRunId'
type MockJobsInterface_CancelRunByRunId_Call struct {
	*mock.Call
}

// CancelRunByRunId is a helper method to define mock.On call
//   - ctx context.Context
//   - runId int64
func (_e *MockJobsInterface_Expecter) CancelRunByRunId(ctx interface{}, runId interface{}) *MockJobsInterface_CancelRunByRunId_Call {
	return &MockJobsInterface_CancelRunByRunId_Call{Call: _e.mock.On("CancelRunByRunId", ctx, runId)}
}

func (_c *MockJobsInterface_CancelRunByRunId_Call) Run(run func(ctx context.Context, runId int64)) *MockJobsInterface_CancelRunByRunId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockJobsInterface_CancelRunByRunId_Call) Return(_a0 error) *MockJobsInterface_CancelRunByRunId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_CancelRunByRunId_Call) RunAndReturn(run func(context.Context, int64) error) *MockJobsInterface_CancelRunByRunId_Call {
	_c.Call.Return(run)
	return _c
}

// CancelRunByRunIdAndWait provides a mock function with given fields: ctx, runId, options
func (_m *MockJobsInterface) CancelRunByRunIdAndWait(ctx context.Context, runId int64, options ...retries.Option[jobs.Run]) (*jobs.Run, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, runId)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelRunByRunIdAndWait")
	}

	var r0 *jobs.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, ...retries.Option[jobs.Run]) (*jobs.Run, error)); ok {
		return rf(ctx, runId, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, ...retries.Option[jobs.Run]) *jobs.Run); ok {
		r0 = rf(ctx, runId, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, ...retries.Option[jobs.Run]) error); ok {
		r1 = rf(ctx, runId, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_CancelRunByRunIdAndWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelRunByRunIdAndWait'
type MockJobsInterface_CancelRunByRunIdAndWait_Call struct {
	*mock.Call
}

// CancelRunByRunIdAndWait is a helper method to define mock.On call
//   - ctx context.Context
//   - runId int64
//   - options ...retries.Option[jobs.Run]
func (_e *MockJobsInterface_Expecter) CancelRunByRunIdAndWait(ctx interface{}, runId interface{}, options ...interface{}) *MockJobsInterface_CancelRunByRunIdAndWait_Call {
	return &MockJobsInterface_CancelRunByRunIdAndWait_Call{Call: _e.mock.On("CancelRunByRunIdAndWait",
		append([]interface{}{ctx, runId}, options...)...)}
}

func (_c *MockJobsInterface_CancelRunByRunIdAndWait_Call) Run(run func(ctx context.Context, runId int64, options ...retries.Option[jobs.Run])) *MockJobsInterface_CancelRunByRunIdAndWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]retries.Option[jobs.Run], len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(retries.Option[jobs.Run])
			}
		}
		run(args[0].(context.Context), args[1].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockJobsInterface_CancelRunByRunIdAndWait_Call) Return(_a0 *jobs.Run, _a1 error) *MockJobsInterface_CancelRunByRunIdAndWait_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_CancelRunByRunIdAndWait_Call) RunAndReturn(run func(context.Context, int64, ...retries.Option[jobs.Run]) (*jobs.Run, error)) *MockJobsInterface_CancelRunByRunIdAndWait_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) Create(ctx context.Context, request jobs.CreateJob) (*jobs.CreateResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *jobs.CreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.CreateJob) (*jobs.CreateResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.CreateJob) *jobs.CreateResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.CreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.CreateJob) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockJobsInterface_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.CreateJob
func (_e *MockJobsInterface_Expecter) Create(ctx interface{}, request interface{}) *MockJobsInterface_Create_Call {
	return &MockJobsInterface_Create_Call{Call: _e.mock.On("Create", ctx, request)}
}

func (_c *MockJobsInterface_Create_Call) Run(run func(ctx context.Context, request jobs.CreateJob)) *MockJobsInterface_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.CreateJob))
	})
	return _c
}

func (_c *MockJobsInterface_Create_Call) Return(_a0 *jobs.CreateResponse, _a1 error) *MockJobsInterface_Create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_Create_Call) RunAndReturn(run func(context.Context, jobs.CreateJob) (*jobs.CreateResponse, error)) *MockJobsInterface_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) Delete(ctx context.Context, request jobs.DeleteJob) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.DeleteJob) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockJobsInterface_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.DeleteJob
func (_e *MockJobsInterface_Expecter) Delete(ctx interface{}, request interface{}) *MockJobsInterface_Delete_Call {
	return &MockJobsInterface_Delete_Call{Call: _e.mock.On("Delete", ctx, request)}
}

func (_c *MockJobsInterface_Delete_Call) Run(run func(ctx context.Context, request jobs.DeleteJob)) *MockJobsInterface_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.DeleteJob))
	})
	return _c
}

func (_c *MockJobsInterface_Delete_Call) Return(_a0 error) *MockJobsInterface_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_Delete_Call) RunAndReturn(run func(context.Context, jobs.DeleteJob) error) *MockJobsInterface_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByJobId provides a mock function with given fields: ctx, jobId
func (_m *MockJobsInterface) DeleteByJobId(ctx context.Context, jobId int64) error {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByJobId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, jobId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_DeleteByJobId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByJobId'
type MockJobsInterface_DeleteByJobId_Call struct {
	*mock.Call
}

// DeleteByJobId is a helper method to define mock.On call
//   - ctx context.Context
//   - jobId int64
func (_e *MockJobsInterface_Expecter) DeleteByJobId(ctx interface{}, jobId interface{}) *MockJobsInterface_DeleteByJobId_Call {
	return &MockJobsInterface_DeleteByJobId_Call{Call: _e.mock.On("DeleteByJobId", ctx, jobId)}
}

func (_c *MockJobsInterface_DeleteByJobId_Call) Run(run func(ctx context.Context, jobId int64)) *MockJobsInterface_DeleteByJobId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockJobsInterface_DeleteByJobId_Call) Return(_a0 error) *MockJobsInterface_DeleteByJobId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_DeleteByJobId_Call) RunAndReturn(run func(context.Context, int64) error) *MockJobsInterface_DeleteByJobId_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRun provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) DeleteRun(ctx context.Context, request jobs.DeleteRun) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRun")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.DeleteRun) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_DeleteRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRun'
type MockJobsInterface_DeleteRun_Call struct {
	*mock.Call
}

// DeleteRun is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.DeleteRun
func (_e *MockJobsInterface_Expecter) DeleteRun(ctx interface{}, request interface{}) *MockJobsInterface_DeleteRun_Call {
	return &MockJobsInterface_DeleteRun_Call{Call: _e.mock.On("DeleteRun", ctx, request)}
}

func (_c *MockJobsInterface_DeleteRun_Call) Run(run func(ctx context.Context, request jobs.DeleteRun)) *MockJobsInterface_DeleteRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.DeleteRun))
	})
	return _c
}

func (_c *MockJobsInterface_DeleteRun_Call) Return(_a0 error) *MockJobsInterface_DeleteRun_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_DeleteRun_Call) RunAndReturn(run func(context.Context, jobs.DeleteRun) error) *MockJobsInterface_DeleteRun_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRunByRunId provides a mock function with given fields: ctx, runId
func (_m *MockJobsInterface) DeleteRunByRunId(ctx context.Context, runId int64) error {
	ret := _m.Called(ctx, runId)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRunByRunId")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, runId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_DeleteRunByRunId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRunByRunId'
type MockJobsInterface_DeleteRunByRunId_Call struct {
	*mock.Call
}

// DeleteRunByRunId is a helper method to define mock.On call
//   - ctx context.Context
//   - runId int64
func (_e *MockJobsInterface_Expecter) DeleteRunByRunId(ctx interface{}, runId interface{}) *MockJobsInterface_DeleteRunByRunId_Call {
	return &MockJobsInterface_DeleteRunByRunId_Call{Call: _e.mock.On("DeleteRunByRunId", ctx, runId)}
}

func (_c *MockJobsInterface_DeleteRunByRunId_Call) Run(run func(ctx context.Context, runId int64)) *MockJobsInterface_DeleteRunByRunId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockJobsInterface_DeleteRunByRunId_Call) Return(_a0 error) *MockJobsInterface_DeleteRunByRunId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_DeleteRunByRunId_Call) RunAndReturn(run func(context.Context, int64) error) *MockJobsInterface_DeleteRunByRunId_Call {
	_c.Call.Return(run)
	return _c
}

// ExportRun provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) ExportRun(ctx context.Context, request jobs.ExportRunRequest) (*jobs.ExportRunOutput, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ExportRun")
	}

	var r0 *jobs.ExportRunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ExportRunRequest) (*jobs.ExportRunOutput, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ExportRunRequest) *jobs.ExportRunOutput); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.ExportRunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.ExportRunRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_ExportRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExportRun'
type MockJobsInterface_ExportRun_Call struct {
	*mock.Call
}

// ExportRun is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.ExportRunRequest
func (_e *MockJobsInterface_Expecter) ExportRun(ctx interface{}, request interface{}) *MockJobsInterface_ExportRun_Call {
	return &MockJobsInterface_ExportRun_Call{Call: _e.mock.On("ExportRun", ctx, request)}
}

func (_c *MockJobsInterface_ExportRun_Call) Run(run func(ctx context.Context, request jobs.ExportRunRequest)) *MockJobsInterface_ExportRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.ExportRunRequest))
	})
	return _c
}

func (_c *MockJobsInterface_ExportRun_Call) Return(_a0 *jobs.ExportRunOutput, _a1 error) *MockJobsInterface_ExportRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_ExportRun_Call) RunAndReturn(run func(context.Context, jobs.ExportRunRequest) (*jobs.ExportRunOutput, error)) *MockJobsInterface_ExportRun_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) Get(ctx context.Context, request jobs.GetJobRequest) (*jobs.Job, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *jobs.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetJobRequest) (*jobs.Job, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetJobRequest) *jobs.Job); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.GetJobRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockJobsInterface_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.GetJobRequest
func (_e *MockJobsInterface_Expecter) Get(ctx interface{}, request interface{}) *MockJobsInterface_Get_Call {
	return &MockJobsInterface_Get_Call{Call: _e.mock.On("Get", ctx, request)}
}

func (_c *MockJobsInterface_Get_Call) Run(run func(ctx context.Context, request jobs.GetJobRequest)) *MockJobsInterface_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.GetJobRequest))
	})
	return _c
}

func (_c *MockJobsInterface_Get_Call) Return(_a0 *jobs.Job, _a1 error) *MockJobsInterface_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_Get_Call) RunAndReturn(run func(context.Context, jobs.GetJobRequest) (*jobs.Job, error)) *MockJobsInterface_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetByJobId provides a mock function with given fields: ctx, jobId
func (_m *MockJobsInterface) GetByJobId(ctx context.Context, jobId int64) (*jobs.Job, error) {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for GetByJobId")
	}

	var r0 *jobs.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*jobs.Job, error)); ok {
		return rf(ctx, jobId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *jobs.Job); ok {
		r0 = rf(ctx, jobId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, jobId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetByJobId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByJobId'
type MockJobsInterface_GetByJobId_Call struct {
	*mock.Call
}

// GetByJobId is a helper method to define mock.On call
//   - ctx context.Context
//   - jobId int64
func (_e *MockJobsInterface_Expecter) GetByJobId(ctx interface{}, jobId interface{}) *MockJobsInterface_GetByJobId_Call {
	return &MockJobsInterface_GetByJobId_Call{Call: _e.mock.On("GetByJobId", ctx, jobId)}
}

func (_c *MockJobsInterface_GetByJobId_Call) Run(run func(ctx context.Context, jobId int64)) *MockJobsInterface_GetByJobId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockJobsInterface_GetByJobId_Call) Return(_a0 *jobs.Job, _a1 error) *MockJobsInterface_GetByJobId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetByJobId_Call) RunAndReturn(run func(context.Context, int64) (*jobs.Job, error)) *MockJobsInterface_GetByJobId_Call {
	_c.Call.Return(run)
	return _c
}

// GetBySettingsName provides a mock function with given fields: ctx, name
func (_m *MockJobsInterface) GetBySettingsName(ctx context.Context, name string) (*jobs.BaseJob, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetBySettingsName")
	}

	var r0 *jobs.BaseJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*jobs.BaseJob, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *jobs.BaseJob); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.BaseJob)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetBySettingsName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBySettingsName'
type MockJobsInterface_GetBySettingsName_Call struct {
	*mock.Call
}

// GetBySettingsName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockJobsInterface_Expecter) GetBySettingsName(ctx interface{}, name interface{}) *MockJobsInterface_GetBySettingsName_Call {
	return &MockJobsInterface_GetBySettingsName_Call{Call: _e.mock.On("GetBySettingsName", ctx, name)}
}

func (_c *MockJobsInterface_GetBySettingsName_Call) Run(run func(ctx context.Context, name string)) *MockJobsInterface_GetBySettingsName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockJobsInterface_GetBySettingsName_Call) Return(_a0 *jobs.BaseJob, _a1 error) *MockJobsInterface_GetBySettingsName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetBySettingsName_Call) RunAndReturn(run func(context.Context, string) (*jobs.BaseJob, error)) *MockJobsInterface_GetBySettingsName_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionLevels provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) GetPermissionLevels(ctx context.Context, request jobs.GetJobPermissionLevelsRequest) (*jobs.GetJobPermissionLevelsResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionLevels")
	}

	var r0 *jobs.GetJobPermissionLevelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetJobPermissionLevelsRequest) (*jobs.GetJobPermissionLevelsResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetJobPermissionLevelsRequest) *jobs.GetJobPermissionLevelsResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.GetJobPermissionLevelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.GetJobPermissionLevelsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetPermissionLevels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionLevels'
type MockJobsInterface_GetPermissionLevels_Call struct {
	*mock.Call
}

// GetPermissionLevels is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.GetJobPermissionLevelsRequest
func (_e *MockJobsInterface_Expecter) GetPermissionLevels(ctx interface{}, request interface{}) *MockJobsInterface_GetPermissionLevels_Call {
	return &MockJobsInterface_GetPermissionLevels_Call{Call: _e.mock.On("GetPermissionLevels", ctx, request)}
}

func (_c *MockJobsInterface_GetPermissionLevels_Call) Run(run func(ctx context.Context, request jobs.GetJobPermissionLevelsRequest)) *MockJobsInterface_GetPermissionLevels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.GetJobPermissionLevelsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_GetPermissionLevels_Call) Return(_a0 *jobs.GetJobPermissionLevelsResponse, _a1 error) *MockJobsInterface_GetPermissionLevels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetPermissionLevels_Call) RunAndReturn(run func(context.Context, jobs.GetJobPermissionLevelsRequest) (*jobs.GetJobPermissionLevelsResponse, error)) *MockJobsInterface_GetPermissionLevels_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionLevelsByJobId provides a mock function with given fields: ctx, jobId
func (_m *MockJobsInterface) GetPermissionLevelsByJobId(ctx context.Context, jobId string) (*jobs.GetJobPermissionLevelsResponse, error) {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionLevelsByJobId")
	}

	var r0 *jobs.GetJobPermissionLevelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*jobs.GetJobPermissionLevelsResponse, error)); ok {
		return rf(ctx, jobId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *jobs.GetJobPermissionLevelsResponse); ok {
		r0 = rf(ctx, jobId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.GetJobPermissionLevelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetPermissionLevelsByJobId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionLevelsByJobId'
type MockJobsInterface_GetPermissionLevelsByJobId_Call struct {
	*mock.Call
}

// GetPermissionLevelsByJobId is a helper method to define mock.On call
//   - ctx context.Context
//   - jobId string
func (_e *MockJobsInterface_Expecter) GetPermissionLevelsByJobId(ctx interface{}, jobId interface{}) *MockJobsInterface_GetPermissionLevelsByJobId_Call {
	return &MockJobsInterface_GetPermissionLevelsByJobId_Call{Call: _e.mock.On("GetPermissionLevelsByJobId", ctx, jobId)}
}

func (_c *MockJobsInterface_GetPermissionLevelsByJobId_Call) Run(run func(ctx context.Context, jobId string)) *MockJobsInterface_GetPermissionLevelsByJobId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockJobsInterface_GetPermissionLevelsByJobId_Call) Return(_a0 *jobs.GetJobPermissionLevelsResponse, _a1 error) *MockJobsInterface_GetPermissionLevelsByJobId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetPermissionLevelsByJobId_Call) RunAndReturn(run func(context.Context, string) (*jobs.GetJobPermissionLevelsResponse, error)) *MockJobsInterface_GetPermissionLevelsByJobId_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissions provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) GetPermissions(ctx context.Context, request jobs.GetJobPermissionsRequest) (*jobs.JobPermissions, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissions")
	}

	var r0 *jobs.JobPermissions
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetJobPermissionsRequest) (*jobs.JobPermissions, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetJobPermissionsRequest) *jobs.JobPermissions); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.JobPermissions)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.GetJobPermissionsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissions'
type MockJobsInterface_GetPermissions_Call struct {
	*mock.Call
}

// GetPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.GetJobPermissionsRequest
func (_e *MockJobsInterface_Expecter) GetPermissions(ctx interface{}, request interface{}) *MockJobsInterface_GetPermissions_Call {
	return &MockJobsInterface_GetPermissions_Call{Call: _e.mock.On("GetPermissions", ctx, request)}
}

func (_c *MockJobsInterface_GetPermissions_Call) Run(run func(ctx context.Context, request jobs.GetJobPermissionsRequest)) *MockJobsInterface_GetPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.GetJobPermissionsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_GetPermissions_Call) Return(_a0 *jobs.JobPermissions, _a1 error) *MockJobsInterface_GetPermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetPermissions_Call) RunAndReturn(run func(context.Context, jobs.GetJobPermissionsRequest) (*jobs.JobPermissions, error)) *MockJobsInterface_GetPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionsByJobId provides a mock function with given fields: ctx, jobId
func (_m *MockJobsInterface) GetPermissionsByJobId(ctx context.Context, jobId string) (*jobs.JobPermissions, error) {
	ret := _m.Called(ctx, jobId)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsByJobId")
	}

	var r0 *jobs.JobPermissions
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*jobs.JobPermissions, error)); ok {
		return rf(ctx, jobId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *jobs.JobPermissions); ok {
		r0 = rf(ctx, jobId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.JobPermissions)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetPermissionsByJobId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionsByJobId'
type MockJobsInterface_GetPermissionsByJobId_Call struct {
	*mock.Call
}

// GetPermissionsByJobId is a helper method to define mock.On call
//   - ctx context.Context
//   - jobId string
func (_e *MockJobsInterface_Expecter) GetPermissionsByJobId(ctx interface{}, jobId interface{}) *MockJobsInterface_GetPermissionsByJobId_Call {
	return &MockJobsInterface_GetPermissionsByJobId_Call{Call: _e.mock.On("GetPermissionsByJobId", ctx, jobId)}
}

func (_c *MockJobsInterface_GetPermissionsByJobId_Call) Run(run func(ctx context.Context, jobId string)) *MockJobsInterface_GetPermissionsByJobId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockJobsInterface_GetPermissionsByJobId_Call) Return(_a0 *jobs.JobPermissions, _a1 error) *MockJobsInterface_GetPermissionsByJobId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetPermissionsByJobId_Call) RunAndReturn(run func(context.Context, string) (*jobs.JobPermissions, error)) *MockJobsInterface_GetPermissionsByJobId_Call {
	_c.Call.Return(run)
	return _c
}

// GetRun provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) GetRun(ctx context.Context, request jobs.GetRunRequest) (*jobs.Run, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetRun")
	}

	var r0 *jobs.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetRunRequest) (*jobs.Run, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetRunRequest) *jobs.Run); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.GetRunRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRun'
type MockJobsInterface_GetRun_Call struct {
	*mock.Call
}

// GetRun is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.GetRunRequest
func (_e *MockJobsInterface_Expecter) GetRun(ctx interface{}, request interface{}) *MockJobsInterface_GetRun_Call {
	return &MockJobsInterface_GetRun_Call{Call: _e.mock.On("GetRun", ctx, request)}
}

func (_c *MockJobsInterface_GetRun_Call) Run(run func(ctx context.Context, request jobs.GetRunRequest)) *MockJobsInterface_GetRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.GetRunRequest))
	})
	return _c
}

func (_c *MockJobsInterface_GetRun_Call) Return(_a0 *jobs.Run, _a1 error) *MockJobsInterface_GetRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetRun_Call) RunAndReturn(run func(context.Context, jobs.GetRunRequest) (*jobs.Run, error)) *MockJobsInterface_GetRun_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunOutput provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) GetRunOutput(ctx context.Context, request jobs.GetRunOutputRequest) (*jobs.RunOutput, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetRunOutput")
	}

	var r0 *jobs.RunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetRunOutputRequest) (*jobs.RunOutput, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.GetRunOutputRequest) *jobs.RunOutput); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.RunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.GetRunOutputRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetRunOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunOutput'
type MockJobsInterface_GetRunOutput_Call struct {
	*mock.Call
}

// GetRunOutput is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.GetRunOutputRequest
func (_e *MockJobsInterface_Expecter) GetRunOutput(ctx interface{}, request interface{}) *MockJobsInterface_GetRunOutput_Call {
	return &MockJobsInterface_GetRunOutput_Call{Call: _e.mock.On("GetRunOutput", ctx, request)}
}

func (_c *MockJobsInterface_GetRunOutput_Call) Run(run func(ctx context.Context, request jobs.GetRunOutputRequest)) *MockJobsInterface_GetRunOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.GetRunOutputRequest))
	})
	return _c
}

func (_c *MockJobsInterface_GetRunOutput_Call) Return(_a0 *jobs.RunOutput, _a1 error) *MockJobsInterface_GetRunOutput_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetRunOutput_Call) RunAndReturn(run func(context.Context, jobs.GetRunOutputRequest) (*jobs.RunOutput, error)) *MockJobsInterface_GetRunOutput_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunOutputByRunId provides a mock function with given fields: ctx, runId
func (_m *MockJobsInterface) GetRunOutputByRunId(ctx context.Context, runId int64) (*jobs.RunOutput, error) {
	ret := _m.Called(ctx, runId)

	if len(ret) == 0 {
		panic("no return value specified for GetRunOutputByRunId")
	}

	var r0 *jobs.RunOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*jobs.RunOutput, error)); ok {
		return rf(ctx, runId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *jobs.RunOutput); ok {
		r0 = rf(ctx, runId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.RunOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, runId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_GetRunOutputByRunId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunOutputByRunId'
type MockJobsInterface_GetRunOutputByRunId_Call struct {
	*mock.Call
}

// GetRunOutputByRunId is a helper method to define mock.On call
//   - ctx context.Context
//   - runId int64
func (_e *MockJobsInterface_Expecter) GetRunOutputByRunId(ctx interface{}, runId interface{}) *MockJobsInterface_GetRunOutputByRunId_Call {
	return &MockJobsInterface_GetRunOutputByRunId_Call{Call: _e.mock.On("GetRunOutputByRunId", ctx, runId)}
}

func (_c *MockJobsInterface_GetRunOutputByRunId_Call) Run(run func(ctx context.Context, runId int64)) *MockJobsInterface_GetRunOutputByRunId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockJobsInterface_GetRunOutputByRunId_Call) Return(_a0 *jobs.RunOutput, _a1 error) *MockJobsInterface_GetRunOutputByRunId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_GetRunOutputByRunId_Call) RunAndReturn(run func(context.Context, int64) (*jobs.RunOutput, error)) *MockJobsInterface_GetRunOutputByRunId_Call {
	_c.Call.Return(run)
	return _c
}

// Impl provides a mock function with given fields:
func (_m *MockJobsInterface) Impl() jobs.JobsService {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Impl")
	}

	var r0 jobs.JobsService
	if rf, ok := ret.Get(0).(func() jobs.JobsService); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jobs.JobsService)
		}
	}

	return r0
}

// MockJobsInterface_Impl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Impl'
type MockJobsInterface_Impl_Call struct {
	*mock.Call
}

// Impl is a helper method to define mock.On call
func (_e *MockJobsInterface_Expecter) Impl() *MockJobsInterface_Impl_Call {
	return &MockJobsInterface_Impl_Call{Call: _e.mock.On("Impl")}
}

func (_c *MockJobsInterface_Impl_Call) Run(run func()) *MockJobsInterface_Impl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockJobsInterface_Impl_Call) Return(_a0 jobs.JobsService) *MockJobsInterface_Impl_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_Impl_Call) RunAndReturn(run func() jobs.JobsService) *MockJobsInterface_Impl_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) List(ctx context.Context, request jobs.ListJobsRequest) listing.Iterator[jobs.BaseJob] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 listing.Iterator[jobs.BaseJob]
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListJobsRequest) listing.Iterator[jobs.BaseJob]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[jobs.BaseJob])
		}
	}

	return r0
}

// MockJobsInterface_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockJobsInterface_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.ListJobsRequest
func (_e *MockJobsInterface_Expecter) List(ctx interface{}, request interface{}) *MockJobsInterface_List_Call {
	return &MockJobsInterface_List_Call{Call: _e.mock.On("List", ctx, request)}
}

func (_c *MockJobsInterface_List_Call) Run(run func(ctx context.Context, request jobs.ListJobsRequest)) *MockJobsInterface_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.ListJobsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_List_Call) Return(_a0 listing.Iterator[jobs.BaseJob]) *MockJobsInterface_List_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_List_Call) RunAndReturn(run func(context.Context, jobs.ListJobsRequest) listing.Iterator[jobs.BaseJob]) *MockJobsInterface_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListAll provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) ListAll(ctx context.Context, request jobs.ListJobsRequest) ([]jobs.BaseJob, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListAll")
	}

	var r0 []jobs.BaseJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListJobsRequest) ([]jobs.BaseJob, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListJobsRequest) []jobs.BaseJob); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]jobs.BaseJob)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.ListJobsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_ListAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAll'
type MockJobsInterface_ListAll_Call struct {
	*mock.Call
}

// ListAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.ListJobsRequest
func (_e *MockJobsInterface_Expecter) ListAll(ctx interface{}, request interface{}) *MockJobsInterface_ListAll_Call {
	return &MockJobsInterface_ListAll_Call{Call: _e.mock.On("ListAll", ctx, request)}
}

func (_c *MockJobsInterface_ListAll_Call) Run(run func(ctx context.Context, request jobs.ListJobsRequest)) *MockJobsInterface_ListAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.ListJobsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_ListAll_Call) Return(_a0 []jobs.BaseJob, _a1 error) *MockJobsInterface_ListAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_ListAll_Call) RunAndReturn(run func(context.Context, jobs.ListJobsRequest) ([]jobs.BaseJob, error)) *MockJobsInterface_ListAll_Call {
	_c.Call.Return(run)
	return _c
}

// ListRuns provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) ListRuns(ctx context.Context, request jobs.ListRunsRequest) listing.Iterator[jobs.BaseRun] {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListRuns")
	}

	var r0 listing.Iterator[jobs.BaseRun]
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListRunsRequest) listing.Iterator[jobs.BaseRun]); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(listing.Iterator[jobs.BaseRun])
		}
	}

	return r0
}

// MockJobsInterface_ListRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRuns'
type MockJobsInterface_ListRuns_Call struct {
	*mock.Call
}

// ListRuns is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.ListRunsRequest
func (_e *MockJobsInterface_Expecter) ListRuns(ctx interface{}, request interface{}) *MockJobsInterface_ListRuns_Call {
	return &MockJobsInterface_ListRuns_Call{Call: _e.mock.On("ListRuns", ctx, request)}
}

func (_c *MockJobsInterface_ListRuns_Call) Run(run func(ctx context.Context, request jobs.ListRunsRequest)) *MockJobsInterface_ListRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.ListRunsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_ListRuns_Call) Return(_a0 listing.Iterator[jobs.BaseRun]) *MockJobsInterface_ListRuns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_ListRuns_Call) RunAndReturn(run func(context.Context, jobs.ListRunsRequest) listing.Iterator[jobs.BaseRun]) *MockJobsInterface_ListRuns_Call {
	_c.Call.Return(run)
	return _c
}

// ListRunsAll provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) ListRunsAll(ctx context.Context, request jobs.ListRunsRequest) ([]jobs.BaseRun, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListRunsAll")
	}

	var r0 []jobs.BaseRun
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListRunsRequest) ([]jobs.BaseRun, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ListRunsRequest) []jobs.BaseRun); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]jobs.BaseRun)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.ListRunsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_ListRunsAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRunsAll'
type MockJobsInterface_ListRunsAll_Call struct {
	*mock.Call
}

// ListRunsAll is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.ListRunsRequest
func (_e *MockJobsInterface_Expecter) ListRunsAll(ctx interface{}, request interface{}) *MockJobsInterface_ListRunsAll_Call {
	return &MockJobsInterface_ListRunsAll_Call{Call: _e.mock.On("ListRunsAll", ctx, request)}
}

func (_c *MockJobsInterface_ListRunsAll_Call) Run(run func(ctx context.Context, request jobs.ListRunsRequest)) *MockJobsInterface_ListRunsAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.ListRunsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_ListRunsAll_Call) Return(_a0 []jobs.BaseRun, _a1 error) *MockJobsInterface_ListRunsAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_ListRunsAll_Call) RunAndReturn(run func(context.Context, jobs.ListRunsRequest) ([]jobs.BaseRun, error)) *MockJobsInterface_ListRunsAll_Call {
	_c.Call.Return(run)
	return _c
}

// RepairRun provides a mock function with given fields: ctx, repairRun
func (_m *MockJobsInterface) RepairRun(ctx context.Context, repairRun jobs.RepairRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RepairRunResponse], error) {
	ret := _m.Called(ctx, repairRun)

	if len(ret) == 0 {
		panic("no return value specified for RepairRun")
	}

	var r0 *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RepairRunResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RepairRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RepairRunResponse], error)); ok {
		return rf(ctx, repairRun)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RepairRun) *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RepairRunResponse]); ok {
		r0 = rf(ctx, repairRun)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RepairRunResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.RepairRun) error); ok {
		r1 = rf(ctx, repairRun)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_RepairRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepairRun'
type MockJobsInterface_RepairRun_Call struct {
	*mock.Call
}

// RepairRun is a helper method to define mock.On call
//   - ctx context.Context
//   - repairRun jobs.RepairRun
func (_e *MockJobsInterface_Expecter) RepairRun(ctx interface{}, repairRun interface{}) *MockJobsInterface_RepairRun_Call {
	return &MockJobsInterface_RepairRun_Call{Call: _e.mock.On("RepairRun", ctx, repairRun)}
}

func (_c *MockJobsInterface_RepairRun_Call) Run(run func(ctx context.Context, repairRun jobs.RepairRun)) *MockJobsInterface_RepairRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.RepairRun))
	})
	return _c
}

func (_c *MockJobsInterface_RepairRun_Call) Return(_a0 *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RepairRunResponse], _a1 error) *MockJobsInterface_RepairRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_RepairRun_Call) RunAndReturn(run func(context.Context, jobs.RepairRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RepairRunResponse], error)) *MockJobsInterface_RepairRun_Call {
	_c.Call.Return(run)
	return _c
}

// RepairRunAndWait provides a mock function with given fields: ctx, repairRun, options
func (_m *MockJobsInterface) RepairRunAndWait(ctx context.Context, repairRun jobs.RepairRun, options ...retries.Option[jobs.Run]) (*jobs.Run, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, repairRun)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RepairRunAndWait")
	}

	var r0 *jobs.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RepairRun, ...retries.Option[jobs.Run]) (*jobs.Run, error)); ok {
		return rf(ctx, repairRun, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RepairRun, ...retries.Option[jobs.Run]) *jobs.Run); ok {
		r0 = rf(ctx, repairRun, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.RepairRun, ...retries.Option[jobs.Run]) error); ok {
		r1 = rf(ctx, repairRun, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_RepairRunAndWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RepairRunAndWait'
type MockJobsInterface_RepairRunAndWait_Call struct {
	*mock.Call
}

// RepairRunAndWait is a helper method to define mock.On call
//   - ctx context.Context
//   - repairRun jobs.RepairRun
//   - options ...retries.Option[jobs.Run]
func (_e *MockJobsInterface_Expecter) RepairRunAndWait(ctx interface{}, repairRun interface{}, options ...interface{}) *MockJobsInterface_RepairRunAndWait_Call {
	return &MockJobsInterface_RepairRunAndWait_Call{Call: _e.mock.On("RepairRunAndWait",
		append([]interface{}{ctx, repairRun}, options...)...)}
}

func (_c *MockJobsInterface_RepairRunAndWait_Call) Run(run func(ctx context.Context, repairRun jobs.RepairRun, options ...retries.Option[jobs.Run])) *MockJobsInterface_RepairRunAndWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]retries.Option[jobs.Run], len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(retries.Option[jobs.Run])
			}
		}
		run(args[0].(context.Context), args[1].(jobs.RepairRun), variadicArgs...)
	})
	return _c
}

func (_c *MockJobsInterface_RepairRunAndWait_Call) Return(_a0 *jobs.Run, _a1 error) *MockJobsInterface_RepairRunAndWait_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_RepairRunAndWait_Call) RunAndReturn(run func(context.Context, jobs.RepairRun, ...retries.Option[jobs.Run]) (*jobs.Run, error)) *MockJobsInterface_RepairRunAndWait_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) Reset(ctx context.Context, request jobs.ResetJob) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.ResetJob) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type MockJobsInterface_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.ResetJob
func (_e *MockJobsInterface_Expecter) Reset(ctx interface{}, request interface{}) *MockJobsInterface_Reset_Call {
	return &MockJobsInterface_Reset_Call{Call: _e.mock.On("Reset", ctx, request)}
}

func (_c *MockJobsInterface_Reset_Call) Run(run func(ctx context.Context, request jobs.ResetJob)) *MockJobsInterface_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.ResetJob))
	})
	return _c
}

func (_c *MockJobsInterface_Reset_Call) Return(_a0 error) *MockJobsInterface_Reset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_Reset_Call) RunAndReturn(run func(context.Context, jobs.ResetJob) error) *MockJobsInterface_Reset_Call {
	_c.Call.Return(run)
	return _c
}

// RunNow provides a mock function with given fields: ctx, runNow
func (_m *MockJobsInterface) RunNow(ctx context.Context, runNow jobs.RunNow) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RunNowResponse], error) {
	ret := _m.Called(ctx, runNow)

	if len(ret) == 0 {
		panic("no return value specified for RunNow")
	}

	var r0 *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RunNowResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RunNow) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RunNowResponse], error)); ok {
		return rf(ctx, runNow)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RunNow) *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RunNowResponse]); ok {
		r0 = rf(ctx, runNow)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RunNowResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.RunNow) error); ok {
		r1 = rf(ctx, runNow)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_RunNow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunNow'
type MockJobsInterface_RunNow_Call struct {
	*mock.Call
}

// RunNow is a helper method to define mock.On call
//   - ctx context.Context
//   - runNow jobs.RunNow
func (_e *MockJobsInterface_Expecter) RunNow(ctx interface{}, runNow interface{}) *MockJobsInterface_RunNow_Call {
	return &MockJobsInterface_RunNow_Call{Call: _e.mock.On("RunNow", ctx, runNow)}
}

func (_c *MockJobsInterface_RunNow_Call) Run(run func(ctx context.Context, runNow jobs.RunNow)) *MockJobsInterface_RunNow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.RunNow))
	})
	return _c
}

func (_c *MockJobsInterface_RunNow_Call) Return(_a0 *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RunNowResponse], _a1 error) *MockJobsInterface_RunNow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_RunNow_Call) RunAndReturn(run func(context.Context, jobs.RunNow) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.RunNowResponse], error)) *MockJobsInterface_RunNow_Call {
	_c.Call.Return(run)
	return _c
}

// RunNowAndWait provides a mock function with given fields: ctx, runNow, options
func (_m *MockJobsInterface) RunNowAndWait(ctx context.Context, runNow jobs.RunNow, options ...retries.Option[jobs.Run]) (*jobs.Run, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, runNow)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunNowAndWait")
	}

	var r0 *jobs.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RunNow, ...retries.Option[jobs.Run]) (*jobs.Run, error)); ok {
		return rf(ctx, runNow, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.RunNow, ...retries.Option[jobs.Run]) *jobs.Run); ok {
		r0 = rf(ctx, runNow, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.RunNow, ...retries.Option[jobs.Run]) error); ok {
		r1 = rf(ctx, runNow, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_RunNowAndWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunNowAndWait'
type MockJobsInterface_RunNowAndWait_Call struct {
	*mock.Call
}

// RunNowAndWait is a helper method to define mock.On call
//   - ctx context.Context
//   - runNow jobs.RunNow
//   - options ...retries.Option[jobs.Run]
func (_e *MockJobsInterface_Expecter) RunNowAndWait(ctx interface{}, runNow interface{}, options ...interface{}) *MockJobsInterface_RunNowAndWait_Call {
	return &MockJobsInterface_RunNowAndWait_Call{Call: _e.mock.On("RunNowAndWait",
		append([]interface{}{ctx, runNow}, options...)...)}
}

func (_c *MockJobsInterface_RunNowAndWait_Call) Run(run func(ctx context.Context, runNow jobs.RunNow, options ...retries.Option[jobs.Run])) *MockJobsInterface_RunNowAndWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]retries.Option[jobs.Run], len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(retries.Option[jobs.Run])
			}
		}
		run(args[0].(context.Context), args[1].(jobs.RunNow), variadicArgs...)
	})
	return _c
}

func (_c *MockJobsInterface_RunNowAndWait_Call) Return(_a0 *jobs.Run, _a1 error) *MockJobsInterface_RunNowAndWait_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_RunNowAndWait_Call) RunAndReturn(run func(context.Context, jobs.RunNow, ...retries.Option[jobs.Run]) (*jobs.Run, error)) *MockJobsInterface_RunNowAndWait_Call {
	_c.Call.Return(run)
	return _c
}

// SetPermissions provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) SetPermissions(ctx context.Context, request jobs.JobPermissionsRequest) (*jobs.JobPermissions, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for SetPermissions")
	}

	var r0 *jobs.JobPermissions
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.JobPermissionsRequest) (*jobs.JobPermissions, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.JobPermissionsRequest) *jobs.JobPermissions); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.JobPermissions)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.JobPermissionsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_SetPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPermissions'
type MockJobsInterface_SetPermissions_Call struct {
	*mock.Call
}

// SetPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.JobPermissionsRequest
func (_e *MockJobsInterface_Expecter) SetPermissions(ctx interface{}, request interface{}) *MockJobsInterface_SetPermissions_Call {
	return &MockJobsInterface_SetPermissions_Call{Call: _e.mock.On("SetPermissions", ctx, request)}
}

func (_c *MockJobsInterface_SetPermissions_Call) Run(run func(ctx context.Context, request jobs.JobPermissionsRequest)) *MockJobsInterface_SetPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.JobPermissionsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_SetPermissions_Call) Return(_a0 *jobs.JobPermissions, _a1 error) *MockJobsInterface_SetPermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_SetPermissions_Call) RunAndReturn(run func(context.Context, jobs.JobPermissionsRequest) (*jobs.JobPermissions, error)) *MockJobsInterface_SetPermissions_Call {
	_c.Call.Return(run)
	return _c
}

// Submit provides a mock function with given fields: ctx, submitRun
func (_m *MockJobsInterface) Submit(ctx context.Context, submitRun jobs.SubmitRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.SubmitRunResponse], error) {
	ret := _m.Called(ctx, submitRun)

	if len(ret) == 0 {
		panic("no return value specified for Submit")
	}

	var r0 *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.SubmitRunResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.SubmitRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.SubmitRunResponse], error)); ok {
		return rf(ctx, submitRun)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.SubmitRun) *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.SubmitRunResponse]); ok {
		r0 = rf(ctx, submitRun)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.SubmitRunResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.SubmitRun) error); ok {
		r1 = rf(ctx, submitRun)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_Submit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Submit'
type MockJobsInterface_Submit_Call struct {
	*mock.Call
}

// Submit is a helper method to define mock.On call
//   - ctx context.Context
//   - submitRun jobs.SubmitRun
func (_e *MockJobsInterface_Expecter) Submit(ctx interface{}, submitRun interface{}) *MockJobsInterface_Submit_Call {
	return &MockJobsInterface_Submit_Call{Call: _e.mock.On("Submit", ctx, submitRun)}
}

func (_c *MockJobsInterface_Submit_Call) Run(run func(ctx context.Context, submitRun jobs.SubmitRun)) *MockJobsInterface_Submit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.SubmitRun))
	})
	return _c
}

func (_c *MockJobsInterface_Submit_Call) Return(_a0 *jobs.WaitGetRunJobTerminatedOrSkipped[jobs.SubmitRunResponse], _a1 error) *MockJobsInterface_Submit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_Submit_Call) RunAndReturn(run func(context.Context, jobs.SubmitRun) (*jobs.WaitGetRunJobTerminatedOrSkipped[jobs.SubmitRunResponse], error)) *MockJobsInterface_Submit_Call {
	_c.Call.Return(run)
	return _c
}

// SubmitAndWait provides a mock function with given fields: ctx, submitRun, options
func (_m *MockJobsInterface) SubmitAndWait(ctx context.Context, submitRun jobs.SubmitRun, options ...retries.Option[jobs.Run]) (*jobs.Run, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, submitRun)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubmitAndWait")
	}

	var r0 *jobs.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.SubmitRun, ...retries.Option[jobs.Run]) (*jobs.Run, error)); ok {
		return rf(ctx, submitRun, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.SubmitRun, ...retries.Option[jobs.Run]) *jobs.Run); ok {
		r0 = rf(ctx, submitRun, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.SubmitRun, ...retries.Option[jobs.Run]) error); ok {
		r1 = rf(ctx, submitRun, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_SubmitAndWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitAndWait'
type MockJobsInterface_SubmitAndWait_Call struct {
	*mock.Call
}

// SubmitAndWait is a helper method to define mock.On call
//   - ctx context.Context
//   - submitRun jobs.SubmitRun
//   - options ...retries.Option[jobs.Run]
func (_e *MockJobsInterface_Expecter) SubmitAndWait(ctx interface{}, submitRun interface{}, options ...interface{}) *MockJobsInterface_SubmitAndWait_Call {
	return &MockJobsInterface_SubmitAndWait_Call{Call: _e.mock.On("SubmitAndWait",
		append([]interface{}{ctx, submitRun}, options...)...)}
}

func (_c *MockJobsInterface_SubmitAndWait_Call) Run(run func(ctx context.Context, submitRun jobs.SubmitRun, options ...retries.Option[jobs.Run])) *MockJobsInterface_SubmitAndWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]retries.Option[jobs.Run], len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(retries.Option[jobs.Run])
			}
		}
		run(args[0].(context.Context), args[1].(jobs.SubmitRun), variadicArgs...)
	})
	return _c
}

func (_c *MockJobsInterface_SubmitAndWait_Call) Return(_a0 *jobs.Run, _a1 error) *MockJobsInterface_SubmitAndWait_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_SubmitAndWait_Call) RunAndReturn(run func(context.Context, jobs.SubmitRun, ...retries.Option[jobs.Run]) (*jobs.Run, error)) *MockJobsInterface_SubmitAndWait_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) Update(ctx context.Context, request jobs.UpdateJob) error {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.UpdateJob) error); ok {
		r0 = rf(ctx, request)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockJobsInterface_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockJobsInterface_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.UpdateJob
func (_e *MockJobsInterface_Expecter) Update(ctx interface{}, request interface{}) *MockJobsInterface_Update_Call {
	return &MockJobsInterface_Update_Call{Call: _e.mock.On("Update", ctx, request)}
}

func (_c *MockJobsInterface_Update_Call) Run(run func(ctx context.Context, request jobs.UpdateJob)) *MockJobsInterface_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.UpdateJob))
	})
	return _c
}

func (_c *MockJobsInterface_Update_Call) Return(_a0 error) *MockJobsInterface_Update_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_Update_Call) RunAndReturn(run func(context.Context, jobs.UpdateJob) error) *MockJobsInterface_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePermissions provides a mock function with given fields: ctx, request
func (_m *MockJobsInterface) UpdatePermissions(ctx context.Context, request jobs.JobPermissionsRequest) (*jobs.JobPermissions, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePermissions")
	}

	var r0 *jobs.JobPermissions
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jobs.JobPermissionsRequest) (*jobs.JobPermissions, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jobs.JobPermissionsRequest) *jobs.JobPermissions); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.JobPermissions)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jobs.JobPermissionsRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_UpdatePermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePermissions'
type MockJobsInterface_UpdatePermissions_Call struct {
	*mock.Call
}

// UpdatePermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - request jobs.JobPermissionsRequest
func (_e *MockJobsInterface_Expecter) UpdatePermissions(ctx interface{}, request interface{}) *MockJobsInterface_UpdatePermissions_Call {
	return &MockJobsInterface_UpdatePermissions_Call{Call: _e.mock.On("UpdatePermissions", ctx, request)}
}

func (_c *MockJobsInterface_UpdatePermissions_Call) Run(run func(ctx context.Context, request jobs.JobPermissionsRequest)) *MockJobsInterface_UpdatePermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jobs.JobPermissionsRequest))
	})
	return _c
}

func (_c *MockJobsInterface_UpdatePermissions_Call) Return(_a0 *jobs.JobPermissions, _a1 error) *MockJobsInterface_UpdatePermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_UpdatePermissions_Call) RunAndReturn(run func(context.Context, jobs.JobPermissionsRequest) (*jobs.JobPermissions, error)) *MockJobsInterface_UpdatePermissions_Call {
	_c.Call.Return(run)
	return _c
}

// WaitGetRunJobTerminatedOrSkipped provides a mock function with given fields: ctx, runId, timeout, callback
func (_m *MockJobsInterface) WaitGetRunJobTerminatedOrSkipped(ctx context.Context, runId int64, timeout time.Duration, callback func(*jobs.Run)) (*jobs.Run, error) {
	ret := _m.Called(ctx, runId, timeout, callback)

	if len(ret) == 0 {
		panic("no return value specified for WaitGetRunJobTerminatedOrSkipped")
	}

	var r0 *jobs.Run
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, time.Duration, func(*jobs.Run)) (*jobs.Run, error)); ok {
		return rf(ctx, runId, timeout, callback)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, time.Duration, func(*jobs.Run)) *jobs.Run); ok {
		r0 = rf(ctx, runId, timeout, callback)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jobs.Run)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, time.Duration, func(*jobs.Run)) error); ok {
		r1 = rf(ctx, runId, timeout, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitGetRunJobTerminatedOrSkipped'
type MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call struct {
	*mock.Call
}

// WaitGetRunJobTerminatedOrSkipped is a helper method to define mock.On call
//   - ctx context.Context
//   - runId int64
//   - timeout time.Duration
//   - callback func(*jobs.Run)
func (_e *MockJobsInterface_Expecter) WaitGetRunJobTerminatedOrSkipped(ctx interface{}, runId interface{}, timeout interface{}, callback interface{}) *MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call {
	return &MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call{Call: _e.mock.On("WaitGetRunJobTerminatedOrSkipped", ctx, runId, timeout, callback)}
}

func (_c *MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call) Run(run func(ctx context.Context, runId int64, timeout time.Duration, callback func(*jobs.Run))) *MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(time.Duration), args[3].(func(*jobs.Run)))
	})
	return _c
}

func (_c *MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call) Return(_a0 *jobs.Run, _a1 error) *MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call) RunAndReturn(run func(context.Context, int64, time.Duration, func(*jobs.Run)) (*jobs.Run, error)) *MockJobsInterface_WaitGetRunJobTerminatedOrSkipped_Call {
	_c.Call.Return(run)
	return _c
}

// WithImpl provides a mock function with given fields: impl
func (_m *MockJobsInterface) WithImpl(impl jobs.JobsService) jobs.JobsInterface {
	ret := _m.Called(impl)

	if len(ret) == 0 {
		panic("no return value specified for WithImpl")
	}

	var r0 jobs.JobsInterface
	if rf, ok := ret.Get(0).(func(jobs.JobsService) jobs.JobsInterface); ok {
		r0 = rf(impl)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jobs.JobsInterface)
		}
	}

	return r0
}

// MockJobsInterface_WithImpl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithImpl'
type MockJobsInterface_WithImpl_Call struct {
	*mock.Call
}

// WithImpl is a helper method to define mock.On call
//   - impl jobs.JobsService
func (_e *MockJobsInterface_Expecter) WithImpl(impl interface{}) *MockJobsInterface_WithImpl_Call {
	return &MockJobsInterface_WithImpl_Call{Call: _e.mock.On("WithImpl", impl)}
}

func (_c *MockJobsInterface_WithImpl_Call) Run(run func(impl jobs.JobsService)) *MockJobsInterface_WithImpl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(jobs.JobsService))
	})
	return _c
}

func (_c *MockJobsInterface_WithImpl_Call) Return(_a0 jobs.JobsInterface) *MockJobsInterface_WithImpl_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockJobsInterface_WithImpl_Call) RunAndReturn(run func(jobs.JobsService) jobs.JobsInterface) *MockJobsInterface_WithImpl_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockJobsInterface creates a new instance of MockJobsInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockJobsInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockJobsInterface {
	mock := &MockJobsInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
