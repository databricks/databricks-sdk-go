// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Credentials, Encryption Keys, Networks, Private Access, Storage, Vpc Endpoints, Workspaces, etc.
package provisioning

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/databricks/useragent"
)

type credentialsBaseClient struct {
	credentialsImpl
}

// Delete credential configuration.
//
// Deletes a Databricks credential configuration object for an account, both
// specified by ID. You cannot delete a credential that is associated with any
// workspace.
func (a *credentialsBaseClient) DeleteByCredentialsId(ctx context.Context, credentialsId string) (*DeleteResponse, error) {
	return a.credentialsImpl.Delete(ctx, DeleteCredentialRequest{
		CredentialsId: credentialsId,
	})
}

// Get credential configuration.
//
// Gets a Databricks credential configuration object for an account, both
// specified by ID.
func (a *credentialsBaseClient) GetByCredentialsId(ctx context.Context, credentialsId string) (*Credential, error) {
	return a.credentialsImpl.Get(ctx, GetCredentialRequest{
		CredentialsId: credentialsId,
	})
}

// CredentialCredentialsNameToCredentialsIdMap calls [credentialsBaseClient.List] and creates a map of results with [Credential].CredentialsName as key and [Credential].CredentialsId as value.
//
// Returns an error if there's more than one [Credential] with the same .CredentialsName.
//
// Note: All [Credential] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *credentialsBaseClient) CredentialCredentialsNameToCredentialsIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.CredentialsName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .CredentialsName: %s", key)
		}
		mapping[key] = v.CredentialsId
	}
	return mapping, nil
}

// GetByCredentialsName calls [credentialsBaseClient.CredentialCredentialsNameToCredentialsIdMap] and returns a single [Credential].
//
// Returns an error if there's more than one [Credential] with the same .CredentialsName.
//
// Note: All [Credential] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *credentialsBaseClient) GetByCredentialsName(ctx context.Context, name string) (*Credential, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Credential{}
	for _, v := range result {
		key := v.CredentialsName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Credential named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Credential named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type encryptionKeysBaseClient struct {
	encryptionKeysImpl
}

// Delete encryption key configuration.
//
// Deletes a customer-managed key configuration object for an account. You
// cannot delete a configuration that is associated with a running workspace.
func (a *encryptionKeysBaseClient) DeleteByCustomerManagedKeyId(ctx context.Context, customerManagedKeyId string) (*DeleteResponse, error) {
	return a.encryptionKeysImpl.Delete(ctx, DeleteEncryptionKeyRequest{
		CustomerManagedKeyId: customerManagedKeyId,
	})
}

// Get encryption key configuration.
//
// Gets a customer-managed key configuration object for an account, specified by
// ID. This operation uploads a reference to a customer-managed key to
// Databricks. If assigned as a workspace's customer-managed key for managed
// services, Databricks uses the key to encrypt the workspaces notebooks and
// secrets in the control plane, in addition to Databricks SQL queries and query
// history. If it is specified as a workspace's customer-managed key for
// storage, the key encrypts the workspace's root S3 bucket (which contains the
// workspace's root DBFS and system data) and, optionally, cluster EBS volume
// data.
//
// **Important**: Customer-managed keys are supported only for some deployment
// types, subscription types, and AWS regions.
//
// This operation is available only if your account is on the E2 version of the
// platform.",
func (a *encryptionKeysBaseClient) GetByCustomerManagedKeyId(ctx context.Context, customerManagedKeyId string) (*CustomerManagedKey, error) {
	return a.encryptionKeysImpl.Get(ctx, GetEncryptionKeyRequest{
		CustomerManagedKeyId: customerManagedKeyId,
	})
}

type networksBaseClient struct {
	networksImpl
}

// Delete a network configuration.
//
// Deletes a Databricks network configuration, which represents a cloud VPC and
// its resources. You cannot delete a network that is associated with a
// workspace.
//
// This operation is available only if your account is on the E2 version of the
// platform.
func (a *networksBaseClient) DeleteByNetworkId(ctx context.Context, networkId string) (*DeleteResponse, error) {
	return a.networksImpl.Delete(ctx, DeleteNetworkRequest{
		NetworkId: networkId,
	})
}

// Get a network configuration.
//
// Gets a Databricks network configuration, which represents a cloud VPC and its
// resources.
func (a *networksBaseClient) GetByNetworkId(ctx context.Context, networkId string) (*Network, error) {
	return a.networksImpl.Get(ctx, GetNetworkRequest{
		NetworkId: networkId,
	})
}

// NetworkNetworkNameToNetworkIdMap calls [networksBaseClient.List] and creates a map of results with [Network].NetworkName as key and [Network].NetworkId as value.
//
// Returns an error if there's more than one [Network] with the same .NetworkName.
//
// Note: All [Network] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *networksBaseClient) NetworkNetworkNameToNetworkIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.NetworkName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .NetworkName: %s", key)
		}
		mapping[key] = v.NetworkId
	}
	return mapping, nil
}

// GetByNetworkName calls [networksBaseClient.NetworkNetworkNameToNetworkIdMap] and returns a single [Network].
//
// Returns an error if there's more than one [Network] with the same .NetworkName.
//
// Note: All [Network] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *networksBaseClient) GetByNetworkName(ctx context.Context, name string) (*Network, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Network{}
	for _, v := range result {
		key := v.NetworkName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Network named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Network named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type privateAccessBaseClient struct {
	privateAccessImpl
}

// Delete a private access settings object.
//
// Deletes a private access settings object, which determines how your workspace
// is accessed over [AWS PrivateLink].
//
// Before configuring PrivateLink, read the [Databricks article about
// PrivateLink].",
//
// [AWS PrivateLink]: https://aws.amazon.com/privatelink
// [Databricks article about PrivateLink]: https://docs.databricks.com/administration-guide/cloud-configurations/aws/privatelink.html
func (a *privateAccessBaseClient) DeleteByPrivateAccessSettingsId(ctx context.Context, privateAccessSettingsId string) (*DeleteResponse, error) {
	return a.privateAccessImpl.Delete(ctx, DeletePrivateAccesRequest{
		PrivateAccessSettingsId: privateAccessSettingsId,
	})
}

// Get a private access settings object.
//
// Gets a private access settings object, which specifies how your workspace is
// accessed over [AWS PrivateLink].
//
// Before configuring PrivateLink, read the [Databricks article about
// PrivateLink].",
//
// [AWS PrivateLink]: https://aws.amazon.com/privatelink
// [Databricks article about PrivateLink]: https://docs.databricks.com/administration-guide/cloud-configurations/aws/privatelink.html
func (a *privateAccessBaseClient) GetByPrivateAccessSettingsId(ctx context.Context, privateAccessSettingsId string) (*PrivateAccessSettings, error) {
	return a.privateAccessImpl.Get(ctx, GetPrivateAccesRequest{
		PrivateAccessSettingsId: privateAccessSettingsId,
	})
}

// PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap calls [privateAccessBaseClient.List] and creates a map of results with [PrivateAccessSettings].PrivateAccessSettingsName as key and [PrivateAccessSettings].PrivateAccessSettingsId as value.
//
// Returns an error if there's more than one [PrivateAccessSettings] with the same .PrivateAccessSettingsName.
//
// Note: All [PrivateAccessSettings] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *privateAccessBaseClient) PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.PrivateAccessSettingsName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .PrivateAccessSettingsName: %s", key)
		}
		mapping[key] = v.PrivateAccessSettingsId
	}
	return mapping, nil
}

// GetByPrivateAccessSettingsName calls [privateAccessBaseClient.PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap] and returns a single [PrivateAccessSettings].
//
// Returns an error if there's more than one [PrivateAccessSettings] with the same .PrivateAccessSettingsName.
//
// Note: All [PrivateAccessSettings] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *privateAccessBaseClient) GetByPrivateAccessSettingsName(ctx context.Context, name string) (*PrivateAccessSettings, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PrivateAccessSettings{}
	for _, v := range result {
		key := v.PrivateAccessSettingsName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PrivateAccessSettings named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PrivateAccessSettings named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type storageBaseClient struct {
	storageImpl
}

// Delete storage configuration.
//
// Deletes a Databricks storage configuration. You cannot delete a storage
// configuration that is associated with any workspace.
func (a *storageBaseClient) DeleteByStorageConfigurationId(ctx context.Context, storageConfigurationId string) (*DeleteResponse, error) {
	return a.storageImpl.Delete(ctx, DeleteStorageRequest{
		StorageConfigurationId: storageConfigurationId,
	})
}

// Get storage configuration.
//
// Gets a Databricks storage configuration for an account, both specified by ID.
func (a *storageBaseClient) GetByStorageConfigurationId(ctx context.Context, storageConfigurationId string) (*StorageConfiguration, error) {
	return a.storageImpl.Get(ctx, GetStorageRequest{
		StorageConfigurationId: storageConfigurationId,
	})
}

// StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap calls [storageBaseClient.List] and creates a map of results with [StorageConfiguration].StorageConfigurationName as key and [StorageConfiguration].StorageConfigurationId as value.
//
// Returns an error if there's more than one [StorageConfiguration] with the same .StorageConfigurationName.
//
// Note: All [StorageConfiguration] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *storageBaseClient) StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.StorageConfigurationName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .StorageConfigurationName: %s", key)
		}
		mapping[key] = v.StorageConfigurationId
	}
	return mapping, nil
}

// GetByStorageConfigurationName calls [storageBaseClient.StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap] and returns a single [StorageConfiguration].
//
// Returns an error if there's more than one [StorageConfiguration] with the same .StorageConfigurationName.
//
// Note: All [StorageConfiguration] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *storageBaseClient) GetByStorageConfigurationName(ctx context.Context, name string) (*StorageConfiguration, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]StorageConfiguration{}
	for _, v := range result {
		key := v.StorageConfigurationName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("StorageConfiguration named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of StorageConfiguration named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type vpcEndpointsBaseClient struct {
	vpcEndpointsImpl
}

// Delete VPC endpoint configuration.
//
// Deletes a VPC endpoint configuration, which represents an [AWS VPC endpoint]
// that can communicate privately with Databricks over [AWS PrivateLink].
//
// Before configuring PrivateLink, read the [Databricks article about
// PrivateLink].
//
// [AWS PrivateLink]: https://aws.amazon.com/privatelink
// [AWS VPC endpoint]: https://docs.aws.amazon.com/vpc/latest/privatelink/concepts.html
// [Databricks article about PrivateLink]: https://docs.databricks.com/administration-guide/cloud-configurations/aws/privatelink.html
func (a *vpcEndpointsBaseClient) DeleteByVpcEndpointId(ctx context.Context, vpcEndpointId string) (*DeleteResponse, error) {
	return a.vpcEndpointsImpl.Delete(ctx, DeleteVpcEndpointRequest{
		VpcEndpointId: vpcEndpointId,
	})
}

// Get a VPC endpoint configuration.
//
// Gets a VPC endpoint configuration, which represents a [VPC endpoint] object
// in AWS used to communicate privately with Databricks over [AWS PrivateLink].
//
// [AWS PrivateLink]: https://aws.amazon.com/privatelink
// [VPC endpoint]: https://docs.aws.amazon.com/vpc/latest/privatelink/concepts.html
func (a *vpcEndpointsBaseClient) GetByVpcEndpointId(ctx context.Context, vpcEndpointId string) (*VpcEndpoint, error) {
	return a.vpcEndpointsImpl.Get(ctx, GetVpcEndpointRequest{
		VpcEndpointId: vpcEndpointId,
	})
}

// VpcEndpointVpcEndpointNameToVpcEndpointIdMap calls [vpcEndpointsBaseClient.List] and creates a map of results with [VpcEndpoint].VpcEndpointName as key and [VpcEndpoint].VpcEndpointId as value.
//
// Returns an error if there's more than one [VpcEndpoint] with the same .VpcEndpointName.
//
// Note: All [VpcEndpoint] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *vpcEndpointsBaseClient) VpcEndpointVpcEndpointNameToVpcEndpointIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.VpcEndpointName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .VpcEndpointName: %s", key)
		}
		mapping[key] = v.VpcEndpointId
	}
	return mapping, nil
}

// GetByVpcEndpointName calls [vpcEndpointsBaseClient.VpcEndpointVpcEndpointNameToVpcEndpointIdMap] and returns a single [VpcEndpoint].
//
// Returns an error if there's more than one [VpcEndpoint] with the same .VpcEndpointName.
//
// Note: All [VpcEndpoint] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *vpcEndpointsBaseClient) GetByVpcEndpointName(ctx context.Context, name string) (*VpcEndpoint, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]VpcEndpoint{}
	for _, v := range result {
		key := v.VpcEndpointName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("VpcEndpoint named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of VpcEndpoint named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type workspacesBaseClient struct {
	workspacesImpl
}

// Delete a workspace.
//
// Terminates and deletes a Databricks workspace. From an API perspective,
// deletion is immediate. However, it might take a few minutes for all
// workspaces resources to be deleted, depending on the size and number of
// workspace resources.
//
// This operation is available only if your account is on the E2 version of the
// platform or on a select custom plan that allows multiple workspaces per
// account.
func (a *workspacesBaseClient) DeleteByWorkspaceId(ctx context.Context, workspaceId int64) (*DeleteResponse, error) {
	return a.workspacesImpl.Delete(ctx, DeleteWorkspaceRequest{
		WorkspaceId: workspaceId,
	})
}

// Get a workspace.
//
// Gets information including status for a Databricks workspace, specified by
// ID. In the response, the `workspace_status` field indicates the current
// status. After initial workspace creation (which is asynchronous), make
// repeated `GET` requests with the workspace ID and check its status. The
// workspace becomes available when the status changes to `RUNNING`.
//
// For information about how to create a new workspace with this API **including
// error handling**, see [Create a new workspace using the Account API].
//
// This operation is available only if your account is on the E2 version of the
// platform or on a select custom plan that allows multiple workspaces per
// account.
//
// [Create a new workspace using the Account API]: http://docs.databricks.com/administration-guide/account-api/new-workspace.html
func (a *workspacesBaseClient) GetByWorkspaceId(ctx context.Context, workspaceId int64) (*Workspace, error) {
	return a.workspacesImpl.Get(ctx, GetWorkspaceRequest{
		WorkspaceId: workspaceId,
	})
}

// WorkspaceWorkspaceNameToWorkspaceIdMap calls [workspacesBaseClient.List] and creates a map of results with [Workspace].WorkspaceName as key and [Workspace].WorkspaceId as value.
//
// Returns an error if there's more than one [Workspace] with the same .WorkspaceName.
//
// Note: All [Workspace] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *workspacesBaseClient) WorkspaceWorkspaceNameToWorkspaceIdMap(ctx context.Context) (map[string]int64, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]int64{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.WorkspaceName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .WorkspaceName: %s", key)
		}
		mapping[key] = v.WorkspaceId
	}
	return mapping, nil
}

// GetByWorkspaceName calls [workspacesBaseClient.WorkspaceWorkspaceNameToWorkspaceIdMap] and returns a single [Workspace].
//
// Returns an error if there's more than one [Workspace] with the same .WorkspaceName.
//
// Note: All [Workspace] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *workspacesBaseClient) GetByWorkspaceName(ctx context.Context, name string) (*Workspace, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Workspace{}
	for _, v := range result {
		key := v.WorkspaceName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Workspace named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Workspace named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}
