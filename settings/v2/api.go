// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Ip Access Lists, Account Settings, Aibi Dashboard Embedding Access Policy, Aibi Dashboard Embedding Approved Domains, Automatic Cluster Update, Compliance Security Profile, Credentials Manager, Csp Enablement Account, Default Namespace, Disable Legacy Access, Disable Legacy Dbfs, Disable Legacy Features, Enable Ip Access Lists, Enhanced Security Monitoring, Esm Enablement Account, Ip Access Lists, Network Connectivity, Notification Destinations, Personal Compute, Restrict Workspace Admins, Settings, Token Management, Tokens, Workspace Conf, etc.
package settings

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/databricks/useragent"
)

type accountIpAccessListsBaseClient struct {
	accountIpAccessListsImpl
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *accountIpAccessListsBaseClient) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) (*DeleteResponse, error) {
	return a.accountIpAccessListsImpl.Delete(ctx, DeleteAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get IP access list.
//
// Gets an IP access list, specified by its list ID.
func (a *accountIpAccessListsBaseClient) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error) {
	return a.accountIpAccessListsImpl.Get(ctx, GetAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [accountIpAccessListsBaseClient.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *accountIpAccessListsBaseClient) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [accountIpAccessListsBaseClient.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *accountIpAccessListsBaseClient) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type accountSettingsBaseClient struct {
	accountSettingsImpl
}

type aibiDashboardEmbeddingAccessPolicyBaseClient struct {
	aibiDashboardEmbeddingAccessPolicyImpl
}

type aibiDashboardEmbeddingApprovedDomainsBaseClient struct {
	aibiDashboardEmbeddingApprovedDomainsImpl
}

type automaticClusterUpdateBaseClient struct {
	automaticClusterUpdateImpl
}

type complianceSecurityProfileBaseClient struct {
	complianceSecurityProfileImpl
}

type credentialsManagerBaseClient struct {
	credentialsManagerImpl
}

type cspEnablementAccountBaseClient struct {
	cspEnablementAccountImpl
}

type defaultNamespaceBaseClient struct {
	defaultNamespaceImpl
}

type disableLegacyAccessBaseClient struct {
	disableLegacyAccessImpl
}

type disableLegacyDbfsBaseClient struct {
	disableLegacyDbfsImpl
}

type disableLegacyFeaturesBaseClient struct {
	disableLegacyFeaturesImpl
}

type enableIpAccessListsBaseClient struct {
	enableIpAccessListsImpl
}

type enhancedSecurityMonitoringBaseClient struct {
	enhancedSecurityMonitoringImpl
}

type esmEnablementAccountBaseClient struct {
	esmEnablementAccountImpl
}

type ipAccessListsBaseClient struct {
	ipAccessListsImpl
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *ipAccessListsBaseClient) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) (*DeleteResponse, error) {
	return a.ipAccessListsImpl.Delete(ctx, DeleteIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access list.
//
// Gets an IP access list, specified by its list ID.
func (a *ipAccessListsBaseClient) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error) {
	return a.ipAccessListsImpl.Get(ctx, GetIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [ipAccessListsBaseClient.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ipAccessListsBaseClient) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [ipAccessListsBaseClient.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ipAccessListsBaseClient) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type networkConnectivityBaseClient struct {
	networkConnectivityImpl
}

// Delete a network connectivity configuration.
//
// Deletes a network connectivity configuration.
func (a *networkConnectivityBaseClient) DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*DeleteNetworkConnectivityConfigurationResponse, error) {
	return a.networkConnectivityImpl.DeleteNetworkConnectivityConfiguration(ctx, DeleteNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Delete a private endpoint rule.
//
// Initiates deleting a private endpoint rule. If the connection state is
// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
// the private endpoint is deactivated and will be deleted after seven days of
// deactivation. When a private endpoint is deactivated, the `deactivated` field
// is set to `true` and the private endpoint is not available to your serverless
// compute resources.
func (a *networkConnectivityBaseClient) DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.networkConnectivityImpl.DeletePrivateEndpointRule(ctx, DeletePrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// Get a network connectivity configuration.
//
// Gets a network connectivity configuration.
func (a *networkConnectivityBaseClient) GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error) {
	return a.networkConnectivityImpl.GetNetworkConnectivityConfiguration(ctx, GetNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Get a private endpoint rule.
//
// Gets the private endpoint rule.
func (a *networkConnectivityBaseClient) GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.networkConnectivityImpl.GetPrivateEndpointRule(ctx, GetPrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
func (a *networkConnectivityBaseClient) ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error) {
	return a.networkConnectivityImpl.internalListPrivateEndpointRules(ctx, ListPrivateEndpointRulesRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

type notificationDestinationsBaseClient struct {
	notificationDestinationsImpl
}

// Delete a notification destination.
//
// Deletes a notification destination. Requires workspace admin permissions.
func (a *notificationDestinationsBaseClient) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.notificationDestinationsImpl.Delete(ctx, DeleteNotificationDestinationRequest{
		Id: id,
	})
}

// Get a notification destination.
//
// Gets a notification destination.
func (a *notificationDestinationsBaseClient) GetById(ctx context.Context, id string) (*NotificationDestination, error) {
	return a.notificationDestinationsImpl.Get(ctx, GetNotificationDestinationRequest{
		Id: id,
	})
}

type personalComputeBaseClient struct {
	personalComputeImpl
}

type restrictWorkspaceAdminsBaseClient struct {
	restrictWorkspaceAdminsImpl
}

type settingsBaseClient struct {
	settingsImpl
}

type tokenManagementBaseClient struct {
	tokenManagementImpl
}

// Delete a token.
//
// Deletes a token, specified by its ID.
func (a *tokenManagementBaseClient) DeleteByTokenId(ctx context.Context, tokenId string) (*DeleteResponse, error) {
	return a.tokenManagementImpl.Delete(ctx, DeleteTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Get token info.
//
// Gets information about a token, specified by its ID.
func (a *tokenManagementBaseClient) GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error) {
	return a.tokenManagementImpl.Get(ctx, GetTokenManagementRequest{
		TokenId: tokenId,
	})
}

// TokenInfoCommentToTokenIdMap calls [tokenManagementBaseClient.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *tokenManagementBaseClient) TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [tokenManagementBaseClient.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *tokenManagementBaseClient) GetByComment(ctx context.Context, name string) (*TokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTokenManagementRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type tokensBaseClient struct {
	tokensImpl
}

// Revoke token.
//
// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *tokensBaseClient) DeleteByTokenId(ctx context.Context, tokenId string) (*RevokeTokenResponse, error) {
	return a.tokensImpl.Delete(ctx, RevokeTokenRequest{
		TokenId: tokenId,
	})
}

// PublicTokenInfoCommentToTokenIdMap calls [tokensBaseClient.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *tokensBaseClient) PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [tokensBaseClient.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *tokensBaseClient) GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PublicTokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PublicTokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PublicTokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type workspaceConfBaseClient struct {
	workspaceConfImpl
}
