// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Ip Access Lists, Account Settings, Aibi Dashboard Embedding Access Policy, Aibi Dashboard Embedding Approved Domains, Automatic Cluster Update, Compliance Security Profile, Credentials Manager, Csp Enablement Account, Default Namespace, Disable Legacy Access, Disable Legacy Dbfs, Disable Legacy Features, Enable Ip Access Lists, Enhanced Security Monitoring, Esm Enablement Account, Ip Access Lists, Network Connectivity, Notification Destinations, Personal Compute, Restrict Workspace Admins, Settings, Token Management, Tokens, Workspace Conf, etc.
package settings

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/databricks/useragent"
)

// The Accounts IP Access List API enables account admins to configure IP access
// lists for access to the account console.
//
// Account IP Access Lists affect web application access and REST API access to
// the account console and account APIs. If the feature is disabled for the
// account, all access is allowed for this account. There is support for allow
// lists (inclusion) and block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the account, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the account, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the account supports a maximum
// of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the account-level IP access lists, it can take a few minutes
// for changes to take effect.
type AccountIpAccessListsAPI struct {
	accountIpAccessListsImpl
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) (*DeleteResponse, error) {
	return a.accountIpAccessListsImpl.Delete(ctx, DeleteAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get IP access list.
//
// Gets an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error) {
	return a.accountIpAccessListsImpl.Get(ctx, GetAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Accounts Settings API allows users to manage settings at the account level.
type AccountSettingsAPI struct {
	accountSettingsImpl
}

// Controls whether AI/BI published dashboard embedding is enabled,
// conditionally enabled, or disabled at the workspace level. By default, this
// setting is conditionally enabled (ALLOW_APPROVED_DOMAINS).
type AibiDashboardEmbeddingAccessPolicyAPI struct {
	aibiDashboardEmbeddingAccessPolicyImpl
}

// Controls the list of domains approved to host the embedded AI/BI dashboards.
// The approved domains list can't be mutated when the current access policy is
// not set to ALLOW_APPROVED_DOMAINS.
type AibiDashboardEmbeddingApprovedDomainsAPI struct {
	aibiDashboardEmbeddingApprovedDomainsImpl
}

// Controls whether automatic cluster update is enabled for the current
// workspace. By default, it is turned off.
type AutomaticClusterUpdateAPI struct {
	automaticClusterUpdateImpl
}

// Controls whether to enable the compliance security profile for the current
// workspace. Enabling it on a workspace is permanent. By default, it is turned
// off.
//
// This settings can NOT be disabled once it is enabled.
type ComplianceSecurityProfileAPI struct {
	complianceSecurityProfileImpl
}

// Credentials manager interacts with with Identity Providers to to perform
// token exchanges using stored credentials and refresh tokens.
type CredentialsManagerAPI struct {
	credentialsManagerImpl
}

// The compliance security profile settings at the account level control whether
// to enable it for new workspaces. By default, this account-level setting is
// disabled for new workspaces. After workspace creation, account admins can
// enable the compliance security profile individually for each workspace.
//
// This settings can be disabled so that new workspaces do not have compliance
// security profile enabled by default.
type CspEnablementAccountAPI struct {
	cspEnablementAccountImpl
}

// The default namespace setting API allows users to configure the default
// namespace for a Databricks workspace.
//
// Through this API, users can retrieve, set, or modify the default namespace
// used when queries do not reference a fully qualified three-level name. For
// example, if you use the API to set 'retail_prod' as the default catalog, then
// a query 'SELECT * FROM myTable' would reference the object
// 'retail_prod.default.myTable' (the schema 'default' is always assumed).
//
// This setting requires a restart of clusters and SQL warehouses to take
// effect. Additionally, the default namespace only applies when using Unity
// Catalog-enabled compute.
type DefaultNamespaceAPI struct {
	defaultNamespaceImpl
}

// 'Disabling legacy access' has the following impacts:
//
// 1. Disables direct access to the Hive Metastore. However, you can still
// access Hive Metastore through HMS Federation. 2. Disables Fallback Mode (docs
// link) on any External Location access from the workspace. 3. Alters DBFS path
// access to use External Location permissions in place of legacy credentials.
// 4. Enforces Unity Catalog access on all path based access.
type DisableLegacyAccessAPI struct {
	disableLegacyAccessImpl
}

// When this setting is on, access to DBFS root and DBFS mounts is disallowed
// (as well as creation of new mounts). When the setting is off, all DBFS
// functionality is enabled
type DisableLegacyDbfsAPI struct {
	disableLegacyDbfsImpl
}

// Disable legacy features for new Databricks workspaces.
//
// For newly created workspaces: 1. Disables the use of DBFS root and mounts. 2.
// Hive Metastore will not be provisioned. 3. Disables the use of
// ‘No-isolation clusters’. 4. Disables Databricks Runtime versions prior to
// 13.3LTS.
type DisableLegacyFeaturesAPI struct {
	disableLegacyFeaturesImpl
}

// Controls the enforcement of IP access lists for accessing the account
// console. Allowing you to enable or disable restricted access based on IP
// addresses.
type EnableIpAccessListsAPI struct {
	enableIpAccessListsImpl
}

// Controls whether enhanced security monitoring is enabled for the current
// workspace. If the compliance security profile is enabled, this is
// automatically enabled. By default, it is disabled. However, if the compliance
// security profile is enabled, this is automatically enabled.
//
// If the compliance security profile is disabled, you can enable or disable
// this setting and it is not permanent.
type EnhancedSecurityMonitoringAPI struct {
	enhancedSecurityMonitoringImpl
}

// The enhanced security monitoring setting at the account level controls
// whether to enable the feature on new workspaces. By default, this
// account-level setting is disabled for new workspaces. After workspace
// creation, account admins can enable enhanced security monitoring individually
// for each workspace.
type EsmEnablementAccountAPI struct {
	esmEnablementAccountImpl
}

// IP Access List enables admins to configure IP access lists.
//
// IP access lists affect web application access and REST API access to this
// workspace only. If the feature is disabled for a workspace, all access is
// allowed for this workspace. There is support for allow lists (inclusion) and
// block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the workspace, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the workspace, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the workspace supports a
// maximum of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the IP access list feature, it can take a few minutes for
// changes to take effect.
type IpAccessListsAPI struct {
	ipAccessListsImpl
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) (*DeleteResponse, error) {
	return a.ipAccessListsImpl.Delete(ctx, DeleteIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access list.
//
// Gets an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error) {
	return a.ipAccessListsImpl.Get(ctx, GetIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// These APIs provide configurations for the network connectivity of your
// workspaces for serverless compute resources.
type NetworkConnectivityAPI struct {
	networkConnectivityImpl
}

// Delete a network connectivity configuration.
//
// Deletes a network connectivity configuration.
func (a *NetworkConnectivityAPI) DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*DeleteNetworkConnectivityConfigurationResponse, error) {
	return a.networkConnectivityImpl.DeleteNetworkConnectivityConfiguration(ctx, DeleteNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Delete a private endpoint rule.
//
// Initiates deleting a private endpoint rule. If the connection state is
// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
// the private endpoint is deactivated and will be deleted after seven days of
// deactivation. When a private endpoint is deactivated, the `deactivated` field
// is set to `true` and the private endpoint is not available to your serverless
// compute resources.
func (a *NetworkConnectivityAPI) DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.networkConnectivityImpl.DeletePrivateEndpointRule(ctx, DeletePrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// Get a network connectivity configuration.
//
// Gets a network connectivity configuration.
func (a *NetworkConnectivityAPI) GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error) {
	return a.networkConnectivityImpl.GetNetworkConnectivityConfiguration(ctx, GetNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Get a private endpoint rule.
//
// Gets the private endpoint rule.
func (a *NetworkConnectivityAPI) GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.networkConnectivityImpl.GetPrivateEndpointRule(ctx, GetPrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error) {
	return a.networkConnectivityImpl.internalListPrivateEndpointRules(ctx, ListPrivateEndpointRulesRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// The notification destinations API lets you programmatically manage a
// workspace's notification destinations. Notification destinations are used to
// send notifications for query alerts and jobs to destinations outside of
// Databricks. Only workspace admins can create, update, and delete notification
// destinations.
type NotificationDestinationsAPI struct {
	notificationDestinationsImpl
}

// Delete a notification destination.
//
// Deletes a notification destination. Requires workspace admin permissions.
func (a *NotificationDestinationsAPI) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.notificationDestinationsImpl.Delete(ctx, DeleteNotificationDestinationRequest{
		Id: id,
	})
}

// Get a notification destination.
//
// Gets a notification destination.
func (a *NotificationDestinationsAPI) GetById(ctx context.Context, id string) (*NotificationDestination, error) {
	return a.notificationDestinationsImpl.Get(ctx, GetNotificationDestinationRequest{
		Id: id,
	})
}

// The Personal Compute enablement setting lets you control which users can use
// the Personal Compute default policy to create compute resources. By default
// all users in all workspaces have access (ON), but you can change the setting
// to instead let individual workspaces configure access control (DELEGATE).
//
// There is only one instance of this setting per account. Since this setting
// has a default value, this setting is present on all accounts even though it's
// never set on a given account. Deletion reverts the value of the setting back
// to the default value.
type PersonalComputeAPI struct {
	personalComputeImpl
}

// The Restrict Workspace Admins setting lets you control the capabilities of
// workspace admins. With the setting status set to ALLOW_ALL, workspace admins
// can create service principal personal access tokens on behalf of any service
// principal in their workspace. Workspace admins can also change a job owner to
// any user in their workspace. And they can change the job run_as setting to
// any user in their workspace or to a service principal on which they have the
// Service Principal User role. With the setting status set to
// RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins can only create personal
// access tokens on behalf of service principals they have the Service Principal
// User role on. They can also only change a job owner to themselves. And they
// can change the job run_as setting to themselves or to a service principal on
// which they have the Service Principal User role.
type RestrictWorkspaceAdminsAPI struct {
	restrictWorkspaceAdminsImpl
}

// Workspace Settings API allows users to manage settings at the workspace
// level.
type SettingsAPI struct {
	settingsImpl
}

// Enables administrators to get all tokens and delete tokens for other users.
// Admins can either get every token, get a specific token by ID, or get all
// tokens for a particular user.
type TokenManagementAPI struct {
	tokenManagementImpl
}

// Delete a token.
//
// Deletes a token, specified by its ID.
func (a *TokenManagementAPI) DeleteByTokenId(ctx context.Context, tokenId string) (*DeleteResponse, error) {
	return a.tokenManagementImpl.Delete(ctx, DeleteTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Get token info.
//
// Gets information about a token, specified by its ID.
func (a *TokenManagementAPI) GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error) {
	return a.tokenManagementImpl.Get(ctx, GetTokenManagementRequest{
		TokenId: tokenId,
	})
}

// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) GetByComment(ctx context.Context, name string) (*TokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTokenManagementRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// The Token API allows you to create, list, and revoke tokens that can be used
// to authenticate and access Databricks REST APIs.
type TokensAPI struct {
	tokensImpl
}

// Revoke token.
//
// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *TokensAPI) DeleteByTokenId(ctx context.Context, tokenId string) (*RevokeTokenResponse, error) {
	return a.tokensImpl.Delete(ctx, RevokeTokenRequest{
		TokenId: tokenId,
	})
}

// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PublicTokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PublicTokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PublicTokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// This API allows updating known workspace settings for advanced users.
type WorkspaceConfAPI struct {
	workspaceConfImpl
}
