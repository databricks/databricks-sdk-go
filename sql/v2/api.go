// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Alerts, Alerts Legacy, Dashboard Widgets, Dashboards, Data Sources, Dbsql Permissions, Queries, Queries Legacy, Query History, Query Visualizations, Query Visualizations Legacy, Redash Config, Statement Execution, Warehouses, etc.
package sql

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/databricks/useragent"
)

// The alerts API can be used to perform CRUD operations on alerts. An alert is
// a Databricks SQL object that periodically runs a query, evaluates a condition
// of its result, and notifies one or more users and/or notification
// destinations if the condition was met. Alerts can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type AlertsAPI struct {
	alertsImpl
}

// Delete an alert.
//
// Moves an alert to the trash. Trashed alerts immediately disappear from
// searches and list views, and can no longer trigger. You can restore a trashed
// alert through the UI. A trashed alert is permanently deleted after 30 days.
func (a *AlertsAPI) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.alertsImpl.Delete(ctx, TrashAlertRequest{
		Id: id,
	})
}

// Get an alert.
//
// Gets an alert.
func (a *AlertsAPI) GetById(ctx context.Context, id string) (*Alert, error) {
	return a.alertsImpl.Get(ctx, GetAlertRequest{
		Id: id,
	})
}

// ListAlertsResponseAlertDisplayNameToIdMap calls [AlertsAPI.ListAll] and creates a map of results with [ListAlertsResponseAlert].DisplayName as key and [ListAlertsResponseAlert].Id as value.
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) ListAlertsResponseAlertDisplayNameToIdMap(ctx context.Context, request ListAlertsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [AlertsAPI.ListAlertsResponseAlertDisplayNameToIdMap] and returns a single [ListAlertsResponseAlert].
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) GetByDisplayName(ctx context.Context, name string) (*ListAlertsResponseAlert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListAlertsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListAlertsResponseAlert{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListAlertsResponseAlert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListAlertsResponseAlert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// The alerts API can be used to perform CRUD operations on alerts. An alert is
// a Databricks SQL object that periodically runs a query, evaluates a condition
// of its result, and notifies one or more users and/or notification
// destinations if the condition was met. Alerts can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type AlertsLegacyAPI struct {
	alertsLegacyImpl
}

// Delete an alert.
//
// Deletes an alert. Deleted alerts are no longer accessible and cannot be
// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
// the trash.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *AlertsLegacyAPI) DeleteByAlertId(ctx context.Context, alertId string) (*DeleteResponse, error) {
	return a.alertsLegacyImpl.Delete(ctx, DeleteAlertsLegacyRequest{
		AlertId: alertId,
	})
}

// Get an alert.
//
// Gets an alert.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *AlertsLegacyAPI) GetByAlertId(ctx context.Context, alertId string) (*LegacyAlert, error) {
	return a.alertsLegacyImpl.Get(ctx, GetAlertsLegacyRequest{
		AlertId: alertId,
	})
}

// LegacyAlertNameToIdMap calls [AlertsLegacyAPI.List] and creates a map of results with [LegacyAlert].Name as key and [LegacyAlert].Id as value.
//
// Returns an error if there's more than one [LegacyAlert] with the same .Name.
//
// Note: All [LegacyAlert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsLegacyAPI) LegacyAlertNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [AlertsLegacyAPI.LegacyAlertNameToIdMap] and returns a single [LegacyAlert].
//
// Returns an error if there's more than one [LegacyAlert] with the same .Name.
//
// Note: All [LegacyAlert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsLegacyAPI) GetByName(ctx context.Context, name string) (*LegacyAlert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]LegacyAlert{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("LegacyAlert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of LegacyAlert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// This is an evolving API that facilitates the addition and removal of widgets
// from existing dashboards within the Databricks Workspace. Data structures may
// change over time.
type DashboardWidgetsAPI struct {
	dashboardWidgetsImpl
}

// Remove widget.
func (a *DashboardWidgetsAPI) DeleteById(ctx context.Context, id string) (*DeleteResponse, error) {
	return a.dashboardWidgetsImpl.Delete(ctx, DeleteDashboardWidgetRequest{
		Id: id,
	})
}

// In general, there is little need to modify dashboards using the API. However,
// it can be useful to use dashboard objects to look-up a collection of related
// query IDs. The API can also be used to duplicate multiple dashboards at once
// since you can get a dashboard definition with a GET request and then POST it
// to create a new one. Dashboards can be scheduled using the `sql_task` type of
// the Jobs API, e.g. :method:jobs/create.
type DashboardsAPI struct {
	dashboardsImpl
}

// Remove a dashboard.
//
// Moves a dashboard to the trash. Trashed dashboards do not appear in list
// views or searches, and cannot be shared.
func (a *DashboardsAPI) DeleteByDashboardId(ctx context.Context, dashboardId string) (*DeleteResponse, error) {
	return a.dashboardsImpl.Delete(ctx, DeleteDashboardRequest{
		DashboardId: dashboardId,
	})
}

// Retrieve a definition.
//
// Returns a JSON representation of a dashboard object, including its
// visualization and query objects.
func (a *DashboardsAPI) GetByDashboardId(ctx context.Context, dashboardId string) (*Dashboard, error) {
	return a.dashboardsImpl.Get(ctx, GetDashboardRequest{
		DashboardId: dashboardId,
	})
}

// DashboardNameToIdMap calls [DashboardsAPI.ListAll] and creates a map of results with [Dashboard].Name as key and [Dashboard].Id as value.
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DashboardsAPI) DashboardNameToIdMap(ctx context.Context, request ListDashboardsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [DashboardsAPI.DashboardNameToIdMap] and returns a single [Dashboard].
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DashboardsAPI) GetByName(ctx context.Context, name string) (*Dashboard, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListDashboardsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Dashboard{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Dashboard named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Dashboard named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// This API is provided to assist you in making new query objects. When creating
// a query object, you may optionally specify a `data_source_id` for the SQL
// warehouse against which it will run. If you don't already know the
// `data_source_id` for your desired SQL warehouse, this API will help you find
// it.
//
// This API does not support searches. It returns the full list of SQL
// warehouses in your workspace. We advise you to use any text editor, REST
// client, or `grep` to search the response from this API for the name of your
// SQL warehouse as it appears in Databricks SQL.
//
// **Note**: A new version of the Databricks SQL API is now available. [Learn
// more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type DataSourcesAPI struct {
	dataSourcesImpl
}

// DataSourceNameToIdMap calls [DataSourcesAPI.List] and creates a map of results with [DataSource].Name as key and [DataSource].Id as value.
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DataSourcesAPI) DataSourceNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [DataSourcesAPI.DataSourceNameToIdMap] and returns a single [DataSource].
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DataSourcesAPI) GetByName(ctx context.Context, name string) (*DataSource, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]DataSource{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("DataSource named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of DataSource named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// The SQL Permissions API is similar to the endpoints of the
// :method:permissions/set. However, this exposes only one endpoint, which gets
// the Access Control List for a given object. You cannot modify any permissions
// using this API.
//
// There are three levels of permission:
//
// - `CAN_VIEW`: Allows read-only access
//
// - `CAN_RUN`: Allows read access and run access (superset of `CAN_VIEW`)
//
// - `CAN_MANAGE`: Allows all actions: read, run, edit, delete, modify
// permissions (superset of `CAN_RUN`)
//
// **Note**: A new version of the Databricks SQL API is now available. [Learn
// more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type DbsqlPermissionsAPI struct {
	dbsqlPermissionsImpl
}

// Get object ACL.
//
// Gets a JSON representation of the access control list (ACL) for a specified
// object.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:workspace/getpermissions instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *DbsqlPermissionsAPI) GetByObjectTypeAndObjectId(ctx context.Context, objectType ObjectTypePlural, objectId string) (*GetResponse, error) {
	return a.dbsqlPermissionsImpl.Get(ctx, GetDbsqlPermissionRequest{
		ObjectType: objectType,
		ObjectId:   objectId,
	})
}

// The queries API can be used to perform CRUD operations on queries. A query is
// a Databricks SQL object that includes the target SQL warehouse, query text,
// name, description, tags, and parameters. Queries can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type QueriesAPI struct {
	queriesImpl
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and cannot be used for alerts. You can restore a
// trashed query through the UI. A trashed query is permanently deleted after 30
// days.
func (a *QueriesAPI) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.queriesImpl.Delete(ctx, TrashQueryRequest{
		Id: id,
	})
}

// Get a query.
//
// Gets a query.
func (a *QueriesAPI) GetById(ctx context.Context, id string) (*Query, error) {
	return a.queriesImpl.Get(ctx, GetQueryRequest{
		Id: id,
	})
}

// ListQueryObjectsResponseQueryDisplayNameToIdMap calls [QueriesAPI.ListAll] and creates a map of results with [ListQueryObjectsResponseQuery].DisplayName as key and [ListQueryObjectsResponseQuery].Id as value.
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) ListQueryObjectsResponseQueryDisplayNameToIdMap(ctx context.Context, request ListQueriesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [QueriesAPI.ListQueryObjectsResponseQueryDisplayNameToIdMap] and returns a single [ListQueryObjectsResponseQuery].
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) GetByDisplayName(ctx context.Context, name string) (*ListQueryObjectsResponseQuery, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListQueryObjectsResponseQuery{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListQueryObjectsResponseQuery named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListQueryObjectsResponseQuery named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// List visualizations on a query.
//
// Gets a list of visualizations on a query.
func (a *QueriesAPI) ListVisualizationsById(ctx context.Context, id string) (*ListVisualizationsForQueryResponse, error) {
	return a.queriesImpl.internalListVisualizations(ctx, ListVisualizationsForQueryRequest{
		Id: id,
	})
}

// These endpoints are used for CRUD operations on query definitions. Query
// definitions include the target SQL warehouse, query text, name, description,
// tags, parameters, and visualizations. Queries can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type QueriesLegacyAPI struct {
	queriesLegacyImpl
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and they cannot be used for alerts. The trash is
// deleted after 30 days.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueriesLegacyAPI) DeleteByQueryId(ctx context.Context, queryId string) (*DeleteResponse, error) {
	return a.queriesLegacyImpl.Delete(ctx, DeleteQueriesLegacyRequest{
		QueryId: queryId,
	})
}

// Get a query definition.
//
// Retrieve a query object definition along with contextual permissions
// information about the currently authenticated user.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueriesLegacyAPI) GetByQueryId(ctx context.Context, queryId string) (*LegacyQuery, error) {
	return a.queriesLegacyImpl.Get(ctx, GetQueriesLegacyRequest{
		QueryId: queryId,
	})
}

// LegacyQueryNameToIdMap calls [QueriesLegacyAPI.ListAll] and creates a map of results with [LegacyQuery].Name as key and [LegacyQuery].Id as value.
//
// Returns an error if there's more than one [LegacyQuery] with the same .Name.
//
// Note: All [LegacyQuery] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesLegacyAPI) LegacyQueryNameToIdMap(ctx context.Context, request ListQueriesLegacyRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [QueriesLegacyAPI.LegacyQueryNameToIdMap] and returns a single [LegacyQuery].
//
// Returns an error if there's more than one [LegacyQuery] with the same .Name.
//
// Note: All [LegacyQuery] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesLegacyAPI) GetByName(ctx context.Context, name string) (*LegacyQuery, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesLegacyRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]LegacyQuery{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("LegacyQuery named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of LegacyQuery named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// A service responsible for storing and retrieving the list of queries run
// against SQL endpoints and serverless compute.
type QueryHistoryAPI struct {
	queryHistoryImpl
}

// This is an evolving API that facilitates the addition and removal of
// visualizations from existing queries in the Databricks Workspace. Data
// structures can change over time.
type QueryVisualizationsAPI struct {
	queryVisualizationsImpl
}

// Remove a visualization.
//
// Removes a visualization.
func (a *QueryVisualizationsAPI) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.queryVisualizationsImpl.Delete(ctx, DeleteVisualizationRequest{
		Id: id,
	})
}

// This is an evolving API that facilitates the addition and removal of
// vizualisations from existing queries within the Databricks Workspace. Data
// structures may change over time.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type QueryVisualizationsLegacyAPI struct {
	queryVisualizationsLegacyImpl
}

// Remove visualization.
//
// Removes a visualization from the query.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queryvisualizations/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueryVisualizationsLegacyAPI) DeleteById(ctx context.Context, id string) (*DeleteResponse, error) {
	return a.queryVisualizationsLegacyImpl.Delete(ctx, DeleteQueryVisualizationsLegacyRequest{
		Id: id,
	})
}

// Redash V2 service for workspace configurations (internal)
type RedashConfigAPI struct {
	redashConfigImpl
}

// The Databricks SQL Statement Execution API can be used to execute SQL
// statements on a SQL warehouse and fetch the result.
//
// **Getting started**
//
// We suggest beginning with the [Databricks SQL Statement Execution API
// tutorial].
//
// **Overview of statement execution and result fetching**
//
// Statement execution begins by issuing a
// :method:statementexecution/executeStatement request with a valid SQL
// statement and warehouse ID, along with optional parameters such as the data
// catalog and output format. If no other parameters are specified, the server
// will wait for up to 10s before returning a response. If the statement has
// completed within this timespan, the response will include the result data as
// a JSON array and metadata. Otherwise, if no result is available after the 10s
// timeout expired, the response will provide the statement ID that can be used
// to poll for results by using a :method:statementexecution/getStatement
// request.
//
// You can specify whether the call should behave synchronously, asynchronously
// or start synchronously with a fallback to asynchronous execution. This is
// controlled with the `wait_timeout` and `on_wait_timeout` settings. If
// `wait_timeout` is set between 5-50 seconds (default: 10s), the call waits for
// results up to the specified timeout; when set to `0s`, the call is
// asynchronous and responds immediately with a statement ID. The
// `on_wait_timeout` setting specifies what should happen when the timeout is
// reached while the statement execution has not yet finished. This can be set
// to either `CONTINUE`, to fallback to asynchronous mode, or it can be set to
// `CANCEL`, which cancels the statement.
//
// In summary: - Synchronous mode - `wait_timeout=30s` and
// `on_wait_timeout=CANCEL` - The call waits up to 30 seconds; if the statement
// execution finishes within this time, the result data is returned directly in
// the response. If the execution takes longer than 30 seconds, the execution is
// canceled and the call returns with a `CANCELED` state. - Asynchronous mode -
// `wait_timeout=0s` (`on_wait_timeout` is ignored) - The call doesn't wait for
// the statement to finish but returns directly with a statement ID. The status
// of the statement execution can be polled by issuing
// :method:statementexecution/getStatement with the statement ID. Once the
// execution has succeeded, this call also returns the result and metadata in
// the response. - Hybrid mode (default) - `wait_timeout=10s` and
// `on_wait_timeout=CONTINUE` - The call waits for up to 10 seconds; if the
// statement execution finishes within this time, the result data is returned
// directly in the response. If the execution takes longer than 10 seconds, a
// statement ID is returned. The statement ID can be used to fetch status and
// results in the same way as in the asynchronous mode.
//
// Depending on the size, the result can be split into multiple chunks. If the
// statement execution is successful, the statement response contains a manifest
// and the first chunk of the result. The manifest contains schema information
// and provides metadata for each chunk in the result. Result chunks can be
// retrieved by index with :method:statementexecution/getStatementResultChunkN
// which may be called in any order and in parallel. For sequential fetching,
// each chunk, apart from the last, also contains a `next_chunk_index` and
// `next_chunk_internal_link` that point to the next chunk.
//
// A statement can be canceled with :method:statementexecution/cancelExecution.
//
// **Fetching result data: format and disposition**
//
// To specify the format of the result data, use the `format` field, which can
// be set to one of the following options: `JSON_ARRAY` (JSON), `ARROW_STREAM`
// ([Apache Arrow Columnar]), or `CSV`.
//
// There are two ways to receive statement results, controlled by the
// `disposition` setting, which can be either `INLINE` or `EXTERNAL_LINKS`:
//
// - `INLINE`: In this mode, the result data is directly included in the
// response. It's best suited for smaller results. This mode can only be used
// with the `JSON_ARRAY` format.
//
// - `EXTERNAL_LINKS`: In this mode, the response provides links that can be
// used to download the result data in chunks separately. This approach is ideal
// for larger results and offers higher throughput. This mode can be used with
// all the formats: `JSON_ARRAY`, `ARROW_STREAM`, and `CSV`.
//
// By default, the API uses `format=JSON_ARRAY` and `disposition=INLINE`.
//
// **Limits and limitations**
//
// Note: The byte limit for INLINE disposition is based on internal storage
// metrics and will not exactly match the byte count of the actual payload.
//
// - Statements with `disposition=INLINE` are limited to 25 MiB and will fail
// when this limit is exceeded. - Statements with `disposition=EXTERNAL_LINKS`
// are limited to 100 GiB. Result sets larger than this limit will be truncated.
// Truncation is indicated by the `truncated` field in the result manifest. -
// The maximum query text size is 16 MiB. - Cancelation might silently fail. A
// successful response from a cancel request indicates that the cancel request
// was successfully received and sent to the processing engine. However, an
// outstanding statement might have already completed execution when the cancel
// request arrives. Polling for status until a terminal state is reached is a
// reliable way to determine the final state. - Wait timeouts are approximate,
// occur server-side, and cannot account for things such as caller delays and
// network latency from caller to service. - To guarantee that the statement is
// kept alive, you must poll at least once every 15 minutes. - The results are
// only available for one hour after success; polling does not extend this. -
// The SQL Execution API must be used for the entire lifecycle of the statement.
// For example, you cannot use the Jobs API to execute the command, and then the
// SQL Execution API to cancel it.
//
// [Apache Arrow Columnar]: https://arrow.apache.org/overview/
// [Databricks SQL Statement Execution API tutorial]: https://docs.databricks.com/sql/api/sql-execution-tutorial.html
type StatementExecutionAPI struct {
	statementExecutionImpl
}

// Get status, manifest, and result first chunk.
//
// This request can be used to poll for the statement's status. When the
// `status.state` field is `SUCCEEDED` it will also return the result manifest
// and the first chunk of the result data. When the statement is in the terminal
// states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200 with the state
// set. After at least 12 hours in terminal state, the statement is removed from
// the warehouse and further calls will receive an HTTP 404 response.
//
// **NOTE** This call currently might take up to 5 seconds to get the latest
// status and result.
func (a *StatementExecutionAPI) GetStatementByStatementId(ctx context.Context, statementId string) (*StatementResponse, error) {
	return a.statementExecutionImpl.GetStatement(ctx, GetStatementRequest{
		StatementId: statementId,
	})
}

// Get result chunk by index.
//
// After the statement execution has `SUCCEEDED`, this request can be used to
// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
// typically fetched with :method:statementexecution/executeStatement or
// :method:statementexecution/getStatement, this request can be used to fetch
// subsequent chunks. The response structure is identical to the nested `result`
// element described in the :method:statementexecution/getStatement request, and
// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
// fields for simple iteration through the result set.
func (a *StatementExecutionAPI) GetStatementResultChunkNByStatementIdAndChunkIndex(ctx context.Context, statementId string, chunkIndex int) (*ResultData, error) {
	return a.statementExecutionImpl.GetStatementResultChunkN(ctx, GetStatementResultChunkNRequest{
		StatementId: statementId,
		ChunkIndex:  chunkIndex,
	})
}

// A SQL warehouse is a compute resource that lets you run SQL commands on data
// objects within Databricks SQL. Compute resources are infrastructure resources
// that provide processing capabilities in the cloud.
type WarehousesAPI struct {
	warehousesImpl
}

// Delete a warehouse.
//
// Deletes a SQL warehouse.
func (a *WarehousesAPI) DeleteById(ctx context.Context, id string) (*DeleteWarehouseResponse, error) {
	return a.warehousesImpl.Delete(ctx, DeleteWarehouseRequest{
		Id: id,
	})
}

// Get warehouse info.
//
// Gets the information for a single SQL warehouse.
func (a *WarehousesAPI) GetById(ctx context.Context, id string) (*GetWarehouseResponse, error) {
	return a.warehousesImpl.Get(ctx, GetWarehouseRequest{
		Id: id,
	})
}

// Get SQL warehouse permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *WarehousesAPI) GetPermissionLevelsByWarehouseId(ctx context.Context, warehouseId string) (*GetWarehousePermissionLevelsResponse, error) {
	return a.warehousesImpl.GetPermissionLevels(ctx, GetWarehousePermissionLevelsRequest{
		WarehouseId: warehouseId,
	})
}

// Get SQL warehouse permissions.
//
// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
// permissions from their root object.
func (a *WarehousesAPI) GetPermissionsByWarehouseId(ctx context.Context, warehouseId string) (*WarehousePermissions, error) {
	return a.warehousesImpl.GetPermissions(ctx, GetWarehousePermissionsRequest{
		WarehouseId: warehouseId,
	})
}

// EndpointInfoNameToIdMap calls [WarehousesAPI.ListAll] and creates a map of results with [EndpointInfo].Name as key and [EndpointInfo].Id as value.
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) EndpointInfoNameToIdMap(ctx context.Context, request ListWarehousesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [WarehousesAPI.EndpointInfoNameToIdMap] and returns a single [EndpointInfo].
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) GetByName(ctx context.Context, name string) (*EndpointInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListWarehousesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]EndpointInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("EndpointInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of EndpointInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}
