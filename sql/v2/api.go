// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Alerts, Alerts Legacy, Dashboard Widgets, Dashboards, Data Sources, Dbsql Permissions, Queries, Queries Legacy, Query History, Query Visualizations, Query Visualizations Legacy, Redash Config, Statement Execution, Warehouses, etc.
package sql

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/databricks/useragent"
)

type alertsBaseClient struct {
	alertsImpl
}

// Delete an alert.
//
// Moves an alert to the trash. Trashed alerts immediately disappear from
// searches and list views, and can no longer trigger. You can restore a trashed
// alert through the UI. A trashed alert is permanently deleted after 30 days.
func (a *alertsBaseClient) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.alertsImpl.Delete(ctx, TrashAlertRequest{
		Id: id,
	})
}

// Get an alert.
//
// Gets an alert.
func (a *alertsBaseClient) GetById(ctx context.Context, id string) (*Alert, error) {
	return a.alertsImpl.Get(ctx, GetAlertRequest{
		Id: id,
	})
}

// ListAlertsResponseAlertDisplayNameToIdMap calls [alertsBaseClient.ListAll] and creates a map of results with [ListAlertsResponseAlert].DisplayName as key and [ListAlertsResponseAlert].Id as value.
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *alertsBaseClient) ListAlertsResponseAlertDisplayNameToIdMap(ctx context.Context, request ListAlertsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [alertsBaseClient.ListAlertsResponseAlertDisplayNameToIdMap] and returns a single [ListAlertsResponseAlert].
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *alertsBaseClient) GetByDisplayName(ctx context.Context, name string) (*ListAlertsResponseAlert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListAlertsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListAlertsResponseAlert{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListAlertsResponseAlert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListAlertsResponseAlert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type alertsLegacyBaseClient struct {
	alertsLegacyImpl
}

// Delete an alert.
//
// Deletes an alert. Deleted alerts are no longer accessible and cannot be
// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
// the trash.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *alertsLegacyBaseClient) DeleteByAlertId(ctx context.Context, alertId string) (*DeleteResponse, error) {
	return a.alertsLegacyImpl.Delete(ctx, DeleteAlertsLegacyRequest{
		AlertId: alertId,
	})
}

// Get an alert.
//
// Gets an alert.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *alertsLegacyBaseClient) GetByAlertId(ctx context.Context, alertId string) (*LegacyAlert, error) {
	return a.alertsLegacyImpl.Get(ctx, GetAlertsLegacyRequest{
		AlertId: alertId,
	})
}

// LegacyAlertNameToIdMap calls [alertsLegacyBaseClient.List] and creates a map of results with [LegacyAlert].Name as key and [LegacyAlert].Id as value.
//
// Returns an error if there's more than one [LegacyAlert] with the same .Name.
//
// Note: All [LegacyAlert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *alertsLegacyBaseClient) LegacyAlertNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [alertsLegacyBaseClient.LegacyAlertNameToIdMap] and returns a single [LegacyAlert].
//
// Returns an error if there's more than one [LegacyAlert] with the same .Name.
//
// Note: All [LegacyAlert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *alertsLegacyBaseClient) GetByName(ctx context.Context, name string) (*LegacyAlert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]LegacyAlert{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("LegacyAlert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of LegacyAlert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type dashboardWidgetsBaseClient struct {
	dashboardWidgetsImpl
}

// Remove widget.
func (a *dashboardWidgetsBaseClient) DeleteById(ctx context.Context, id string) (*DeleteResponse, error) {
	return a.dashboardWidgetsImpl.Delete(ctx, DeleteDashboardWidgetRequest{
		Id: id,
	})
}

type dashboardsBaseClient struct {
	dashboardsImpl
}

// Remove a dashboard.
//
// Moves a dashboard to the trash. Trashed dashboards do not appear in list
// views or searches, and cannot be shared.
func (a *dashboardsBaseClient) DeleteByDashboardId(ctx context.Context, dashboardId string) (*DeleteResponse, error) {
	return a.dashboardsImpl.Delete(ctx, DeleteDashboardRequest{
		DashboardId: dashboardId,
	})
}

// Retrieve a definition.
//
// Returns a JSON representation of a dashboard object, including its
// visualization and query objects.
func (a *dashboardsBaseClient) GetByDashboardId(ctx context.Context, dashboardId string) (*Dashboard, error) {
	return a.dashboardsImpl.Get(ctx, GetDashboardRequest{
		DashboardId: dashboardId,
	})
}

// DashboardNameToIdMap calls [dashboardsBaseClient.ListAll] and creates a map of results with [Dashboard].Name as key and [Dashboard].Id as value.
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *dashboardsBaseClient) DashboardNameToIdMap(ctx context.Context, request ListDashboardsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [dashboardsBaseClient.DashboardNameToIdMap] and returns a single [Dashboard].
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *dashboardsBaseClient) GetByName(ctx context.Context, name string) (*Dashboard, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListDashboardsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Dashboard{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Dashboard named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Dashboard named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type dataSourcesBaseClient struct {
	dataSourcesImpl
}

// DataSourceNameToIdMap calls [dataSourcesBaseClient.List] and creates a map of results with [DataSource].Name as key and [DataSource].Id as value.
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *dataSourcesBaseClient) DataSourceNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [dataSourcesBaseClient.DataSourceNameToIdMap] and returns a single [DataSource].
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *dataSourcesBaseClient) GetByName(ctx context.Context, name string) (*DataSource, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]DataSource{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("DataSource named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of DataSource named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type dbsqlPermissionsBaseClient struct {
	dbsqlPermissionsImpl
}

// Get object ACL.
//
// Gets a JSON representation of the access control list (ACL) for a specified
// object.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:workspace/getpermissions instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *dbsqlPermissionsBaseClient) GetByObjectTypeAndObjectId(ctx context.Context, objectType ObjectTypePlural, objectId string) (*GetResponse, error) {
	return a.dbsqlPermissionsImpl.Get(ctx, GetDbsqlPermissionRequest{
		ObjectType: objectType,
		ObjectId:   objectId,
	})
}

type queriesBaseClient struct {
	queriesImpl
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and cannot be used for alerts. You can restore a
// trashed query through the UI. A trashed query is permanently deleted after 30
// days.
func (a *queriesBaseClient) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.queriesImpl.Delete(ctx, TrashQueryRequest{
		Id: id,
	})
}

// Get a query.
//
// Gets a query.
func (a *queriesBaseClient) GetById(ctx context.Context, id string) (*Query, error) {
	return a.queriesImpl.Get(ctx, GetQueryRequest{
		Id: id,
	})
}

// ListQueryObjectsResponseQueryDisplayNameToIdMap calls [queriesBaseClient.ListAll] and creates a map of results with [ListQueryObjectsResponseQuery].DisplayName as key and [ListQueryObjectsResponseQuery].Id as value.
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *queriesBaseClient) ListQueryObjectsResponseQueryDisplayNameToIdMap(ctx context.Context, request ListQueriesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [queriesBaseClient.ListQueryObjectsResponseQueryDisplayNameToIdMap] and returns a single [ListQueryObjectsResponseQuery].
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *queriesBaseClient) GetByDisplayName(ctx context.Context, name string) (*ListQueryObjectsResponseQuery, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListQueryObjectsResponseQuery{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListQueryObjectsResponseQuery named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListQueryObjectsResponseQuery named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// List visualizations on a query.
//
// Gets a list of visualizations on a query.
func (a *queriesBaseClient) ListVisualizationsById(ctx context.Context, id string) (*ListVisualizationsForQueryResponse, error) {
	return a.queriesImpl.internalListVisualizations(ctx, ListVisualizationsForQueryRequest{
		Id: id,
	})
}

type queriesLegacyBaseClient struct {
	queriesLegacyImpl
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and they cannot be used for alerts. The trash is
// deleted after 30 days.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *queriesLegacyBaseClient) DeleteByQueryId(ctx context.Context, queryId string) (*DeleteResponse, error) {
	return a.queriesLegacyImpl.Delete(ctx, DeleteQueriesLegacyRequest{
		QueryId: queryId,
	})
}

// Get a query definition.
//
// Retrieve a query object definition along with contextual permissions
// information about the currently authenticated user.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *queriesLegacyBaseClient) GetByQueryId(ctx context.Context, queryId string) (*LegacyQuery, error) {
	return a.queriesLegacyImpl.Get(ctx, GetQueriesLegacyRequest{
		QueryId: queryId,
	})
}

// LegacyQueryNameToIdMap calls [queriesLegacyBaseClient.ListAll] and creates a map of results with [LegacyQuery].Name as key and [LegacyQuery].Id as value.
//
// Returns an error if there's more than one [LegacyQuery] with the same .Name.
//
// Note: All [LegacyQuery] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *queriesLegacyBaseClient) LegacyQueryNameToIdMap(ctx context.Context, request ListQueriesLegacyRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [queriesLegacyBaseClient.LegacyQueryNameToIdMap] and returns a single [LegacyQuery].
//
// Returns an error if there's more than one [LegacyQuery] with the same .Name.
//
// Note: All [LegacyQuery] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *queriesLegacyBaseClient) GetByName(ctx context.Context, name string) (*LegacyQuery, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesLegacyRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]LegacyQuery{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("LegacyQuery named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of LegacyQuery named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type queryHistoryBaseClient struct {
	queryHistoryImpl
}

type queryVisualizationsBaseClient struct {
	queryVisualizationsImpl
}

// Remove a visualization.
//
// Removes a visualization.
func (a *queryVisualizationsBaseClient) DeleteById(ctx context.Context, id string) (*Empty, error) {
	return a.queryVisualizationsImpl.Delete(ctx, DeleteVisualizationRequest{
		Id: id,
	})
}

type queryVisualizationsLegacyBaseClient struct {
	queryVisualizationsLegacyImpl
}

// Remove visualization.
//
// Removes a visualization from the query.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queryvisualizations/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *queryVisualizationsLegacyBaseClient) DeleteById(ctx context.Context, id string) (*DeleteResponse, error) {
	return a.queryVisualizationsLegacyImpl.Delete(ctx, DeleteQueryVisualizationsLegacyRequest{
		Id: id,
	})
}

type redashConfigBaseClient struct {
	redashConfigImpl
}

type statementExecutionBaseClient struct {
	statementExecutionImpl
}

// Get status, manifest, and result first chunk.
//
// This request can be used to poll for the statement's status. When the
// `status.state` field is `SUCCEEDED` it will also return the result manifest
// and the first chunk of the result data. When the statement is in the terminal
// states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200 with the state
// set. After at least 12 hours in terminal state, the statement is removed from
// the warehouse and further calls will receive an HTTP 404 response.
//
// **NOTE** This call currently might take up to 5 seconds to get the latest
// status and result.
func (a *statementExecutionBaseClient) GetStatementByStatementId(ctx context.Context, statementId string) (*StatementResponse, error) {
	return a.statementExecutionImpl.GetStatement(ctx, GetStatementRequest{
		StatementId: statementId,
	})
}

// Get result chunk by index.
//
// After the statement execution has `SUCCEEDED`, this request can be used to
// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
// typically fetched with :method:statementexecution/executeStatement or
// :method:statementexecution/getStatement, this request can be used to fetch
// subsequent chunks. The response structure is identical to the nested `result`
// element described in the :method:statementexecution/getStatement request, and
// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
// fields for simple iteration through the result set.
func (a *statementExecutionBaseClient) GetStatementResultChunkNByStatementIdAndChunkIndex(ctx context.Context, statementId string, chunkIndex int) (*ResultData, error) {
	return a.statementExecutionImpl.GetStatementResultChunkN(ctx, GetStatementResultChunkNRequest{
		StatementId: statementId,
		ChunkIndex:  chunkIndex,
	})
}

type warehousesBaseClient struct {
	warehousesImpl
}

// Delete a warehouse.
//
// Deletes a SQL warehouse.
func (a *warehousesBaseClient) DeleteById(ctx context.Context, id string) (*DeleteWarehouseResponse, error) {
	return a.warehousesImpl.Delete(ctx, DeleteWarehouseRequest{
		Id: id,
	})
}

// Get warehouse info.
//
// Gets the information for a single SQL warehouse.
func (a *warehousesBaseClient) GetById(ctx context.Context, id string) (*GetWarehouseResponse, error) {
	return a.warehousesImpl.Get(ctx, GetWarehouseRequest{
		Id: id,
	})
}

// Get SQL warehouse permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *warehousesBaseClient) GetPermissionLevelsByWarehouseId(ctx context.Context, warehouseId string) (*GetWarehousePermissionLevelsResponse, error) {
	return a.warehousesImpl.GetPermissionLevels(ctx, GetWarehousePermissionLevelsRequest{
		WarehouseId: warehouseId,
	})
}

// Get SQL warehouse permissions.
//
// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
// permissions from their root object.
func (a *warehousesBaseClient) GetPermissionsByWarehouseId(ctx context.Context, warehouseId string) (*WarehousePermissions, error) {
	return a.warehousesImpl.GetPermissions(ctx, GetWarehousePermissionsRequest{
		WarehouseId: warehouseId,
	})
}

// EndpointInfoNameToIdMap calls [warehousesBaseClient.ListAll] and creates a map of results with [EndpointInfo].Name as key and [EndpointInfo].Id as value.
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *warehousesBaseClient) EndpointInfoNameToIdMap(ctx context.Context, request ListWarehousesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [warehousesBaseClient.EndpointInfoNameToIdMap] and returns a single [EndpointInfo].
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *warehousesBaseClient) GetByName(ctx context.Context, name string) (*EndpointInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListWarehousesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]EndpointInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("EndpointInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of EndpointInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}
