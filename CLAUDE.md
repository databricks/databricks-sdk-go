# Databricks SDK for Go

Go SDK for the Databricks platform. Auto-generated API clients from OpenAPI specs,
with hand-written authentication, configuration, and transport infrastructure.

## Development

Prerequisites: Go 1.22+, `goimports`, `staticcheck`, `gotestsum`.

```bash
make build      # go build ./...
make test       # Unit tests with coverage
make fmt        # goimports + gofmt
make lint       # staticcheck ./...
make integration # Integration tests (requires cloud env)
make vendor     # Vendor dependencies
make coverage   # View HTML coverage report
make codegen    # Regenerate service/ from OpenAPI specs
```

CI runs `go build`, `go vet`, `staticcheck`, and `make test` across Go 1.22, 1.23, and 1.24.

## Architecture

```
├── apierr/         # API error types and handling
├── client/         # High-level DatabricksClient (wraps workspace + account APIs)
├── config/         # Authentication and client configuration (core, hand-written)
├── credentials/    # Credential providers (OAuth, PAT, Azure, GCP, etc.)
├── experimental/   # Experimental features and generated mocks
├── httpclient/     # HTTP transport layer, request/response handling
├── internal/       # Internal utilities
├── listing/        # Iterator patterns for paginated API responses
├── logger/         # Logging infrastructure
├── marshal/        # JSON marshalling utilities
├── openapi/        # Code generator (reads OpenAPI specs, generates service/)
├── retries/        # Retry logic and policies
├── service/        # Auto-generated API service clients (DO NOT EDIT)
├── useragent/      # User-agent string construction
├── .codegen/       # Code generation templates (.tmpl files)
└── qa/             # Integration test helpers (RandomName, RandomEmail, etc.)
```

## Generated Code

**DO NOT manually edit files in these directories — they are auto-generated:**

- `service/` — API service clients, generated from OpenAPI specs.
  Every file starts with `// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.`
- `experimental/mocks/` — Mock implementations, generated by mockery.
  Every file starts with `// Code generated by mockery. DO NOT EDIT.`

To regenerate: `make codegen` (requires OpenAPI specs).
After regenerating, run `make fmt` and `make lint`.

**Hand-written code** lives in: `config/`, `credentials/`, `httpclient/`, `apierr/`,
`listing/`, `retries/`, `marshal/`, `logger/`, `useragent/`, `client/`, `internal/`, `openapi/`.

## Code Style

- Go 1.22+ idioms: range-over-int, `min`/`max` builtins
- Format with `goimports` (handles import grouping) then `gofmt`
- All exported functions and types need doc comments: `// FuncName does X.`
- Interface doc comments should explain the **contract/lifecycle** — when methods are called,
  what callers expect, and when errors are appropriate — not just what they do
- Return early on errors; avoid deeply nested if-else chains
- Use `context.Context` as the first parameter for functions that do I/O

### Naming

- Acronyms are fully capitalized: `ID` not `Id`, `URL` not `Url`, `HTTP` not `Http`
- Avoid abbreviations: `authTokenCommand` not `authTokenCmd`
- Variable names describe content, not origin: `workspaceHost` not `resolvedHost`
- Use specific names when multiple similar types exist: `httpClient` not `client`

### Error Handling

- Wrap errors with **caller's context**: `fmt.Errorf("resolving workspace host: %w", err)`.
  Describe what *you* were doing, not what the callee does
- Don't add redundant wrapping — if the underlying error already contains the path/resource,
  add context at the abstraction boundary instead
- Include the specific resource/URL that failed, not just the operation name
- Define sentinel errors as package-level `var` using `errors.New()` — never `fmt.Errorf`.
  They must be comparable with `errors.Is()`
- Use `%q` (not `%s`) for strings in error/log messages — makes empty strings visible as `""`

### API Design

- Minimize exported API surface: if a type is only used through an interface, keep
  the concrete type unexported
- Pass specific values, not entire config objects — functions should depend on the narrowest
  interface possible
- Prefer new types over modifying existing exported types (additive changes only)
- Unstable APIs go under `experimental/` with `// Experimental: subject to change.` doc comments
- When setting default values (timeouts, retries, cache durations), comment the rationale
- Place helper functions near their callers, not at the top of the file
- Validate required fields in constructors — validate early, fail fast
- Validation logic should live near its point of use, not in generic/shared layers
- Use `switch/case` for type dispatching, not `if/else` chains
- Split functions with multiple concerns (e.g., create temp file + atomic rename)
  so each has one clear responsibility. Use `defer` to enforce cleanup invariants
- Extract shared logic into helpers at 3+ duplications, not before
- Adding a required field to a public type is a breaking change — use nil checks
  and defaults to preserve existing behavior

## Testing

`testify` is **discouraged in new packages** and **tolerated in existing packages**.
The SDK aims to minimize third-party dependencies.

- **New packages**: use Go's standard `testing` package with `google/go-cmp` for complex comparisons
- **Existing packages that already use testify**: keep using it for consistency within that package
- Do NOT introduce testify into a package that doesn't already use it

Table-driven tests are preferred for API client methods:

```go
for _, tc := range testCases {
    t.Run(tc.name, func(t *testing.T) {
        // ...
        if diff := cmp.Diff(tc.expected, actual); diff != "" {
            t.Errorf("mismatch (-want +got):\n%s", diff)
        }
    })
}
```

- Unit tests: `*_test.go` alongside source files
- Integration tests: use `//go:build cloud` build tag
- HTTP fixtures: `httpclient/fixtures/` for mocking HTTP responses
- Generated mocks: `experimental/mocks/` (do not hand-write mocks for generated services)
- Test helpers: `qa/` package for integration test utilities
- Call `t.Helper()` at the start of test helper functions (correct line numbers in failures)
- For configurable options, always test three cases: (1) explicit values, (2) nil/unset default, (3) empty value
- When a feature spans multiple implementations, test the same scenarios consistently in each
- Inject `time.Now` as `func() time.Time` for time-dependent logic — makes tests deterministic
- Always check errors — never use `_` for error returns in tests
- Assert on exact expected values, not partial matches (e.g., full header value, not just prefix)
- Extract repeated test values to shared `const`/`var` to convey intent and avoid silent drift
- Add explicit timeouts to channel/goroutine-based tests to prevent hanging
- Use `defer close(ch)` for channel cleanup to handle error paths safely

### Testing Anti-Patterns (never do these)

- Deleting or skipping flaky tests instead of fixing the root cause
- Over-mocking — prefer HTTP fixtures over deep mock chains
- Tests depending on execution order or shared mutable state
- Non-descriptive test names (`TestFoo`, `TestBasic`) — use `TestFunctionName_Scenario_ExpectedBehavior`
- `time.Sleep` in tests — inject a clock or use polling with `assert.Eventually`
- Testing generated code in `service/` — test your hand-written code that uses it
- Exporting methods solely for test access — use `cmp.Diff` to compare structs,
  or write internal (`_test.go` in same package) tests instead
- Unnecessary concurrency in tests — if goroutines/channels aren't clearly needed, don't use them

## Common Mistakes

- Do NOT edit files in `service/` or `experimental/mocks/` — they are auto-generated and will be overwritten
- Do NOT use `context.Background()` in production code (only in tests)
- Do NOT add new files to `service/` manually — update OpenAPI specs and run `make codegen`
- Do NOT add dependencies without checking license compatibility (Apache 2.0 required)
- Do NOT break backwards compatibility of exported APIs without discussion
- Do NOT use `os.Exit()` outside of `main.go` entry points

## Where to Put New Code

1. New API service client? → Update OpenAPI spec, run `make codegen`
2. New auth method? → `credentials/` (implement `CredentialsProvider` interface)
3. Auth config change? → `config/`
4. HTTP transport change? → `httpclient/`
5. New error type? → `apierr/`
6. New pagination pattern? → `listing/`
7. Retry logic change? → `retries/`
8. Code generation change? → `openapi/` and `.codegen/` templates
9. Experimental/unstable API? → `experimental/` or `config/experimental/`

## Pull Requests

PR template requires: Changes (linked issues + functionality) and Tests sections.
All PRs must have the `DCO` sign-off (`git commit -s`).
Run `make fmt test lint` before submitting.

### Changelog

Every PR must update `NEXT_CHANGELOG.md` under the appropriate section
(Breaking Changes, New Features and Improvements, Bug Fixes, Documentation,
Internal Changes, or API Changes). CI will fail if the file is not modified.

For PRs that don't need a changelog entry (e.g., documentation-only, CI config,
agentic coding infrastructure), add `NO_CHANGELOG=true` to the PR description body.
