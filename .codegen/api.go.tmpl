// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// {{if .Description}}{{.Description}}{{else}}These APIs allow you to manage {{range .Services}}{{.TitleName}}, {{end}}etc.{{end}}
package {{.Name}}

import (
	"context"
	"fmt"
	"time"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/useragent"
)
{{range .Services}}
func New{{.PascalName}}(client *client.DatabricksClient) *{{.PascalName}}API {
	return &{{.PascalName}}API{
		impl: &{{.CamelName}}Impl{
			client: client,
		},
	}
}

{{.Comment "// " 80}}
type {{.PascalName}}API struct {
	// impl contains low-level REST API interface, that could be overridden 
	// through WithImpl({{.PascalName}}Service)
	impl {{.PascalName}}Service
}

// WithImpl could be used to override low-level API implementations for unit 
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *{{.PascalName}}API) WithImpl(impl {{.PascalName}}Service) *{{.PascalName}}API {
	a.impl = impl
	return a
}

// Impl returns low-level {{.PascalName}} API implementation
func (a *{{.PascalName}}API) Impl() {{.PascalName}}Service {
	return a.impl
}

{{range .Methods}}{{if not .Pagination}}{{.Comment "// " 80}}
func (a *{{.Service.PascalName}}API) {{.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) {{if .Response}}({{if .Response.ArrayValue}}[]{{.Response.ArrayValue.PascalName}}{{else}}*{{template "type" .Response}}{{end}}, error){{else}}error{{end}} {
	return a.impl.{{.PascalName}}(ctx{{if .Request}}, request{{end}})
}
{{end}}

{{if .Wait}}
// Calls [{{.Service.Name}}API.{{.PascalName}}] and waits to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
// 
// You can override the default timeout of {{.Wait.Timeout}} minutes by calling adding 
// retries.Timeout[{{.Wait.Poll.Response.PascalName}}](60*time.Minute) functional option.
func (a *{{.Service.Name}}API) {{.PascalName}}AndWait(ctx context.Context{{if .Request}}, {{.Request.CamelName}} {{.Request.PascalName}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	{{if .Wait.ForceBindRequest}}_, {{else if .Response}}{{.Response.CamelName}}, {{end}}err := a.{{.PascalName}}(ctx{{if .Request}}, {{.Request.CamelName}}{{end}})
	if err != nil {
		return nil, err
	}
	i := retries.Info[{{.Wait.Poll.Response.PascalName}}]{Timeout: {{.Wait.Timeout}}*time.Minute}
	for _, o := range options {
		o(&i)
	}
	return retries.Poll[{{.Wait.Poll.Response.PascalName}}](ctx, i.Timeout, func() (*{{.Wait.Poll.Response.PascalName}}, *retries.Err) {
		{{.Wait.Poll.Response.CamelName}}, err := a.{{.Wait.Poll.PascalName}}(ctx, {{.Wait.Poll.Request.PascalName}}{ {{range .Wait.Binding}}
			{{.PollField.PascalName}}: {{.Bind.Of.CamelName}}.{{.Bind.PascalName}},{{end}}
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		for _, o := range options {
			o(&retries.Info[{{.Wait.Poll.Response.PascalName}}]{
				Info: {{.Wait.Poll.Response.CamelName}},
				Timeout: i.Timeout,
			})
		}
		status := {{.Wait.Poll.Response.CamelName}}{{range .Wait.StatusPath}}.{{.PascalName}}{{end}}
		{{if .Wait.MessagePath -}}
		{{if .Wait.ComplexMessagePath -}}
		statusMessage := fmt.Sprintf("current status: %s", status)
		if ({{.Wait.Poll.Response.CamelName}}.{{.Wait.MessagePathHead.PascalName}} != nil) {
			statusMessage = {{.Wait.Poll.Response.CamelName}}{{range .Wait.MessagePath}}.{{.PascalName}}{{end}}
		}
		{{- else -}}
		statusMessage := {{.Wait.Poll.Response.CamelName}}{{range .Wait.MessagePath}}.{{.PascalName}}{{end}}
		{{- end}}
		{{- else -}}
		statusMessage := fmt.Sprintf("current status: %s", status)
		{{- end}}
		switch status {
		case {{range $i, $e := .Wait.Success}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}: // target state
			return {{.Wait.Poll.Response.CamelName}}, nil
		{{if .Wait.Failure}}case {{range $i, $e := .Wait.Failure}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}:
			err := fmt.Errorf("failed to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}%s{{end}}, got %s: %s",
				{{range $i, $e := .Wait.Success}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}, status, statusMessage)
			return nil, retries.Halt(err)
		{{end}}default:
			return nil, retries.Continues(statusMessage)
		}
	})
}
{{end}}{{if .Pagination}}
{{.Comment "// " 80}}
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.Name}}API) {{.PascalName}}All(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) ([]{{.Pagination.Entity.PascalName}}, error) {
	{{if .Pagination.MultiRequest}}var results []{{.Pagination.Entity.PascalName}}
	{{ if .Pagination.Limit -}}
	var totalCount {{template "type" .Pagination.Offset.Entity}} = 0
	{{ end -}}
	ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
	{{if .Pagination.NeedsOffsetDedupe -}}
	// deduplicate items that may have been added during iteration
	seen := map[{{template "type" .Pagination.Entity.IdentifierField.Entity}}]bool{}
	{{end}}{{if eq .Pagination.Increment 1 -}}
	request.{{.Pagination.Offset.PascalName}} = 1 // start iterating from the first page
	{{end}}for {
		response, err := a.impl.{{.PascalName}}(ctx{{if .Request}}, request{{end}})
		if err != nil {
			return nil, err
		}
		if len(response.{{.Pagination.Results.PascalName}}) == 0 {
			break
		}
		for _, v := range response.{{.Pagination.Results.PascalName}} {
			{{- if .Pagination.NeedsOffsetDedupe -}}
			id := v.{{.Pagination.Entity.IdentifierField.PascalName}}
			if seen[id] {
				// item was added during iteration
				continue
			}
			seen[id] = true
			{{- end}}
			results = append(results, v)
		}
		{{ if .Pagination.Offset -}}
			count := {{template "type" .Pagination.Offset.Entity}}(len(response.{{.Pagination.Results.PascalName}}))
			totalCount += count
		{{ end -}}
		{{if eq .Path "/api/2.0/clusters/events" -}}
		if response.NextPage == nil {
			break
		}
		request = *response.NextPage
		{{- else if .Pagination.Token -}}
		request.{{.Pagination.Token.PollField.PascalName}} = response.{{.Pagination.Token.Bind.PascalName}}
		if response.{{.Pagination.Token.Bind.PascalName}} == "" {
			break
		}
		{{- else if eq .Pagination.Increment 1 -}}
		request.{{.Pagination.Offset.PascalName}}++
		{{- else -}}
		request.{{.Pagination.Offset.PascalName}} += {{template "type" .Pagination.Offset.Entity}}(len(response.{{.Pagination.Results.PascalName}}))
		{{- end}}
		{{ if .Pagination.Limit -}}
		limit := request.{{.Pagination.Limit.PascalName}}
		if limit > 0 && totalCount >= limit {
			break
		}
		{{- end -}}
	}
	return results, nil{{else if .Pagination.Results}}response, err := a.impl.{{.PascalName}}(ctx{{if .Request}}, request{{end}})
	if err != nil {
		return nil, err
	}
	return response.{{.Pagination.Results.PascalName}}, nil{{else}}return a.impl.{{.PascalName}}(ctx, request){{end}}
}
{{end}}{{if .NamedIdMap}}
// {{.NamedIdMap.PascalName}} calls [{{.Service.Name}}API.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end -}}] and creates a map of results with [{{.NamedIdMap.Entity.PascalName}}]{{range .NamedIdMap.NamePath}}.{{.PascalName}}{{end}} as key and [{{.NamedIdMap.Entity.PascalName}}].{{.NamedIdMap.Id.PascalName}} as value.
//
// Returns an error if there's more than one [{{.NamedIdMap.Entity.PascalName}}] with the same {{range .NamedIdMap.NamePath}}.{{.PascalName}}{{end}}.
//
// Note: All [{{.NamedIdMap.Entity.PascalName}}] instances are loaded into memory before creating a map.
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.Name}}API) {{.NamedIdMap.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) (map[string]{{template "type" .NamedIdMap.Id.Entity}}, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]{{template "type" .NamedIdMap.Id.Entity}}{}
	result, err := a.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end}}(ctx{{if .Request}}, request{{end}})
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v{{range .NamedIdMap.NamePath}}.{{.PascalName}}{{end}}
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate {{range .NamedIdMap.NamePath}}.{{.PascalName}}{{end}}: %s", key)
		}
		mapping[key] = v.{{.NamedIdMap.Id.PascalName}}
	}
	return mapping, nil
}
{{end}}{{if .GetByName}}
// GetBy{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}} calls [{{.Service.Name}}API.{{.NamedIdMap.Entity.PascalName}}{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}}To{{.NamedIdMap.Id.PascalName}}Map] and returns a single [{{.GetByName.PascalName}}].
//
// Returns an error if there's more than one [{{.NamedIdMap.Entity.PascalName}}] with the same {{range .NamedIdMap.NamePath}}.{{.PascalName}}{{end}}.
//
// Note: All [{{.NamedIdMap.Entity.PascalName}}] instances are loaded into memory before returning matching by name.
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.Name}}API) GetBy{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}}(ctx context.Context, name string) (*{{template "type" .GetByName}}, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end}}(ctx{{if .Request}}, {{.Request.PascalName}}{}{{end}})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]{{.GetByName.PascalName}}{}
	for _, v := range result {
		key := v{{range .NamedIdMap.NamePath}}.{{.PascalName}}{{end}}
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("{{.GetByName.PascalName}} named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of {{.GetByName.PascalName}} named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}
{{end}}{{if .Shortcut}}
{{.Comment "// " 80}}
func (a *{{.Service.Name}}API) {{.Shortcut.PascalName}}(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}) {{if .Response}}({{if .Response.ArrayValue}}[]{{.Response.ArrayValue.PascalName}}{{else}}*{{template "type" .Response}}{{end}}, error){{else}}error{{end}} {
	return a.impl.{{.PascalName}}(ctx, {{.Request.PascalName}}{
		{{- range .Shortcut.Params}}
		{{.PascalName}}: {{.CamelName}},{{end}}
	})
}
{{end}}{{if and .Shortcut .Wait}}
func (a *{{.Service.Name}}API) {{.Shortcut.PascalName}}AndWait(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error) {
	return a.{{.PascalName}}AndWait(ctx, {{.Request.PascalName}}{
		{{- range .Shortcut.Params}}
		{{.PascalName}}: {{.CamelName}},{{end}}
	}, options...)
}
{{end}}
{{end -}}

{{- end}}