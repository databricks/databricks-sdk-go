// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// {{if .Description}}{{.Description}}{{else}}These APIs allow you to manage {{range .Services}}{{.TitleName}}, {{end}}etc.{{end}}
package {{.Name}}

import (
	"context"
	"fmt"
	"time"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/useragent"
)
{{ $extendedInterface :=
	list
		"Clusters"
		"CommandExecution"
		"Dbfs"
		"Libraries"
		"StatementExecution"
		"Workspace"
}}
{{range .Services}}

type {{.PascalName}}Interface interface {
	{{if (in $extendedInterface .PascalName) }}
		{{.CamelName}}APIUtilities
	{{end -}}

	{{range .Subservices}}
	{{.Comment "    // " 80}}
	{{.PascalName}}() {{.PascalName}}Interface
	{{end}}

	{{range .Waits}}
	// {{.PascalName}} repeatedly calls [{{.Method.Service.PascalName}}API.{{.Poll.PascalName}}] and waits to reach {{range $i, $e := .Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
	{{.PascalName}}(ctx context.Context{{range .Binding}}, {{.PollField.CamelName}} {{template "type" .PollField.Entity}}{{end}},
		timeout time.Duration, callback func(*{{.Poll.Response.PascalName}})) (*{{.Poll.Response.PascalName}}, error)
	{{end}}

	{{range .Methods}}
	{{- $hasWaiter := and .Wait (and (not .IsCrudRead) (not (eq .SnakeName "get_run"))) -}}
	{{if not .Pagination}}{{.Comment "// " 80}}	
	{{.PascalName}}(ctx context.Context{{if .Request}}, {{if $hasWaiter}}{{.Request.CamelName}}{{else}}request{{end}} {{.Request.PascalName}}{{end}}) {{if $hasWaiter}}{{ template "wait-response-type" . }}{{else}}{{ template "response-type" .}}{{end}}
	{{end}}

	{{if $hasWaiter}}
	// Calls [{{.Service.PascalName}}APIInterface.{{.PascalName}}] and waits to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
	// 
	// You can override the default timeout of {{.Wait.Timeout}} minutes by calling adding 
	// retries.Timeout[{{.Wait.Poll.Response.PascalName}}](60*time.Minute) functional option.
	//
	// Deprecated: use [{{.Service.PascalName}}APIInterface.{{.PascalName}}].Get() or [{{.Service.PascalName}}APIInterface.{{.Wait.PascalName}}]
	{{.PascalName}}AndWait(ctx context.Context{{if .Request}}, {{.Request.CamelName}} {{.Request.PascalName}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error)

	{{end}}{{if .Pagination}}
	{{.Comment "// " 80}}
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) {{ template "paginated-return-type" . }}

	{{.Comment "// " 80}}
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.PascalName}}All(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) ([]{{ template "type" .Pagination.Entity }}, error)
		
	{{end}}{{if .NamedIdMap}}
	// {{.NamedIdMap.PascalName}} calls [{{.Service.PascalName}}API.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end -}}] and creates a map of results with [{{.NamedIdMap.Entity.PascalName}}]{{ template "field-path" .NamedIdMap.NamePath }} as key and [{{.NamedIdMap.Entity.PascalName}}]{{ template "field-path" .NamedIdMap.IdPath}} as value.
	//
	// Returns an error if there's more than one [{{.NamedIdMap.Entity.PascalName}}] with the same {{ template "field-path" .NamedIdMap.NamePath }}.
	//
	// Note: All [{{.NamedIdMap.Entity.PascalName}}] instances are loaded into memory before creating a map.
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.NamedIdMap.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) (map[string]{{template "type" .NamedIdMap.Id.Entity}}, error)
	
	{{end}}{{if .GetByName}}
	// GetBy{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}} calls [{{.Service.PascalName}}API.{{.NamedIdMap.Entity.PascalName}}{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}}To{{.NamedIdMap.Id.PascalName}}Map] and returns a single [{{.GetByName.PascalName}}].
	//
	// Returns an error if there's more than one [{{.NamedIdMap.Entity.PascalName}}] with the same {{ template "field-path" .NamedIdMap.NamePath }}.
	//
	// Note: All [{{.NamedIdMap.Entity.PascalName}}] instances are loaded into memory before returning matching by name.
	// 
	// This method is generated by Databricks SDK Code Generator.
	GetBy{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}}(ctx context.Context, name string) (*{{template "type" .GetByName}}, error)
		
	{{end}}{{if .Shortcut}}
	{{.Comment "// " 80}}
	{{.Shortcut.PascalName}}(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}) {{ template "response-type" . }}
	
	{{end}}{{if and .Shortcut $hasWaiter}}
	{{.Shortcut.PascalName}}AndWait(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error)
	
	{{end}}
{{end -}}
}

func New{{.PascalName}}(client *client.DatabricksClient,
{{- if .IsDataPlane}}
controlPlane *{{.ControlPlaneService.PascalName}}API,
{{end -}}
) *{{.PascalName}}API {
	return &{{.PascalName}}API{
		{{.CamelName}}Impl: {{.CamelName}}Impl{
			client: client,
			{{- if .IsDataPlane}}
			dataPlaneService: oauth2.NewDataPlaneService(),
			controlPlane: controlPlane,
			{{end}}
		},
		{{range .Subservices}}
		{{.CamelName}}: New{{.PascalName}}(client),
		{{end}}
	}
}

{{.Comment "// " 80}}
type {{.PascalName}}API struct {
	{{.CamelName}}Impl

	{{range .Subservices}}
	{{.Comment "    // " 80}}
	{{.CamelName}} {{.PascalName}}Interface
	{{end}}
}

{{range .Subservices}}
func (a *{{.ParentService.PascalName}}API) {{.PascalName}}() {{.PascalName}}Interface {
	return a.{{.CamelName}}
}
{{end}}

{{range .Waits}}
// {{.PascalName}} repeatedly calls [{{.Method.Service.PascalName}}API.{{.Poll.PascalName}}] and waits to reach {{range $i, $e := .Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
func (a *{{.Method.Service.PascalName}}API) {{.PascalName}}(ctx context.Context{{range .Binding}}, {{.PollField.CamelName}} {{template "type" .PollField.Entity}}{{end}},
	timeout time.Duration, callback func(*{{.Poll.Response.PascalName}})) (*{{.Poll.Response.PascalName}}, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[{{.Poll.Response.PascalName}}](ctx, timeout, func() (*{{.Poll.Response.PascalName}}, *retries.Err) {
		{{.Poll.Response.CamelName}}, err := a.{{.Poll.PascalName}}(ctx, {{.Poll.Request.PascalName}}{ {{range .Binding}}
			{{.PollField.PascalName}}: {{.PollField.CamelName}},{{end}}
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback({{.Poll.Response.CamelName}})
		}
		status := {{.Poll.Response.CamelName}}{{range .StatusPath}}.{{.PascalName}}{{end}}
		{{if .MessagePath -}}
		{{if .ComplexMessagePath -}}
		statusMessage := fmt.Sprintf("current status: %s", status)
		if ({{.Poll.Response.CamelName}}.{{.MessagePathHead.PascalName}} != nil) {
			statusMessage = {{.Poll.Response.CamelName}}{{range .MessagePath}}.{{.PascalName}}{{end}}
		}
		{{- else -}}
		statusMessage := {{.Poll.Response.CamelName}}{{range .MessagePath}}.{{.PascalName}}{{end}}
		{{- end}}
		{{- else -}}
		statusMessage := fmt.Sprintf("current status: %s", status)
		{{- end}}
		switch status {
		case {{range $i, $e := .Success}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}: // target state
			return {{.Poll.Response.CamelName}}, nil
		{{if .Failure}}case {{range $i, $e := .Failure}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}:
			err := fmt.Errorf("failed to reach {{range $i, $e := .Success}}{{if $i}} or {{end}}%s{{end}}, got %s: %s",
				{{range $i, $e := .Success}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}, status, statusMessage)
			return nil, retries.Halt(err)
		{{end}}default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// {{.PascalName}} is a wrapper that calls [{{.Method.Service.PascalName}}API.{{.PascalName}}] and waits to reach {{range $i, $e := .Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state.
type {{.PascalName}}[R any] struct {
	Response *R{{range .Binding}}
	{{.PollField.PascalName}} {{template "type" .PollField.Entity}} `json:"{{.PollField.Name}}"`{{end}}
	Poll     func(time.Duration, func(*{{.Poll.Response.PascalName}})) (*{{.Poll.Response.PascalName}}, error)
	callback func(*{{.Poll.Response.PascalName}})
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *{{.PascalName}}[R]) OnProgress(callback func(*{{.Poll.Response.PascalName}})) *{{.PascalName}}[R] {
	w.callback = callback
	return w
}

// Get the {{.Poll.Response.PascalName}} with the default timeout of {{.Timeout}} minutes.
func (w *{{.PascalName}}[R]) Get() (*{{.Poll.Response.PascalName}}, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the {{.Poll.Response.PascalName}} with custom timeout.
func (w *{{.PascalName}}[R]) GetWithTimeout(timeout time.Duration) (*{{.Poll.Response.PascalName}}, error) {
	return w.Poll(timeout, w.callback)
}
{{end}}

{{range .Methods}}
{{- $hasWaiter := and .Wait (and (not .IsCrudRead) (not (eq .SnakeName "get_run"))) -}}
{{if not .Pagination}}

{{/* 
Function with no waiter are ignored as the API struct automatically inherits
methods from the nested service interface.
*/}}
{{if $hasWaiter -}}
{{.Comment "// " 80}}
func (a *{{.Service.PascalName}}API) {{.PascalName}}(ctx context.Context{{if .Request}}, {{.Request.CamelName}} {{.Request.PascalName}}{{end}}) {{ template "wait-response-type" . }} {
	{{if not .Response.IsEmpty }}{{.Response.CamelName}}, {{end}}err := a.{{.Service.CamelName}}Impl.{{.PascalName}}(ctx{{if .Request}}, {{.Request.CamelName}}{{end}})
	if err != nil {
		return nil, err
	}
	return &{{.Wait.PascalName}}[{{with .Response}}{{if .IsEmpty}}struct{}{{else}}{{.PascalName}}{{end}}{{end}}]{
		{{with .Response}}{{if not .IsEmpty}}Response: {{.CamelName}},{{end}}
		{{- end}}{{range .Wait.Binding}}
		{{.PollField.PascalName}}: {{.Bind.Of.CamelName}}.{{.Bind.PascalName}},{{end}}
		Poll: func(timeout time.Duration, callback func(*{{.Wait.Poll.Response.PascalName}})) (*{{.Wait.Poll.Response.PascalName}}, error) {
			return a.{{.Wait.PascalName}}(ctx{{range .Wait.Binding}}, {{.Bind.Of.CamelName}}.{{.Bind.PascalName}}{{end}}, timeout, callback)
		},
		timeout: {{.Wait.Timeout}}*time.Minute,
		callback: nil,
	}, nil
}
{{- end}}
{{end}} {{/* end of {{if not .Pagination}} */}}

{{if $hasWaiter}}
// Calls [{{.Service.PascalName}}API.{{.PascalName}}] and waits to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
// 
// You can override the default timeout of {{.Wait.Timeout}} minutes by calling adding 
// retries.Timeout[{{.Wait.Poll.Response.PascalName}}](60*time.Minute) functional option.
//
// Deprecated: use [{{.Service.PascalName}}API.{{.PascalName}}].Get() or [{{.Service.PascalName}}API.{{.Wait.PascalName}}]
func (a *{{.Service.PascalName}}API) {{.PascalName}}AndWait(ctx context.Context{{if .Request}}, {{.Request.CamelName}} {{.Request.PascalName}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error) {
	wait, err := a.{{.PascalName}}(ctx{{if .Request}}, {{.Request.CamelName}}{{end}})
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[{{.Wait.Poll.Response.PascalName}}]{Timeout: {{.Wait.Timeout}}*time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *{{.Wait.Poll.Response.PascalName}}) {
		for _, o := range options {
			o(&retries.Info[{{.Wait.Poll.Response.PascalName}}]{
				Info: info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}
{{end}}{{if .Pagination}}
{{.Comment "// " 80}}
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.PascalName}}API) {{.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) {{ template "paginated-return-type" . }} {
	{{ if not .Request }}request := struct{}{}{{end}}
	{{if eq .Pagination.Increment 1 -}}
	request.{{.Pagination.Offset.PascalName}} = 1 // start iterating from the first page
	{{else if contains .Path "/scim/v2/" -}}
	request.{{.Pagination.Offset.PascalName}} = 1 // SCIM offset starts from 1
	{{end}}{{if and .Pagination.Limit (contains .Path "/scim/v2/") -}}
	if request.{{.Pagination.Limit.PascalName}} == 0 {
		request.{{.Pagination.Limit.PascalName}} = 100
	}
	{{- end}}
	getNextPage := func(ctx context.Context, req {{ template "paginated-request-type" . }}) (*{{ .Response.PascalName }}, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.{{.Service.CamelName}}Impl.{{.PascalName}}(ctx{{if .Request}}, req{{end}})
	}
	getItems := func(resp *{{ .Response.PascalName }}) []{{ template "type" .Pagination.Entity }} {
		return {{if .Pagination.Results}}resp.{{.Pagination.Results.PascalName}}{{else}}resp{{end}}
	}
	{{if .Pagination.MultiRequest -}}
	getNextReq := func(resp *{{ .Response.PascalName }}) *{{.Request.PascalName}} {
		{{if .Pagination.Token -}}
		if resp.{{.Pagination.Token.Bind.PascalName}} == "" {
			return nil
		}
		request.{{.Pagination.Token.PollField.PascalName}} = resp.{{.Pagination.Token.Bind.PascalName}}
		{{- else if eq .Path "/api/2.1/clusters/events" -}}
		if resp.NextPage == nil {
			return nil
		}
		request = *resp.NextPage
		{{ else -}}
		if len(getItems(resp)) == 0 {
			return nil
		}
		{{ if eq .Pagination.Increment 1 -}}
		request.{{.Pagination.Offset.PascalName}} = resp.{{.Pagination.Offset.PascalName}} + 1
		{{- else -}}
		request.{{.Pagination.Offset.PascalName}} = resp.{{.Pagination.Offset.PascalName}} + {{template "type" .Pagination.Offset.Entity}}(len(resp.{{.Pagination.Results.PascalName}}))
		{{- end}}{{ end }}
		return &request
	}
	{{- end}}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		{{if .Pagination.MultiRequest}}getNextReq{{else}}nil{{end}})
	{{ if .NeedsOffsetDedupe -}}
	dedupedIterator := listing.NewDedupeIterator[{{ template "type" .Pagination.Entity }}, {{ template "type" .IdentifierField.Entity }}](
		iterator,
		func(item {{ template "type" .Pagination.Entity }}) {{ template "type" .IdentifierField.Entity }} {
			return item{{ template "field-path" .IdFieldPath }}
		})
	return dedupedIterator
	{{- else -}}
	return iterator
	{{- end }}
}

{{.Comment "// " 80}}
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.PascalName}}API) {{.PascalName}}All(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) ([]{{ template "type" .Pagination.Entity }}, error) {
	iterator := a.{{.PascalName}}(ctx{{if .Request}}, request{{end}})
	{{ if .Pagination.Limit -}}
	return listing.ToSliceN[{{ template "type" .Pagination.Entity }}, {{ template "type" .Pagination.Limit.Entity }}](ctx, iterator, request.{{.Pagination.Limit.PascalName}})
	{{ else -}}
	return listing.ToSlice[{{ template "type" .Pagination.Entity }}](ctx, iterator)
	{{- end }}
}
{{end}}{{if .NamedIdMap}}
// {{.NamedIdMap.PascalName}} calls [{{.Service.PascalName}}API.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end -}}] and creates a map of results with [{{.NamedIdMap.Entity.PascalName}}]{{ template "field-path" .NamedIdMap.NamePath }} as key and [{{.NamedIdMap.Entity.PascalName}}]{{ template "field-path" .NamedIdMap.IdPath}} as value.
//
// Returns an error if there's more than one [{{.NamedIdMap.Entity.PascalName}}] with the same {{ template "field-path" .NamedIdMap.NamePath }}.
//
// Note: All [{{.NamedIdMap.Entity.PascalName}}] instances are loaded into memory before creating a map.
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.PascalName}}API) {{.NamedIdMap.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) (map[string]{{template "type" .NamedIdMap.Id.Entity}}, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]{{template "type" .NamedIdMap.Id.Entity}}{}
	result, err := a.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end}}(ctx{{if .Request}}, request{{end}})
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v{{ template "field-path" .NamedIdMap.NamePath }}
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate {{ template "field-path" .NamedIdMap.NamePath }}: %s", key)
		}
		mapping[key] = v{{ template "field-path" .NamedIdMap.IdPath }}
	}
	return mapping, nil
}
{{end}}{{if .GetByName}}
// GetBy{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}} calls [{{.Service.PascalName}}API.{{.NamedIdMap.Entity.PascalName}}{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}}To{{.NamedIdMap.Id.PascalName}}Map] and returns a single [{{.GetByName.PascalName}}].
//
// Returns an error if there's more than one [{{.NamedIdMap.Entity.PascalName}}] with the same {{ template "field-path" .NamedIdMap.NamePath }}.
//
// Note: All [{{.NamedIdMap.Entity.PascalName}}] instances are loaded into memory before returning matching by name.
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.PascalName}}API) GetBy{{range .NamedIdMap.NamePath}}{{.PascalName}}{{end}}(ctx context.Context, name string) (*{{template "type" .GetByName}}, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end}}(ctx{{if .Request}}, {{.Request.PascalName}}{}{{end}})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]{{.GetByName.PascalName}}{}
	for _, v := range result {
		key := v{{ template "field-path" .NamedIdMap.NamePath }}
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("{{.GetByName.PascalName}} named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of {{.GetByName.PascalName}} named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}
{{end}}{{if .Shortcut}}
{{.Comment "// " 80}}
func (a *{{.Service.PascalName}}API) {{.Shortcut.PascalName}}(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}) {{ template "response-type" . }} {
	return a.{{.Service.CamelName}}Impl.{{.PascalName}}(ctx, {{.Request.PascalName}}{
		{{- range .Shortcut.Params}}
		{{.PascalName}}: {{.CamelName}},{{end}}
	})
}
{{end}}{{if and .Shortcut $hasWaiter}}
func (a *{{.Service.PascalName}}API) {{.Shortcut.PascalName}}AndWait(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error) {
	return a.{{.PascalName}}AndWait(ctx, {{.Request.PascalName}}{
		{{- range .Shortcut.Params}}
		{{.PascalName}}: {{.CamelName}},{{end}}
	}, options...)
}
{{end}}
{{end -}}
{{- end}}
{{- define "field-path" -}}
	{{- range .}}.{{.PascalName}}{{end}}
{{- end -}}
{{- define "paginated-request-type" -}}
  {{if .Request}}{{.Request.PascalName}}{{else}}struct{}{{end}}
{{- end -}}

{{/* Note: we return the interface to make it possible to mock list responses more easily. */}}
{{- define "paginated-return-type" -}}
  listing.Iterator[{{ template "type" .Pagination.Entity }}]
{{- end -}}

{{- define "wait-response-type" -}}
(*{{.Wait.PascalName}}[{{with .Response}}{{if .IsEmpty}}struct{}{{else}}{{.PascalName}}{{end}}{{end}}], error)
{{- end -}}