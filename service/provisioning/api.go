// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Credentials, Encryption Keys, Networks, Private Access, Storage, Vpc Endpoints, Workspaces, etc.
package provisioning

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type CredentialsInterface interface {

	// Creates a Databricks credential configuration that represents cloud
	// cross-account credentials for a specified account. Databricks uses this to
	// set up network infrastructure properly to host Databricks clusters. For your
	// AWS IAM role, you need to trust the External ID (the Databricks Account API
	// account ID) in the returned credential object, and configure the required
	// access policy.
	//
	// Save the response's `credentials_id` field, which is the ID for your new
	// credential configuration object.
	//
	// For information about how to create a new workspace with this API, see
	// [Create a new workspace using the Account API]
	//
	// [Create a new workspace using the Account API]: http://docs.databricks.com/administration-guide/account-api/new-workspace.html
	Create(ctx context.Context, request CreateCredentialRequest) (*Credential, error)

	// Deletes a Databricks credential configuration object for an account, both
	// specified by ID. You cannot delete a credential that is associated with any
	// workspace.
	Delete(ctx context.Context, request DeleteCredentialRequest) (*Credential, error)

	// Deletes a Databricks credential configuration object for an account, both
	// specified by ID. You cannot delete a credential that is associated with any
	// workspace.
	DeleteByCredentialsId(ctx context.Context, credentialsId string) (*Credential, error)

	// Gets a Databricks credential configuration object for an account, both
	// specified by ID.
	Get(ctx context.Context, request GetCredentialRequest) (*Credential, error)

	// Gets a Databricks credential configuration object for an account, both
	// specified by ID.
	GetByCredentialsId(ctx context.Context, credentialsId string) (*Credential, error)

	// List Databricks credential configuration objects for an account, specified by
	// ID.
	List(ctx context.Context) ([]Credential, error)

	// CredentialCredentialsNameToCredentialsIdMap calls [CredentialsAPI.List] and creates a map of results with [Credential].CredentialsName as key and [Credential].CredentialsId as value.
	//
	// Returns an error if there's more than one [Credential] with the same .CredentialsName.
	//
	// Note: All [Credential] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	CredentialCredentialsNameToCredentialsIdMap(ctx context.Context) (map[string]string, error)

	// GetByCredentialsName calls [CredentialsAPI.CredentialCredentialsNameToCredentialsIdMap] and returns a single [Credential].
	//
	// Returns an error if there's more than one [Credential] with the same .CredentialsName.
	//
	// Note: All [Credential] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByCredentialsName(ctx context.Context, name string) (*Credential, error)
}

func NewCredentials(client *client.DatabricksClient) *CredentialsAPI {
	return &CredentialsAPI{
		credentialsImpl: credentialsImpl{
			client: client,
		},
	}
}

// These APIs manage credential configurations for this workspace. Databricks
// needs access to a cross-account service IAM role in your AWS account so that
// Databricks can deploy clusters in the appropriate VPC for the new workspace.
// A credential configuration encapsulates this role information, and its ID is
// used when creating a new workspace.
type CredentialsAPI struct {
	credentialsImpl
}

// Deletes a Databricks credential configuration object for an account, both
// specified by ID. You cannot delete a credential that is associated with any
// workspace.
func (a *CredentialsAPI) DeleteByCredentialsId(ctx context.Context, credentialsId string) (*Credential, error) {
	return a.credentialsImpl.Delete(ctx, DeleteCredentialRequest{
		CredentialsId: credentialsId,
	})
}

// Gets a Databricks credential configuration object for an account, both
// specified by ID.
func (a *CredentialsAPI) GetByCredentialsId(ctx context.Context, credentialsId string) (*Credential, error) {
	return a.credentialsImpl.Get(ctx, GetCredentialRequest{
		CredentialsId: credentialsId,
	})
}

// CredentialCredentialsNameToCredentialsIdMap calls [CredentialsAPI.List] and creates a map of results with [Credential].CredentialsName as key and [Credential].CredentialsId as value.
//
// Returns an error if there's more than one [Credential] with the same .CredentialsName.
//
// Note: All [Credential] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *CredentialsAPI) CredentialCredentialsNameToCredentialsIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.CredentialsName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .CredentialsName: %s", key)
		}
		mapping[key] = v.CredentialsId
	}
	return mapping, nil
}

// GetByCredentialsName calls [CredentialsAPI.CredentialCredentialsNameToCredentialsIdMap] and returns a single [Credential].
//
// Returns an error if there's more than one [Credential] with the same .CredentialsName.
//
// Note: All [Credential] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *CredentialsAPI) GetByCredentialsName(ctx context.Context, name string) (*Credential, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Credential{}
	for _, v := range result {
		key := v.CredentialsName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Credential named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Credential named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type EncryptionKeysInterface interface {

	// Creates a customer-managed key configuration object for an account, specified
	// by ID. This operation uploads a reference to a customer-managed key to
	// Databricks. If the key is assigned as a workspace's customer-managed key for
	// managed services, Databricks uses the key to encrypt the workspaces notebooks
	// and secrets in the control plane, in addition to Databricks SQL queries and
	// query history. If it is specified as a workspace's customer-managed key for
	// workspace storage, the key encrypts the workspace's root S3 bucket (which
	// contains the workspace's root DBFS and system data) and, optionally, cluster
	// EBS volume data.
	//
	// **Important**: Customer-managed keys are supported only for some deployment
	// types, subscription types, and AWS regions that currently support creation of
	// Databricks workspaces.
	//
	// This operation is available only if your account is on the E2 version of the
	// platform or on a select custom plan that allows multiple workspaces per
	// account.
	Create(ctx context.Context, request CreateCustomerManagedKeyRequest) (*CustomerManagedKey, error)

	// Deletes a customer-managed key configuration object for an account. You
	// cannot delete a configuration that is associated with a running workspace.
	Delete(ctx context.Context, request DeleteEncryptionKeyRequest) (*CustomerManagedKey, error)

	// Deletes a customer-managed key configuration object for an account. You
	// cannot delete a configuration that is associated with a running workspace.
	DeleteByCustomerManagedKeyId(ctx context.Context, customerManagedKeyId string) (*CustomerManagedKey, error)

	// Gets a customer-managed key configuration object for an account, specified by
	// ID. This operation uploads a reference to a customer-managed key to
	// Databricks. If assigned as a workspace's customer-managed key for managed
	// services, Databricks uses the key to encrypt the workspaces notebooks and
	// secrets in the control plane, in addition to Databricks SQL queries and query
	// history. If it is specified as a workspace's customer-managed key for
	// storage, the key encrypts the workspace's root S3 bucket (which contains the
	// workspace's root DBFS and system data) and, optionally, cluster EBS volume
	// data.
	//
	// **Important**: Customer-managed keys are supported only for some deployment
	// types, subscription types, and AWS regions.
	//
	// This operation is available only if your account is on the E2 version of the
	// platform.",
	Get(ctx context.Context, request GetEncryptionKeyRequest) (*CustomerManagedKey, error)

	// Gets a customer-managed key configuration object for an account, specified by
	// ID. This operation uploads a reference to a customer-managed key to
	// Databricks. If assigned as a workspace's customer-managed key for managed
	// services, Databricks uses the key to encrypt the workspaces notebooks and
	// secrets in the control plane, in addition to Databricks SQL queries and query
	// history. If it is specified as a workspace's customer-managed key for
	// storage, the key encrypts the workspace's root S3 bucket (which contains the
	// workspace's root DBFS and system data) and, optionally, cluster EBS volume
	// data.
	//
	// **Important**: Customer-managed keys are supported only for some deployment
	// types, subscription types, and AWS regions.
	//
	// This operation is available only if your account is on the E2 version of the
	// platform.",
	GetByCustomerManagedKeyId(ctx context.Context, customerManagedKeyId string) (*CustomerManagedKey, error)

	// Lists Databricks customer-managed key configurations for an account.
	List(ctx context.Context) ([]CustomerManagedKey, error)
}

func NewEncryptionKeys(client *client.DatabricksClient) *EncryptionKeysAPI {
	return &EncryptionKeysAPI{
		encryptionKeysImpl: encryptionKeysImpl{
			client: client,
		},
	}
}

// These APIs manage encryption key configurations for this workspace
// (optional). A key configuration encapsulates the AWS KMS key information and
// some information about how the key configuration can be used. There are two
// possible uses for key configurations:
//
// * Managed services: A key configuration can be used to encrypt a workspace's
// notebook and secret data in the control plane, as well as Databricks SQL
// queries and query history. * Storage: A key configuration can be used to
// encrypt a workspace's DBFS and EBS data in the data plane.
//
// In both of these cases, the key configuration's ID is used when creating a
// new workspace. This Preview feature is available if your account is on the E2
// version of the platform. Updating a running workspace with workspace storage
// encryption requires that the workspace is on the E2 version of the platform.
// If you have an older workspace, it might not be on the E2 version of the
// platform. If you are not sure, contact your Databricks representative.
type EncryptionKeysAPI struct {
	encryptionKeysImpl
}

// Deletes a customer-managed key configuration object for an account. You
// cannot delete a configuration that is associated with a running workspace.
func (a *EncryptionKeysAPI) DeleteByCustomerManagedKeyId(ctx context.Context, customerManagedKeyId string) (*CustomerManagedKey, error) {
	return a.encryptionKeysImpl.Delete(ctx, DeleteEncryptionKeyRequest{
		CustomerManagedKeyId: customerManagedKeyId,
	})
}

// Gets a customer-managed key configuration object for an account, specified by
// ID. This operation uploads a reference to a customer-managed key to
// Databricks. If assigned as a workspace's customer-managed key for managed
// services, Databricks uses the key to encrypt the workspaces notebooks and
// secrets in the control plane, in addition to Databricks SQL queries and query
// history. If it is specified as a workspace's customer-managed key for
// storage, the key encrypts the workspace's root S3 bucket (which contains the
// workspace's root DBFS and system data) and, optionally, cluster EBS volume
// data.
//
// **Important**: Customer-managed keys are supported only for some deployment
// types, subscription types, and AWS regions.
//
// This operation is available only if your account is on the E2 version of the
// platform.",
func (a *EncryptionKeysAPI) GetByCustomerManagedKeyId(ctx context.Context, customerManagedKeyId string) (*CustomerManagedKey, error) {
	return a.encryptionKeysImpl.Get(ctx, GetEncryptionKeyRequest{
		CustomerManagedKeyId: customerManagedKeyId,
	})
}

type NetworksInterface interface {

	// Creates a Databricks network configuration that represents an VPC and its
	// resources. The VPC will be used for new Databricks clusters. This requires a
	// pre-existing VPC and subnets.
	Create(ctx context.Context, request CreateNetworkRequest) (*Network, error)

	// Deletes a Databricks network configuration, which represents a cloud VPC and
	// its resources. You cannot delete a network that is associated with a
	// workspace.
	//
	// This operation is available only if your account is on the E2 version of the
	// platform.
	Delete(ctx context.Context, request DeleteNetworkRequest) (*Network, error)

	// Deletes a Databricks network configuration, which represents a cloud VPC and
	// its resources. You cannot delete a network that is associated with a
	// workspace.
	//
	// This operation is available only if your account is on the E2 version of the
	// platform.
	DeleteByNetworkId(ctx context.Context, networkId string) (*Network, error)

	// Gets a Databricks network configuration, which represents a cloud VPC and its
	// resources.
	Get(ctx context.Context, request GetNetworkRequest) (*Network, error)

	// Gets a Databricks network configuration, which represents a cloud VPC and its
	// resources.
	GetByNetworkId(ctx context.Context, networkId string) (*Network, error)

	// Lists Databricks network configurations for an account.
	List(ctx context.Context) ([]Network, error)

	// NetworkNetworkNameToNetworkIdMap calls [NetworksAPI.List] and creates a map of results with [Network].NetworkName as key and [Network].NetworkId as value.
	//
	// Returns an error if there's more than one [Network] with the same .NetworkName.
	//
	// Note: All [Network] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	NetworkNetworkNameToNetworkIdMap(ctx context.Context) (map[string]string, error)

	// GetByNetworkName calls [NetworksAPI.NetworkNetworkNameToNetworkIdMap] and returns a single [Network].
	//
	// Returns an error if there's more than one [Network] with the same .NetworkName.
	//
	// Note: All [Network] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByNetworkName(ctx context.Context, name string) (*Network, error)
}

func NewNetworks(client *client.DatabricksClient) *NetworksAPI {
	return &NetworksAPI{
		networksImpl: networksImpl{
			client: client,
		},
	}
}

// These APIs manage network configurations for customer-managed VPCs
// (optional). Its ID is used when creating a new workspace if you use
// customer-managed VPCs.
type NetworksAPI struct {
	networksImpl
}

// Deletes a Databricks network configuration, which represents a cloud VPC and
// its resources. You cannot delete a network that is associated with a
// workspace.
//
// This operation is available only if your account is on the E2 version of the
// platform.
func (a *NetworksAPI) DeleteByNetworkId(ctx context.Context, networkId string) (*Network, error) {
	return a.networksImpl.Delete(ctx, DeleteNetworkRequest{
		NetworkId: networkId,
	})
}

// Gets a Databricks network configuration, which represents a cloud VPC and its
// resources.
func (a *NetworksAPI) GetByNetworkId(ctx context.Context, networkId string) (*Network, error) {
	return a.networksImpl.Get(ctx, GetNetworkRequest{
		NetworkId: networkId,
	})
}

// NetworkNetworkNameToNetworkIdMap calls [NetworksAPI.List] and creates a map of results with [Network].NetworkName as key and [Network].NetworkId as value.
//
// Returns an error if there's more than one [Network] with the same .NetworkName.
//
// Note: All [Network] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworksAPI) NetworkNetworkNameToNetworkIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.NetworkName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .NetworkName: %s", key)
		}
		mapping[key] = v.NetworkId
	}
	return mapping, nil
}

// GetByNetworkName calls [NetworksAPI.NetworkNetworkNameToNetworkIdMap] and returns a single [Network].
//
// Returns an error if there's more than one [Network] with the same .NetworkName.
//
// Note: All [Network] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworksAPI) GetByNetworkName(ctx context.Context, name string) (*Network, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Network{}
	for _, v := range result {
		key := v.NetworkName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Network named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Network named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type PrivateAccessInterface interface {

	// Creates a private access settings configuration, which represents network
	// access restrictions for workspace resources. Private access settings
	// configure whether workspaces can be accessed from the public internet or only
	// from private endpoints.
	Create(ctx context.Context, request CreatePrivateAccessSettingsRequest) (*PrivateAccessSettings, error)

	// Deletes a Databricks private access settings configuration, both specified by
	// ID.
	Delete(ctx context.Context, request DeletePrivateAccesRequest) (*PrivateAccessSettings, error)

	// Deletes a Databricks private access settings configuration, both specified by
	// ID.
	DeleteByPrivateAccessSettingsId(ctx context.Context, privateAccessSettingsId string) (*PrivateAccessSettings, error)

	// Gets a Databricks private access settings configuration, both specified by
	// ID.
	Get(ctx context.Context, request GetPrivateAccesRequest) (*PrivateAccessSettings, error)

	// Gets a Databricks private access settings configuration, both specified by
	// ID.
	GetByPrivateAccessSettingsId(ctx context.Context, privateAccessSettingsId string) (*PrivateAccessSettings, error)

	// Lists Databricks private access settings for an account.
	List(ctx context.Context) ([]PrivateAccessSettings, error)

	// PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap calls [PrivateAccessAPI.List] and creates a map of results with [PrivateAccessSettings].PrivateAccessSettingsName as key and [PrivateAccessSettings].PrivateAccessSettingsId as value.
	//
	// Returns an error if there's more than one [PrivateAccessSettings] with the same .PrivateAccessSettingsName.
	//
	// Note: All [PrivateAccessSettings] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap(ctx context.Context) (map[string]string, error)

	// GetByPrivateAccessSettingsName calls [PrivateAccessAPI.PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap] and returns a single [PrivateAccessSettings].
	//
	// Returns an error if there's more than one [PrivateAccessSettings] with the same .PrivateAccessSettingsName.
	//
	// Note: All [PrivateAccessSettings] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByPrivateAccessSettingsName(ctx context.Context, name string) (*PrivateAccessSettings, error)

	// Updates an existing private access settings object, which specifies how your
	// workspace is accessed over AWS PrivateLink. To use AWS PrivateLink, a
	// workspace must have a private access settings object referenced by ID in the
	// workspace's private_access_settings_id property. This operation completely
	// overwrites your existing private access settings object attached to your
	// workspaces. All workspaces attached to the private access settings are
	// affected by any change. If public_access_enabled, private_access_level, or
	// allowed_vpc_endpoint_ids are updated, effects of these changes might take
	// several minutes to propagate to the workspace API. You can share one private
	// access settings object with multiple workspaces in a single account. However,
	// private access settings are specific to AWS regions, so only workspaces in
	// the same AWS region can use a given private access settings object. Before
	// configuring PrivateLink, read the Databricks article about PrivateLink.
	Replace(ctx context.Context, request ReplacePrivateAccessSettingsRequest) (*PrivateAccessSettings, error)
}

func NewPrivateAccess(client *client.DatabricksClient) *PrivateAccessAPI {
	return &PrivateAccessAPI{
		privateAccessImpl: privateAccessImpl{
			client: client,
		},
	}
}

// These APIs manage private access settings for this account.
type PrivateAccessAPI struct {
	privateAccessImpl
}

// Deletes a Databricks private access settings configuration, both specified by
// ID.
func (a *PrivateAccessAPI) DeleteByPrivateAccessSettingsId(ctx context.Context, privateAccessSettingsId string) (*PrivateAccessSettings, error) {
	return a.privateAccessImpl.Delete(ctx, DeletePrivateAccesRequest{
		PrivateAccessSettingsId: privateAccessSettingsId,
	})
}

// Gets a Databricks private access settings configuration, both specified by
// ID.
func (a *PrivateAccessAPI) GetByPrivateAccessSettingsId(ctx context.Context, privateAccessSettingsId string) (*PrivateAccessSettings, error) {
	return a.privateAccessImpl.Get(ctx, GetPrivateAccesRequest{
		PrivateAccessSettingsId: privateAccessSettingsId,
	})
}

// PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap calls [PrivateAccessAPI.List] and creates a map of results with [PrivateAccessSettings].PrivateAccessSettingsName as key and [PrivateAccessSettings].PrivateAccessSettingsId as value.
//
// Returns an error if there's more than one [PrivateAccessSettings] with the same .PrivateAccessSettingsName.
//
// Note: All [PrivateAccessSettings] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *PrivateAccessAPI) PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.PrivateAccessSettingsName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .PrivateAccessSettingsName: %s", key)
		}
		mapping[key] = v.PrivateAccessSettingsId
	}
	return mapping, nil
}

// GetByPrivateAccessSettingsName calls [PrivateAccessAPI.PrivateAccessSettingsPrivateAccessSettingsNameToPrivateAccessSettingsIdMap] and returns a single [PrivateAccessSettings].
//
// Returns an error if there's more than one [PrivateAccessSettings] with the same .PrivateAccessSettingsName.
//
// Note: All [PrivateAccessSettings] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *PrivateAccessAPI) GetByPrivateAccessSettingsName(ctx context.Context, name string) (*PrivateAccessSettings, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PrivateAccessSettings{}
	for _, v := range result {
		key := v.PrivateAccessSettingsName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PrivateAccessSettings named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PrivateAccessSettings named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type StorageInterface interface {

	// Creates a Databricks storage configuration for an account.
	Create(ctx context.Context, request CreateStorageConfigurationRequest) (*StorageConfiguration, error)

	// Deletes a Databricks storage configuration. You cannot delete a storage
	// configuration that is associated with any workspace.
	Delete(ctx context.Context, request DeleteStorageRequest) (*StorageConfiguration, error)

	// Deletes a Databricks storage configuration. You cannot delete a storage
	// configuration that is associated with any workspace.
	DeleteByStorageConfigurationId(ctx context.Context, storageConfigurationId string) (*StorageConfiguration, error)

	// Gets a Databricks storage configuration for an account, both specified by ID.
	Get(ctx context.Context, request GetStorageRequest) (*StorageConfiguration, error)

	// Gets a Databricks storage configuration for an account, both specified by ID.
	GetByStorageConfigurationId(ctx context.Context, storageConfigurationId string) (*StorageConfiguration, error)

	// Lists Databricks storage configurations for an account, specified by ID.
	List(ctx context.Context) ([]StorageConfiguration, error)

	// StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap calls [StorageAPI.List] and creates a map of results with [StorageConfiguration].StorageConfigurationName as key and [StorageConfiguration].StorageConfigurationId as value.
	//
	// Returns an error if there's more than one [StorageConfiguration] with the same .StorageConfigurationName.
	//
	// Note: All [StorageConfiguration] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap(ctx context.Context) (map[string]string, error)

	// GetByStorageConfigurationName calls [StorageAPI.StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap] and returns a single [StorageConfiguration].
	//
	// Returns an error if there's more than one [StorageConfiguration] with the same .StorageConfigurationName.
	//
	// Note: All [StorageConfiguration] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByStorageConfigurationName(ctx context.Context, name string) (*StorageConfiguration, error)
}

func NewStorage(client *client.DatabricksClient) *StorageAPI {
	return &StorageAPI{
		storageImpl: storageImpl{
			client: client,
		},
	}
}

// These APIs manage storage configurations for this workspace. A root storage
// S3 bucket in your account is required to store objects like cluster logs,
// notebook revisions, and job results. You can also use the root storage S3
// bucket for storage of non-production DBFS data. A storage configuration
// encapsulates this bucket information, and its ID is used when creating a new
// workspace.
type StorageAPI struct {
	storageImpl
}

// Deletes a Databricks storage configuration. You cannot delete a storage
// configuration that is associated with any workspace.
func (a *StorageAPI) DeleteByStorageConfigurationId(ctx context.Context, storageConfigurationId string) (*StorageConfiguration, error) {
	return a.storageImpl.Delete(ctx, DeleteStorageRequest{
		StorageConfigurationId: storageConfigurationId,
	})
}

// Gets a Databricks storage configuration for an account, both specified by ID.
func (a *StorageAPI) GetByStorageConfigurationId(ctx context.Context, storageConfigurationId string) (*StorageConfiguration, error) {
	return a.storageImpl.Get(ctx, GetStorageRequest{
		StorageConfigurationId: storageConfigurationId,
	})
}

// StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap calls [StorageAPI.List] and creates a map of results with [StorageConfiguration].StorageConfigurationName as key and [StorageConfiguration].StorageConfigurationId as value.
//
// Returns an error if there's more than one [StorageConfiguration] with the same .StorageConfigurationName.
//
// Note: All [StorageConfiguration] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *StorageAPI) StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.StorageConfigurationName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .StorageConfigurationName: %s", key)
		}
		mapping[key] = v.StorageConfigurationId
	}
	return mapping, nil
}

// GetByStorageConfigurationName calls [StorageAPI.StorageConfigurationStorageConfigurationNameToStorageConfigurationIdMap] and returns a single [StorageConfiguration].
//
// Returns an error if there's more than one [StorageConfiguration] with the same .StorageConfigurationName.
//
// Note: All [StorageConfiguration] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *StorageAPI) GetByStorageConfigurationName(ctx context.Context, name string) (*StorageConfiguration, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]StorageConfiguration{}
	for _, v := range result {
		key := v.StorageConfigurationName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("StorageConfiguration named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of StorageConfiguration named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type VpcEndpointsInterface interface {

	// Creates a VPC endpoint configuration, which represents a [VPC endpoint]
	// object in AWS used to communicate privately with Databricks over [AWS
	// PrivateLink].
	//
	// After you create the VPC endpoint configuration, the Databricks [endpoint
	// service] automatically accepts the VPC endpoint.
	//
	// Before configuring PrivateLink, read the [Databricks article about
	// PrivateLink].
	//
	// [AWS PrivateLink]: https://aws.amazon.com/privatelink
	// [Databricks article about PrivateLink]: https://docs.databricks.com/administration-guide/cloud-configurations/aws/privatelink.html
	// [VPC endpoint]: https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints.html
	// [endpoint service]: https://docs.aws.amazon.com/vpc/latest/privatelink/privatelink-share-your-services.html
	Create(ctx context.Context, request CreateVpcEndpointRequest) (*VpcEndpoint, error)

	// Deletes a Databricks VPC endpoint configuration. You cannot delete a VPC
	// endpoint configuration that is associated with any workspace.
	Delete(ctx context.Context, request DeleteVpcEndpointRequest) (*VpcEndpoint, error)

	// Deletes a Databricks VPC endpoint configuration. You cannot delete a VPC
	// endpoint configuration that is associated with any workspace.
	DeleteByVpcEndpointId(ctx context.Context, vpcEndpointId string) (*VpcEndpoint, error)

	// Gets a VPC endpoint configuration, which represents a [VPC endpoint] object
	// in AWS used to communicate privately with Databricks over [AWS PrivateLink].
	//
	// [AWS PrivateLink]: https://aws.amazon.com/privatelink
	// [VPC endpoint]: https://docs.aws.amazon.com/vpc/latest/privatelink/concepts.html
	Get(ctx context.Context, request GetVpcEndpointRequest) (*VpcEndpoint, error)

	// Gets a VPC endpoint configuration, which represents a [VPC endpoint] object
	// in AWS used to communicate privately with Databricks over [AWS PrivateLink].
	//
	// [AWS PrivateLink]: https://aws.amazon.com/privatelink
	// [VPC endpoint]: https://docs.aws.amazon.com/vpc/latest/privatelink/concepts.html
	GetByVpcEndpointId(ctx context.Context, vpcEndpointId string) (*VpcEndpoint, error)

	// Lists Databricks VPC endpoint configurations for an account.
	List(ctx context.Context) ([]VpcEndpoint, error)

	// VpcEndpointVpcEndpointNameToVpcEndpointIdMap calls [VpcEndpointsAPI.List] and creates a map of results with [VpcEndpoint].VpcEndpointName as key and [VpcEndpoint].VpcEndpointId as value.
	//
	// Returns an error if there's more than one [VpcEndpoint] with the same .VpcEndpointName.
	//
	// Note: All [VpcEndpoint] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	VpcEndpointVpcEndpointNameToVpcEndpointIdMap(ctx context.Context) (map[string]string, error)

	// GetByVpcEndpointName calls [VpcEndpointsAPI.VpcEndpointVpcEndpointNameToVpcEndpointIdMap] and returns a single [VpcEndpoint].
	//
	// Returns an error if there's more than one [VpcEndpoint] with the same .VpcEndpointName.
	//
	// Note: All [VpcEndpoint] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByVpcEndpointName(ctx context.Context, name string) (*VpcEndpoint, error)
}

func NewVpcEndpoints(client *client.DatabricksClient) *VpcEndpointsAPI {
	return &VpcEndpointsAPI{
		vpcEndpointsImpl: vpcEndpointsImpl{
			client: client,
		},
	}
}

// These APIs manage VPC endpoint configurations for this account.
type VpcEndpointsAPI struct {
	vpcEndpointsImpl
}

// Deletes a Databricks VPC endpoint configuration. You cannot delete a VPC
// endpoint configuration that is associated with any workspace.
func (a *VpcEndpointsAPI) DeleteByVpcEndpointId(ctx context.Context, vpcEndpointId string) (*VpcEndpoint, error) {
	return a.vpcEndpointsImpl.Delete(ctx, DeleteVpcEndpointRequest{
		VpcEndpointId: vpcEndpointId,
	})
}

// Gets a VPC endpoint configuration, which represents a [VPC endpoint] object
// in AWS used to communicate privately with Databricks over [AWS PrivateLink].
//
// [AWS PrivateLink]: https://aws.amazon.com/privatelink
// [VPC endpoint]: https://docs.aws.amazon.com/vpc/latest/privatelink/concepts.html
func (a *VpcEndpointsAPI) GetByVpcEndpointId(ctx context.Context, vpcEndpointId string) (*VpcEndpoint, error) {
	return a.vpcEndpointsImpl.Get(ctx, GetVpcEndpointRequest{
		VpcEndpointId: vpcEndpointId,
	})
}

// VpcEndpointVpcEndpointNameToVpcEndpointIdMap calls [VpcEndpointsAPI.List] and creates a map of results with [VpcEndpoint].VpcEndpointName as key and [VpcEndpoint].VpcEndpointId as value.
//
// Returns an error if there's more than one [VpcEndpoint] with the same .VpcEndpointName.
//
// Note: All [VpcEndpoint] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VpcEndpointsAPI) VpcEndpointVpcEndpointNameToVpcEndpointIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.VpcEndpointName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .VpcEndpointName: %s", key)
		}
		mapping[key] = v.VpcEndpointId
	}
	return mapping, nil
}

// GetByVpcEndpointName calls [VpcEndpointsAPI.VpcEndpointVpcEndpointNameToVpcEndpointIdMap] and returns a single [VpcEndpoint].
//
// Returns an error if there's more than one [VpcEndpoint] with the same .VpcEndpointName.
//
// Note: All [VpcEndpoint] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VpcEndpointsAPI) GetByVpcEndpointName(ctx context.Context, name string) (*VpcEndpoint, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]VpcEndpoint{}
	for _, v := range result {
		key := v.VpcEndpointName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("VpcEndpoint named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of VpcEndpoint named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type WorkspacesInterface interface {

	// WaitGetWorkspaceRunning repeatedly calls [WorkspacesAPI.Get] and waits to reach RUNNING state
	WaitGetWorkspaceRunning(ctx context.Context, workspaceId int64,
		timeout time.Duration, callback func(*Workspace)) (*Workspace, error)

	// Creates a new workspace using a credential configuration and a storage
	// configuration, an optional network configuration (if using a customer-managed
	// VPC), an optional managed services key configuration (if using
	// customer-managed keys for managed services), and an optional storage key
	// configuration (if using customer-managed keys for storage). The key
	// configurations used for managed services and storage encryption can be the
	// same or different.
	//
	// Important: This operation is asynchronous. A response with HTTP status code
	// 200 means the request has been accepted and is in progress, but does not mean
	// that the workspace deployed successfully and is running. The initial
	// workspace status is typically PROVISIONING. Use the workspace ID
	// (workspace_id) field in the response to identify the new workspace and make
	// repeated GET requests with the workspace ID and check its status. The
	// workspace becomes available when the status changes to RUNNING.
	//
	// You can share one customer-managed VPC with multiple workspaces in a single
	// account. It is not required to create a new VPC for each workspace. However,
	// you cannot reuse subnets or Security Groups between workspaces. If you plan
	// to share one VPC with multiple workspaces, make sure you size your VPC and
	// subnets accordingly. Because a Databricks Account API network configuration
	// encapsulates this information, you cannot reuse a Databricks Account API
	// network configuration across workspaces.
	//
	// For information about how to create a new workspace with this API including
	// error handling, see [Create a new workspace using the Account API].
	//
	// Important: Customer-managed VPCs, PrivateLink, and customer-managed keys are
	// supported on a limited set of deployment and subscription types. If you have
	// questions about availability, contact your Databricks representative.
	//
	// This operation is available only if your account is on the E2 version of the
	// platform or on a select custom plan that allows multiple workspaces per
	// account.
	//
	// [Create a new workspace using the Account API]: http://docs.databricks.com/administration-guide/account-api/new-workspace.html
	Create(ctx context.Context, createWorkspaceRequest CreateWorkspaceRequest) (*WaitGetWorkspaceRunning[Workspace], error)

	// Calls [WorkspacesAPIInterface.Create] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[Workspace](60*time.Minute) functional option.
	//
	// Deprecated: use [WorkspacesAPIInterface.Create].Get() or [WorkspacesAPIInterface.WaitGetWorkspaceRunning]
	CreateAndWait(ctx context.Context, createWorkspaceRequest CreateWorkspaceRequest, options ...retries.Option[Workspace]) (*Workspace, error)

	// Deletes a Databricks workspace, both specified by ID.
	Delete(ctx context.Context, request DeleteWorkspaceRequest) (*Workspace, error)

	// Deletes a Databricks workspace, both specified by ID.
	DeleteByWorkspaceId(ctx context.Context, workspaceId int64) (*Workspace, error)

	// Gets information including status for a Databricks workspace, specified by
	// ID. In the response, the `workspace_status` field indicates the current
	// status. After initial workspace creation (which is asynchronous), make
	// repeated `GET` requests with the workspace ID and check its status. The
	// workspace becomes available when the status changes to `RUNNING`. For
	// information about how to create a new workspace with this API **including
	// error handling**, see [Create a new workspace using the Account API].
	//
	// [Create a new workspace using the Account API]: http://docs.databricks.com/administration-guide/account-api/new-workspace.html
	Get(ctx context.Context, request GetWorkspaceRequest) (*Workspace, error)

	// Gets information including status for a Databricks workspace, specified by
	// ID. In the response, the `workspace_status` field indicates the current
	// status. After initial workspace creation (which is asynchronous), make
	// repeated `GET` requests with the workspace ID and check its status. The
	// workspace becomes available when the status changes to `RUNNING`. For
	// information about how to create a new workspace with this API **including
	// error handling**, see [Create a new workspace using the Account API].
	//
	// [Create a new workspace using the Account API]: http://docs.databricks.com/administration-guide/account-api/new-workspace.html
	GetByWorkspaceId(ctx context.Context, workspaceId int64) (*Workspace, error)

	// Lists Databricks workspaces for an account.
	List(ctx context.Context) ([]Workspace, error)

	// WorkspaceWorkspaceNameToWorkspaceIdMap calls [WorkspacesAPI.List] and creates a map of results with [Workspace].WorkspaceName as key and [Workspace].WorkspaceId as value.
	//
	// Returns an error if there's more than one [Workspace] with the same .WorkspaceName.
	//
	// Note: All [Workspace] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	WorkspaceWorkspaceNameToWorkspaceIdMap(ctx context.Context) (map[string]int64, error)

	// GetByWorkspaceName calls [WorkspacesAPI.WorkspaceWorkspaceNameToWorkspaceIdMap] and returns a single [Workspace].
	//
	// Returns an error if there's more than one [Workspace] with the same .WorkspaceName.
	//
	// Note: All [Workspace] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByWorkspaceName(ctx context.Context, name string) (*Workspace, error)

	// Updates a workspace.
	Update(ctx context.Context, updateWorkspaceRequest UpdateWorkspaceRequest) (*WaitGetWorkspaceRunning[Workspace], error)

	// Calls [WorkspacesAPIInterface.Update] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[Workspace](60*time.Minute) functional option.
	//
	// Deprecated: use [WorkspacesAPIInterface.Update].Get() or [WorkspacesAPIInterface.WaitGetWorkspaceRunning]
	UpdateAndWait(ctx context.Context, updateWorkspaceRequest UpdateWorkspaceRequest, options ...retries.Option[Workspace]) (*Workspace, error)
}

func NewWorkspaces(client *client.DatabricksClient) *WorkspacesAPI {
	return &WorkspacesAPI{
		workspacesImpl: workspacesImpl{
			client: client,
		},
	}
}

// These APIs manage workspaces for this account. A Databricks workspace is an
// environment for accessing all of your Databricks assets. The workspace
// organizes objects (notebooks, libraries, and experiments) into folders, and
// provides access to data and computational resources such as clusters and
// jobs.
//
// These endpoints are available if your account is on the E2 version of the
// platform or on a select custom plan that allows multiple workspaces per
// account.
type WorkspacesAPI struct {
	workspacesImpl
}

// WaitGetWorkspaceRunning repeatedly calls [WorkspacesAPI.Get] and waits to reach RUNNING state
func (a *WorkspacesAPI) WaitGetWorkspaceRunning(ctx context.Context, workspaceId int64,
	timeout time.Duration, callback func(*Workspace)) (*Workspace, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[Workspace](ctx, timeout, func() (*Workspace, *retries.Err) {
		workspace, err := a.Get(ctx, GetWorkspaceRequest{
			WorkspaceId: workspaceId,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(workspace)
		}
		status := workspace.WorkspaceStatus
		statusMessage := workspace.WorkspaceStatusMessage
		switch status {
		case WorkspaceStatusRunning: // target state
			return workspace, nil
		case WorkspaceStatusBanned, WorkspaceStatusFailed:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				WorkspaceStatusRunning, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetWorkspaceRunning is a wrapper that calls [WorkspacesAPI.WaitGetWorkspaceRunning] and waits to reach RUNNING state.
type WaitGetWorkspaceRunning[R any] struct {
	Response    *R
	WorkspaceId int64 `json:"workspace_id"`
	Poll        func(time.Duration, func(*Workspace)) (*Workspace, error)
	callback    func(*Workspace)
	timeout     time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetWorkspaceRunning[R]) OnProgress(callback func(*Workspace)) *WaitGetWorkspaceRunning[R] {
	w.callback = callback
	return w
}

// Get the Workspace with the default timeout of 20 minutes.
func (w *WaitGetWorkspaceRunning[R]) Get() (*Workspace, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the Workspace with custom timeout.
func (w *WaitGetWorkspaceRunning[R]) GetWithTimeout(timeout time.Duration) (*Workspace, error) {
	return w.Poll(timeout, w.callback)
}

// Creates a new workspace using a credential configuration and a storage
// configuration, an optional network configuration (if using a customer-managed
// VPC), an optional managed services key configuration (if using
// customer-managed keys for managed services), and an optional storage key
// configuration (if using customer-managed keys for storage). The key
// configurations used for managed services and storage encryption can be the
// same or different.
//
// Important: This operation is asynchronous. A response with HTTP status code
// 200 means the request has been accepted and is in progress, but does not mean
// that the workspace deployed successfully and is running. The initial
// workspace status is typically PROVISIONING. Use the workspace ID
// (workspace_id) field in the response to identify the new workspace and make
// repeated GET requests with the workspace ID and check its status. The
// workspace becomes available when the status changes to RUNNING.
//
// You can share one customer-managed VPC with multiple workspaces in a single
// account. It is not required to create a new VPC for each workspace. However,
// you cannot reuse subnets or Security Groups between workspaces. If you plan
// to share one VPC with multiple workspaces, make sure you size your VPC and
// subnets accordingly. Because a Databricks Account API network configuration
// encapsulates this information, you cannot reuse a Databricks Account API
// network configuration across workspaces.
//
// For information about how to create a new workspace with this API including
// error handling, see [Create a new workspace using the Account API].
//
// Important: Customer-managed VPCs, PrivateLink, and customer-managed keys are
// supported on a limited set of deployment and subscription types. If you have
// questions about availability, contact your Databricks representative.
//
// This operation is available only if your account is on the E2 version of the
// platform or on a select custom plan that allows multiple workspaces per
// account.
//
// [Create a new workspace using the Account API]: http://docs.databricks.com/administration-guide/account-api/new-workspace.html
func (a *WorkspacesAPI) Create(ctx context.Context, createWorkspaceRequest CreateWorkspaceRequest) (*WaitGetWorkspaceRunning[Workspace], error) {
	workspace, err := a.workspacesImpl.Create(ctx, createWorkspaceRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWorkspaceRunning[Workspace]{
		Response:    workspace,
		WorkspaceId: workspace.WorkspaceId,
		Poll: func(timeout time.Duration, callback func(*Workspace)) (*Workspace, error) {
			return a.WaitGetWorkspaceRunning(ctx, workspace.WorkspaceId, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WorkspacesAPI.Create] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[Workspace](60*time.Minute) functional option.
//
// Deprecated: use [WorkspacesAPI.Create].Get() or [WorkspacesAPI.WaitGetWorkspaceRunning]
func (a *WorkspacesAPI) CreateAndWait(ctx context.Context, createWorkspaceRequest CreateWorkspaceRequest, options ...retries.Option[Workspace]) (*Workspace, error) {
	wait, err := a.Create(ctx, createWorkspaceRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[Workspace]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *Workspace) {
		for _, o := range options {
			o(&retries.Info[Workspace]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Deletes a Databricks workspace, both specified by ID.
func (a *WorkspacesAPI) DeleteByWorkspaceId(ctx context.Context, workspaceId int64) (*Workspace, error) {
	return a.workspacesImpl.Delete(ctx, DeleteWorkspaceRequest{
		WorkspaceId: workspaceId,
	})
}

// Gets information including status for a Databricks workspace, specified by
// ID. In the response, the `workspace_status` field indicates the current
// status. After initial workspace creation (which is asynchronous), make
// repeated `GET` requests with the workspace ID and check its status. The
// workspace becomes available when the status changes to `RUNNING`. For
// information about how to create a new workspace with this API **including
// error handling**, see [Create a new workspace using the Account API].
//
// [Create a new workspace using the Account API]: http://docs.databricks.com/administration-guide/account-api/new-workspace.html
func (a *WorkspacesAPI) GetByWorkspaceId(ctx context.Context, workspaceId int64) (*Workspace, error) {
	return a.workspacesImpl.Get(ctx, GetWorkspaceRequest{
		WorkspaceId: workspaceId,
	})
}

// WorkspaceWorkspaceNameToWorkspaceIdMap calls [WorkspacesAPI.List] and creates a map of results with [Workspace].WorkspaceName as key and [Workspace].WorkspaceId as value.
//
// Returns an error if there's more than one [Workspace] with the same .WorkspaceName.
//
// Note: All [Workspace] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WorkspacesAPI) WorkspaceWorkspaceNameToWorkspaceIdMap(ctx context.Context) (map[string]int64, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]int64{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.WorkspaceName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .WorkspaceName: %s", key)
		}
		mapping[key] = v.WorkspaceId
	}
	return mapping, nil
}

// GetByWorkspaceName calls [WorkspacesAPI.WorkspaceWorkspaceNameToWorkspaceIdMap] and returns a single [Workspace].
//
// Returns an error if there's more than one [Workspace] with the same .WorkspaceName.
//
// Note: All [Workspace] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WorkspacesAPI) GetByWorkspaceName(ctx context.Context, name string) (*Workspace, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Workspace{}
	for _, v := range result {
		key := v.WorkspaceName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Workspace named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Workspace named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Updates a workspace.
func (a *WorkspacesAPI) Update(ctx context.Context, updateWorkspaceRequest UpdateWorkspaceRequest) (*WaitGetWorkspaceRunning[Workspace], error) {
	workspace, err := a.workspacesImpl.Update(ctx, updateWorkspaceRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWorkspaceRunning[Workspace]{
		Response:    workspace,
		WorkspaceId: workspace.WorkspaceId,
		Poll: func(timeout time.Duration, callback func(*Workspace)) (*Workspace, error) {
			return a.WaitGetWorkspaceRunning(ctx, workspace.WorkspaceId, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WorkspacesAPI.Update] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[Workspace](60*time.Minute) functional option.
//
// Deprecated: use [WorkspacesAPI.Update].Get() or [WorkspacesAPI.WaitGetWorkspaceRunning]
func (a *WorkspacesAPI) UpdateAndWait(ctx context.Context, updateWorkspaceRequest UpdateWorkspaceRequest, options ...retries.Option[Workspace]) (*Workspace, error) {
	wait, err := a.Update(ctx, updateWorkspaceRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[Workspace]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *Workspace) {
		for _, o := range options {
			o(&retries.Info[Workspace]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}
