// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// The Postgres API provides access to a Postgres database via REST API or
// direct SQL.
package postgres

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/experimental/api"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type PostgresInterface interface {
	CreateBranch(ctx context.Context, request CreateBranchRequest) (CreateBranchOperationInterface, error)

	CreateEndpoint(ctx context.Context, request CreateEndpointRequest) (CreateEndpointOperationInterface, error)

	CreateProject(ctx context.Context, request CreateProjectRequest) (CreateProjectOperationInterface, error)

	CreateRole(ctx context.Context, request CreateRoleRequest) (CreateRoleOperationInterface, error)

	DeleteBranch(ctx context.Context, request DeleteBranchRequest) (DeleteBranchOperationInterface, error)

	DeleteEndpoint(ctx context.Context, request DeleteEndpointRequest) (DeleteEndpointOperationInterface, error)

	DeleteProject(ctx context.Context, request DeleteProjectRequest) (DeleteProjectOperationInterface, error)

	DeleteRole(ctx context.Context, request DeleteRoleRequest) (DeleteRoleOperationInterface, error)

	// Get a Branch.
	GetBranch(ctx context.Context, request GetBranchRequest) (*Branch, error)

	// Get an Endpoint.
	GetEndpoint(ctx context.Context, request GetEndpointRequest) (*Endpoint, error)

	// Get an Operation.
	GetOperation(ctx context.Context, request GetOperationRequest) (*Operation, error)

	// Get a Project.
	GetProject(ctx context.Context, request GetProjectRequest) (*Project, error)

	// Get a Role.
	GetRole(ctx context.Context, request GetRoleRequest) (*Role, error)

	// List Branches.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListBranches(ctx context.Context, request ListBranchesRequest) listing.Iterator[Branch]

	// List Branches.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListBranchesAll(ctx context.Context, request ListBranchesRequest) ([]Branch, error)

	// List Endpoints.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListEndpoints(ctx context.Context, request ListEndpointsRequest) listing.Iterator[Endpoint]

	// List Endpoints.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListEndpointsAll(ctx context.Context, request ListEndpointsRequest) ([]Endpoint, error)

	// List Projects.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListProjects(ctx context.Context, request ListProjectsRequest) listing.Iterator[Project]

	// List Projects.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListProjectsAll(ctx context.Context, request ListProjectsRequest) ([]Project, error)

	// List Roles.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListRoles(ctx context.Context, request ListRolesRequest) listing.Iterator[Role]

	// List Roles.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListRolesAll(ctx context.Context, request ListRolesRequest) ([]Role, error)

	UpdateBranch(ctx context.Context, request UpdateBranchRequest) (UpdateBranchOperationInterface, error)

	UpdateEndpoint(ctx context.Context, request UpdateEndpointRequest) (UpdateEndpointOperationInterface, error)

	UpdateProject(ctx context.Context, request UpdateProjectRequest) (UpdateProjectOperationInterface, error)
}

func NewPostgres(client *client.DatabricksClient) *PostgresAPI {
	return &PostgresAPI{
		postgresImpl: postgresImpl{
			client: client,
		},
	}
}

// The Postgres API provides access to a Postgres database via REST API or
// direct SQL.
type PostgresAPI struct {
	postgresImpl
}

func (a *PostgresAPI) CreateBranch(ctx context.Context, request CreateBranchRequest) (CreateBranchOperationInterface, error) {
	operation, err := a.postgresImpl.CreateBranch(ctx, request)
	if err != nil {
		return nil, err
	}
	return &createBranchOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type CreateBranchOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) (*Branch, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*BranchOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type createBranchOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *createBranchOperation) Wait(ctx context.Context, opts ...api.Option) (*Branch, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")
	var result *Branch
	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		var branch Branch
		err = json.Unmarshal(operation.Response, &branch)
		if err != nil {
			return fmt.Errorf("failed to unmarshal branch response: %w", err)
		}

		result = &branch

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	if err != nil {
		return nil, err
	}
	return result, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *createBranchOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *createBranchOperation) Metadata() (*BranchOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata BranchOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *createBranchOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) CreateEndpoint(ctx context.Context, request CreateEndpointRequest) (CreateEndpointOperationInterface, error) {
	operation, err := a.postgresImpl.CreateEndpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return &createEndpointOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type CreateEndpointOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) (*Endpoint, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*EndpointOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type createEndpointOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *createEndpointOperation) Wait(ctx context.Context, opts ...api.Option) (*Endpoint, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")
	var result *Endpoint
	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		var endpoint Endpoint
		err = json.Unmarshal(operation.Response, &endpoint)
		if err != nil {
			return fmt.Errorf("failed to unmarshal endpoint response: %w", err)
		}

		result = &endpoint

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	if err != nil {
		return nil, err
	}
	return result, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *createEndpointOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *createEndpointOperation) Metadata() (*EndpointOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata EndpointOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *createEndpointOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) CreateProject(ctx context.Context, request CreateProjectRequest) (CreateProjectOperationInterface, error) {
	operation, err := a.postgresImpl.CreateProject(ctx, request)
	if err != nil {
		return nil, err
	}
	return &createProjectOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type CreateProjectOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) (*Project, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*ProjectOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type createProjectOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *createProjectOperation) Wait(ctx context.Context, opts ...api.Option) (*Project, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")
	var result *Project
	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		var project Project
		err = json.Unmarshal(operation.Response, &project)
		if err != nil {
			return fmt.Errorf("failed to unmarshal project response: %w", err)
		}

		result = &project

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	if err != nil {
		return nil, err
	}
	return result, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *createProjectOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *createProjectOperation) Metadata() (*ProjectOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata ProjectOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *createProjectOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) CreateRole(ctx context.Context, request CreateRoleRequest) (CreateRoleOperationInterface, error) {
	operation, err := a.postgresImpl.CreateRole(ctx, request)
	if err != nil {
		return nil, err
	}
	return &createRoleOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type CreateRoleOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) (*Role, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*RoleOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type createRoleOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *createRoleOperation) Wait(ctx context.Context, opts ...api.Option) (*Role, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")
	var result *Role
	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		var role Role
		err = json.Unmarshal(operation.Response, &role)
		if err != nil {
			return fmt.Errorf("failed to unmarshal role response: %w", err)
		}

		result = &role

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	if err != nil {
		return nil, err
	}
	return result, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *createRoleOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *createRoleOperation) Metadata() (*RoleOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata RoleOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *createRoleOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) DeleteBranch(ctx context.Context, request DeleteBranchRequest) (DeleteBranchOperationInterface, error) {
	operation, err := a.postgresImpl.DeleteBranch(ctx, request)
	if err != nil {
		return nil, err
	}
	return &deleteBranchOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type DeleteBranchOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) error

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*BranchOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type deleteBranchOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *deleteBranchOperation) Wait(ctx context.Context, opts ...api.Option) error {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")

	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	return err

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *deleteBranchOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *deleteBranchOperation) Metadata() (*BranchOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata BranchOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *deleteBranchOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) DeleteEndpoint(ctx context.Context, request DeleteEndpointRequest) (DeleteEndpointOperationInterface, error) {
	operation, err := a.postgresImpl.DeleteEndpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return &deleteEndpointOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type DeleteEndpointOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) error

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*EndpointOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type deleteEndpointOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *deleteEndpointOperation) Wait(ctx context.Context, opts ...api.Option) error {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")

	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	return err

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *deleteEndpointOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *deleteEndpointOperation) Metadata() (*EndpointOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata EndpointOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *deleteEndpointOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) DeleteProject(ctx context.Context, request DeleteProjectRequest) (DeleteProjectOperationInterface, error) {
	operation, err := a.postgresImpl.DeleteProject(ctx, request)
	if err != nil {
		return nil, err
	}
	return &deleteProjectOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type DeleteProjectOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) error

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*ProjectOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type deleteProjectOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *deleteProjectOperation) Wait(ctx context.Context, opts ...api.Option) error {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")

	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	return err

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *deleteProjectOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *deleteProjectOperation) Metadata() (*ProjectOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata ProjectOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *deleteProjectOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) DeleteRole(ctx context.Context, request DeleteRoleRequest) (DeleteRoleOperationInterface, error) {
	operation, err := a.postgresImpl.DeleteRole(ctx, request)
	if err != nil {
		return nil, err
	}
	return &deleteRoleOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type DeleteRoleOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) error

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*RoleOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type deleteRoleOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *deleteRoleOperation) Wait(ctx context.Context, opts ...api.Option) error {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")

	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	return err

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *deleteRoleOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *deleteRoleOperation) Metadata() (*RoleOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata RoleOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *deleteRoleOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) UpdateBranch(ctx context.Context, request UpdateBranchRequest) (UpdateBranchOperationInterface, error) {
	operation, err := a.postgresImpl.UpdateBranch(ctx, request)
	if err != nil {
		return nil, err
	}
	return &updateBranchOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type UpdateBranchOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) (*Branch, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*BranchOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type updateBranchOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *updateBranchOperation) Wait(ctx context.Context, opts ...api.Option) (*Branch, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")
	var result *Branch
	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		var branch Branch
		err = json.Unmarshal(operation.Response, &branch)
		if err != nil {
			return fmt.Errorf("failed to unmarshal branch response: %w", err)
		}

		result = &branch

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	if err != nil {
		return nil, err
	}
	return result, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *updateBranchOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *updateBranchOperation) Metadata() (*BranchOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata BranchOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *updateBranchOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) UpdateEndpoint(ctx context.Context, request UpdateEndpointRequest) (UpdateEndpointOperationInterface, error) {
	operation, err := a.postgresImpl.UpdateEndpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return &updateEndpointOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type UpdateEndpointOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) (*Endpoint, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*EndpointOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type updateEndpointOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *updateEndpointOperation) Wait(ctx context.Context, opts ...api.Option) (*Endpoint, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")
	var result *Endpoint
	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		var endpoint Endpoint
		err = json.Unmarshal(operation.Response, &endpoint)
		if err != nil {
			return fmt.Errorf("failed to unmarshal endpoint response: %w", err)
		}

		result = &endpoint

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	if err != nil {
		return nil, err
	}
	return result, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *updateEndpointOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *updateEndpointOperation) Metadata() (*EndpointOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata EndpointOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *updateEndpointOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) UpdateProject(ctx context.Context, request UpdateProjectRequest) (UpdateProjectOperationInterface, error) {
	operation, err := a.postgresImpl.UpdateProject(ctx, request)
	if err != nil {
		return nil, err
	}
	return &updateProjectOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type UpdateProjectOperationInterface interface {

	// Wait blocks until the long-running operation is completed. If no timeout is
	// specified, this will poll indefinitely. If a timeout is provided and the operation
	// didn't finish within the timeout, this function will return an error, otherwise
	// returns successful response and any errors encountered.
	Wait(ctx context.Context, opts ...api.Option) (*Project, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*ProjectOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type updateProjectOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed. If no timeout is
// specified, this will poll indefinitely. If a timeout is provided and the operation
// didn't finish within the timeout, this function will return an error, otherwise
// returns successful response and any errors encountered.
func (a *updateProjectOperation) Wait(ctx context.Context, opts ...api.Option) (*Project, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")

	errOperationInProgress := errors.New("operation still in progress")
	var result *Project
	call := func(ctx context.Context) error {
		operation, err := a.impl.GetOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return err
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return errOperationInProgress
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return fmt.Errorf("operation failed: %s", errorMsg)
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return fmt.Errorf("operation completed but no response available")
		}

		var project Project
		err = json.Unmarshal(operation.Response, &project)
		if err != nil {
			return fmt.Errorf("failed to unmarshal project response: %w", err)
		}

		result = &project

		return nil
	}

	// Create a retrier that retries on errOperationInProgress with exponential backoff.
	retrier := api.RetryOn(api.BackoffPolicy{}, func(err error) bool {
		return errors.Is(err, errOperationInProgress)
	})

	// Add default retrier.
	defaultOpts := []api.Option{
		api.WithRetrier(func() api.Retrier { return retrier }),
	}
	allOpts := append(defaultOpts, opts...)

	err := api.Execute(ctx, call, allOpts...)

	if err != nil {
		return nil, err
	}
	return result, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *updateProjectOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *updateProjectOperation) Metadata() (*ProjectOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata ProjectOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *updateProjectOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}
