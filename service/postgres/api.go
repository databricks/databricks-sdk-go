// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// The Postgres API provides access to a Postgres database via REST API or
// direct SQL.
package postgres

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/service/common/lro"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type PostgresInterface interface {
	CreateDatabaseBranch(ctx context.Context, request CreateDatabaseBranchRequest) (CreateDatabaseBranchOperationInterface, error)

	CreateDatabaseEndpoint(ctx context.Context, request CreateDatabaseEndpointRequest) (CreateDatabaseEndpointOperationInterface, error)

	CreateDatabaseProject(ctx context.Context, request CreateDatabaseProjectRequest) (CreateDatabaseProjectOperationInterface, error)

	// Delete a Database Branch.
	DeleteDatabaseBranch(ctx context.Context, request DeleteDatabaseBranchRequest) error

	// Delete a Database Endpoint.
	DeleteDatabaseEndpoint(ctx context.Context, request DeleteDatabaseEndpointRequest) error

	// Delete a Database Project.
	DeleteDatabaseProject(ctx context.Context, request DeleteDatabaseProjectRequest) error

	// Get a Database Branch.
	GetDatabaseBranch(ctx context.Context, request GetDatabaseBranchRequest) (*DatabaseBranch, error)

	// Get a Database Endpoint.
	GetDatabaseEndpoint(ctx context.Context, request GetDatabaseEndpointRequest) (*DatabaseEndpoint, error)

	// Get a Database Operation.
	GetDatabaseOperation(ctx context.Context, request GetOperationRequest) (*Operation, error)

	// Get a Database Project.
	GetDatabaseProject(ctx context.Context, request GetDatabaseProjectRequest) (*DatabaseProject, error)

	// List Database Branches.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDatabaseBranches(ctx context.Context, request ListDatabaseBranchesRequest) listing.Iterator[DatabaseBranch]

	// List Database Branches.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDatabaseBranchesAll(ctx context.Context, request ListDatabaseBranchesRequest) ([]DatabaseBranch, error)

	// List Database Endpoints.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDatabaseEndpoints(ctx context.Context, request ListDatabaseEndpointsRequest) listing.Iterator[DatabaseEndpoint]

	// List Database Endpoints.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDatabaseEndpointsAll(ctx context.Context, request ListDatabaseEndpointsRequest) ([]DatabaseEndpoint, error)

	// List Database Projects.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDatabaseProjects(ctx context.Context, request ListDatabaseProjectsRequest) listing.Iterator[DatabaseProject]

	// List Database Projects.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDatabaseProjectsAll(ctx context.Context, request ListDatabaseProjectsRequest) ([]DatabaseProject, error)

	RestartDatabaseEndpoint(ctx context.Context, request RestartDatabaseEndpointRequest) (RestartDatabaseEndpointOperationInterface, error)

	UpdateDatabaseBranch(ctx context.Context, request UpdateDatabaseBranchRequest) (UpdateDatabaseBranchOperationInterface, error)

	UpdateDatabaseEndpoint(ctx context.Context, request UpdateDatabaseEndpointRequest) (UpdateDatabaseEndpointOperationInterface, error)

	UpdateDatabaseProject(ctx context.Context, request UpdateDatabaseProjectRequest) (UpdateDatabaseProjectOperationInterface, error)
}

func NewPostgres(client *client.DatabricksClient) *PostgresAPI {
	return &PostgresAPI{
		postgresImpl: postgresImpl{
			client: client,
		},
	}
}

// The Postgres API provides access to a Postgres database via REST API or
// direct SQL.
type PostgresAPI struct {
	postgresImpl
}

func (a *PostgresAPI) CreateDatabaseBranch(ctx context.Context, request CreateDatabaseBranchRequest) (CreateDatabaseBranchOperationInterface, error) {
	operation, err := a.postgresImpl.CreateDatabaseBranch(ctx, request)
	if err != nil {
		return nil, err
	}
	return &CreateDatabaseBranchOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type CreateDatabaseBranchOperationInterface interface {
	// Wait blocks until the long-running operation is completed with default 20 min
	// timeout, the timeout can be overridden in the opts. If the operation didn't
	// finished within the timeout, this function will through an error of type
	// ErrTimedOut, otherwise successful response and any errors encountered.
	Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseBranch, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*DatabaseBranchOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type CreateDatabaseBranchOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed with default 20 min
// timeout, the timeout can be overridden in the opts. If the operation didn't
// finished within the timeout, this function will through an error of type
// ErrTimedOut, otherwise successful response and any errors encountered.
func (a *CreateDatabaseBranchOperation) Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseBranch, error) {
	timeout := 20 * time.Minute // default timeout per LRO spec
	if opts != nil && opts.Timeout > 0 {
		timeout = opts.Timeout
	}

	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	val, err := retries.Poll[DatabaseBranch](ctx, timeout, func() (*DatabaseBranch, *retries.Err) {
		operation, err := a.impl.GetDatabaseOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return nil, retries.Continues("operation still in progress")
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return nil, retries.Halt(fmt.Errorf("operation failed: %s", errorMsg))
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return nil, retries.Halt(fmt.Errorf("operation completed but no response available"))
		}

		var databaseBranch DatabaseBranch
		err = json.Unmarshal(operation.Response, &databaseBranch)
		if err != nil {
			return nil, retries.Halt(fmt.Errorf("failed to unmarshal databaseBranch response: %w", err))
		}

		return &databaseBranch, nil

	})

	if err != nil {
		return nil, err
	}
	return val, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *CreateDatabaseBranchOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *CreateDatabaseBranchOperation) Metadata() (*DatabaseBranchOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata DatabaseBranchOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *CreateDatabaseBranchOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetDatabaseOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) CreateDatabaseEndpoint(ctx context.Context, request CreateDatabaseEndpointRequest) (CreateDatabaseEndpointOperationInterface, error) {
	operation, err := a.postgresImpl.CreateDatabaseEndpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return &CreateDatabaseEndpointOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type CreateDatabaseEndpointOperationInterface interface {
	// Wait blocks until the long-running operation is completed with default 20 min
	// timeout, the timeout can be overridden in the opts. If the operation didn't
	// finished within the timeout, this function will through an error of type
	// ErrTimedOut, otherwise successful response and any errors encountered.
	Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseEndpoint, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*DatabaseEndpointOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type CreateDatabaseEndpointOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed with default 20 min
// timeout, the timeout can be overridden in the opts. If the operation didn't
// finished within the timeout, this function will through an error of type
// ErrTimedOut, otherwise successful response and any errors encountered.
func (a *CreateDatabaseEndpointOperation) Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseEndpoint, error) {
	timeout := 20 * time.Minute // default timeout per LRO spec
	if opts != nil && opts.Timeout > 0 {
		timeout = opts.Timeout
	}

	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	val, err := retries.Poll[DatabaseEndpoint](ctx, timeout, func() (*DatabaseEndpoint, *retries.Err) {
		operation, err := a.impl.GetDatabaseOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return nil, retries.Continues("operation still in progress")
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return nil, retries.Halt(fmt.Errorf("operation failed: %s", errorMsg))
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return nil, retries.Halt(fmt.Errorf("operation completed but no response available"))
		}

		var databaseEndpoint DatabaseEndpoint
		err = json.Unmarshal(operation.Response, &databaseEndpoint)
		if err != nil {
			return nil, retries.Halt(fmt.Errorf("failed to unmarshal databaseEndpoint response: %w", err))
		}

		return &databaseEndpoint, nil

	})

	if err != nil {
		return nil, err
	}
	return val, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *CreateDatabaseEndpointOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *CreateDatabaseEndpointOperation) Metadata() (*DatabaseEndpointOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata DatabaseEndpointOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *CreateDatabaseEndpointOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetDatabaseOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) CreateDatabaseProject(ctx context.Context, request CreateDatabaseProjectRequest) (CreateDatabaseProjectOperationInterface, error) {
	operation, err := a.postgresImpl.CreateDatabaseProject(ctx, request)
	if err != nil {
		return nil, err
	}
	return &CreateDatabaseProjectOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type CreateDatabaseProjectOperationInterface interface {
	// Wait blocks until the long-running operation is completed with default 20 min
	// timeout, the timeout can be overridden in the opts. If the operation didn't
	// finished within the timeout, this function will through an error of type
	// ErrTimedOut, otherwise successful response and any errors encountered.
	Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseProject, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*DatabaseProjectOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type CreateDatabaseProjectOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed with default 20 min
// timeout, the timeout can be overridden in the opts. If the operation didn't
// finished within the timeout, this function will through an error of type
// ErrTimedOut, otherwise successful response and any errors encountered.
func (a *CreateDatabaseProjectOperation) Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseProject, error) {
	timeout := 20 * time.Minute // default timeout per LRO spec
	if opts != nil && opts.Timeout > 0 {
		timeout = opts.Timeout
	}

	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	val, err := retries.Poll[DatabaseProject](ctx, timeout, func() (*DatabaseProject, *retries.Err) {
		operation, err := a.impl.GetDatabaseOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return nil, retries.Continues("operation still in progress")
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return nil, retries.Halt(fmt.Errorf("operation failed: %s", errorMsg))
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return nil, retries.Halt(fmt.Errorf("operation completed but no response available"))
		}

		var databaseProject DatabaseProject
		err = json.Unmarshal(operation.Response, &databaseProject)
		if err != nil {
			return nil, retries.Halt(fmt.Errorf("failed to unmarshal databaseProject response: %w", err))
		}

		return &databaseProject, nil

	})

	if err != nil {
		return nil, err
	}
	return val, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *CreateDatabaseProjectOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *CreateDatabaseProjectOperation) Metadata() (*DatabaseProjectOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata DatabaseProjectOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *CreateDatabaseProjectOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetDatabaseOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) RestartDatabaseEndpoint(ctx context.Context, request RestartDatabaseEndpointRequest) (RestartDatabaseEndpointOperationInterface, error) {
	operation, err := a.postgresImpl.RestartDatabaseEndpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return &RestartDatabaseEndpointOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type RestartDatabaseEndpointOperationInterface interface {
	// Wait blocks until the long-running operation is completed with default 20 min
	// timeout, the timeout can be overridden in the opts. If the operation didn't
	// finished within the timeout, this function will through an error of type
	// ErrTimedOut, otherwise successful response and any errors encountered.
	Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseEndpoint, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*DatabaseEndpointOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type RestartDatabaseEndpointOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed with default 20 min
// timeout, the timeout can be overridden in the opts. If the operation didn't
// finished within the timeout, this function will through an error of type
// ErrTimedOut, otherwise successful response and any errors encountered.
func (a *RestartDatabaseEndpointOperation) Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseEndpoint, error) {
	timeout := 20 * time.Minute // default timeout per LRO spec
	if opts != nil && opts.Timeout > 0 {
		timeout = opts.Timeout
	}

	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	val, err := retries.Poll[DatabaseEndpoint](ctx, timeout, func() (*DatabaseEndpoint, *retries.Err) {
		operation, err := a.impl.GetDatabaseOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return nil, retries.Continues("operation still in progress")
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return nil, retries.Halt(fmt.Errorf("operation failed: %s", errorMsg))
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return nil, retries.Halt(fmt.Errorf("operation completed but no response available"))
		}

		var databaseEndpoint DatabaseEndpoint
		err = json.Unmarshal(operation.Response, &databaseEndpoint)
		if err != nil {
			return nil, retries.Halt(fmt.Errorf("failed to unmarshal databaseEndpoint response: %w", err))
		}

		return &databaseEndpoint, nil

	})

	if err != nil {
		return nil, err
	}
	return val, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *RestartDatabaseEndpointOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *RestartDatabaseEndpointOperation) Metadata() (*DatabaseEndpointOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata DatabaseEndpointOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *RestartDatabaseEndpointOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetDatabaseOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) UpdateDatabaseBranch(ctx context.Context, request UpdateDatabaseBranchRequest) (UpdateDatabaseBranchOperationInterface, error) {
	operation, err := a.postgresImpl.UpdateDatabaseBranch(ctx, request)
	if err != nil {
		return nil, err
	}
	return &UpdateDatabaseBranchOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type UpdateDatabaseBranchOperationInterface interface {
	// Wait blocks until the long-running operation is completed with default 20 min
	// timeout, the timeout can be overridden in the opts. If the operation didn't
	// finished within the timeout, this function will through an error of type
	// ErrTimedOut, otherwise successful response and any errors encountered.
	Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseBranch, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*DatabaseBranchOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type UpdateDatabaseBranchOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed with default 20 min
// timeout, the timeout can be overridden in the opts. If the operation didn't
// finished within the timeout, this function will through an error of type
// ErrTimedOut, otherwise successful response and any errors encountered.
func (a *UpdateDatabaseBranchOperation) Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseBranch, error) {
	timeout := 20 * time.Minute // default timeout per LRO spec
	if opts != nil && opts.Timeout > 0 {
		timeout = opts.Timeout
	}

	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	val, err := retries.Poll[DatabaseBranch](ctx, timeout, func() (*DatabaseBranch, *retries.Err) {
		operation, err := a.impl.GetDatabaseOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return nil, retries.Continues("operation still in progress")
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return nil, retries.Halt(fmt.Errorf("operation failed: %s", errorMsg))
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return nil, retries.Halt(fmt.Errorf("operation completed but no response available"))
		}

		var databaseBranch DatabaseBranch
		err = json.Unmarshal(operation.Response, &databaseBranch)
		if err != nil {
			return nil, retries.Halt(fmt.Errorf("failed to unmarshal databaseBranch response: %w", err))
		}

		return &databaseBranch, nil

	})

	if err != nil {
		return nil, err
	}
	return val, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *UpdateDatabaseBranchOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *UpdateDatabaseBranchOperation) Metadata() (*DatabaseBranchOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata DatabaseBranchOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *UpdateDatabaseBranchOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetDatabaseOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) UpdateDatabaseEndpoint(ctx context.Context, request UpdateDatabaseEndpointRequest) (UpdateDatabaseEndpointOperationInterface, error) {
	operation, err := a.postgresImpl.UpdateDatabaseEndpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return &UpdateDatabaseEndpointOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type UpdateDatabaseEndpointOperationInterface interface {
	// Wait blocks until the long-running operation is completed with default 20 min
	// timeout, the timeout can be overridden in the opts. If the operation didn't
	// finished within the timeout, this function will through an error of type
	// ErrTimedOut, otherwise successful response and any errors encountered.
	Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseEndpoint, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*DatabaseEndpointOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type UpdateDatabaseEndpointOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed with default 20 min
// timeout, the timeout can be overridden in the opts. If the operation didn't
// finished within the timeout, this function will through an error of type
// ErrTimedOut, otherwise successful response and any errors encountered.
func (a *UpdateDatabaseEndpointOperation) Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseEndpoint, error) {
	timeout := 20 * time.Minute // default timeout per LRO spec
	if opts != nil && opts.Timeout > 0 {
		timeout = opts.Timeout
	}

	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	val, err := retries.Poll[DatabaseEndpoint](ctx, timeout, func() (*DatabaseEndpoint, *retries.Err) {
		operation, err := a.impl.GetDatabaseOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return nil, retries.Continues("operation still in progress")
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return nil, retries.Halt(fmt.Errorf("operation failed: %s", errorMsg))
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return nil, retries.Halt(fmt.Errorf("operation completed but no response available"))
		}

		var databaseEndpoint DatabaseEndpoint
		err = json.Unmarshal(operation.Response, &databaseEndpoint)
		if err != nil {
			return nil, retries.Halt(fmt.Errorf("failed to unmarshal databaseEndpoint response: %w", err))
		}

		return &databaseEndpoint, nil

	})

	if err != nil {
		return nil, err
	}
	return val, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *UpdateDatabaseEndpointOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *UpdateDatabaseEndpointOperation) Metadata() (*DatabaseEndpointOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata DatabaseEndpointOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *UpdateDatabaseEndpointOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetDatabaseOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}

func (a *PostgresAPI) UpdateDatabaseProject(ctx context.Context, request UpdateDatabaseProjectRequest) (UpdateDatabaseProjectOperationInterface, error) {
	operation, err := a.postgresImpl.UpdateDatabaseProject(ctx, request)
	if err != nil {
		return nil, err
	}
	return &UpdateDatabaseProjectOperation{
		impl:      &a.postgresImpl,
		operation: operation,
	}, nil
}

type UpdateDatabaseProjectOperationInterface interface {
	// Wait blocks until the long-running operation is completed with default 20 min
	// timeout, the timeout can be overridden in the opts. If the operation didn't
	// finished within the timeout, this function will through an error of type
	// ErrTimedOut, otherwise successful response and any errors encountered.
	Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseProject, error)

	// Name returns the name of the long-running operation. The name is assigned
	// by the server and is unique within the service from which the operation is created.
	Name() string

	// Metadata returns metadata associated with the long-running operation.
	// If the metadata is not available, the returned metadata and error are both nil.
	Metadata() (*DatabaseProjectOperationMetadata, error)

	// Done reports whether the long-running operation has completed.
	Done() (bool, error)
}

type UpdateDatabaseProjectOperation struct {
	impl      *postgresImpl
	operation *Operation
}

// Wait blocks until the long-running operation is completed with default 20 min
// timeout, the timeout can be overridden in the opts. If the operation didn't
// finished within the timeout, this function will through an error of type
// ErrTimedOut, otherwise successful response and any errors encountered.
func (a *UpdateDatabaseProjectOperation) Wait(ctx context.Context, opts *lro.LroOptions) (*DatabaseProject, error) {
	timeout := 20 * time.Minute // default timeout per LRO spec
	if opts != nil && opts.Timeout > 0 {
		timeout = opts.Timeout
	}

	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	val, err := retries.Poll[DatabaseProject](ctx, timeout, func() (*DatabaseProject, *retries.Err) {
		operation, err := a.impl.GetDatabaseOperation(ctx, GetOperationRequest{
			Name: a.operation.Name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}

		// Update local operation state
		a.operation = operation

		if !operation.Done {
			return nil, retries.Continues("operation still in progress")
		}

		if operation.Error != nil {
			var errorMsg string
			if operation.Error.Message != "" {
				errorMsg = operation.Error.Message
			} else {
				errorMsg = "unknown error"
			}

			if operation.Error.ErrorCode != "" {
				errorMsg = fmt.Sprintf("[%s] %s", operation.Error.ErrorCode, errorMsg)
			}

			return nil, retries.Halt(fmt.Errorf("operation failed: %s", errorMsg))
		}

		// Operation completed successfully, unmarshal response
		if operation.Response == nil {
			return nil, retries.Halt(fmt.Errorf("operation completed but no response available"))
		}

		var databaseProject DatabaseProject
		err = json.Unmarshal(operation.Response, &databaseProject)
		if err != nil {
			return nil, retries.Halt(fmt.Errorf("failed to unmarshal databaseProject response: %w", err))
		}

		return &databaseProject, nil

	})

	if err != nil {
		return nil, err
	}
	return val, nil

}

// Name returns the name of the long-running operation. The name is assigned
// by the server and is unique within the service from which the operation is created.
func (a *UpdateDatabaseProjectOperation) Name() string {
	return a.operation.Name
}

// Metadata returns metadata associated with the long-running operation.
// If the metadata is not available, the returned metadata and error are both nil.
func (a *UpdateDatabaseProjectOperation) Metadata() (*DatabaseProjectOperationMetadata, error) {
	if a.operation.Metadata == nil {
		return nil, nil
	}

	var metadata DatabaseProjectOperationMetadata
	err := json.Unmarshal(a.operation.Metadata, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal operation metadata: %w", err)
	}

	return &metadata, nil
}

// Done reports whether the long-running operation has completed.
func (a *UpdateDatabaseProjectOperation) Done() (bool, error) {
	// Refresh the operation state first
	operation, err := a.impl.GetDatabaseOperation(context.Background(), GetOperationRequest{
		Name: a.operation.Name,
	})
	if err != nil {
		return false, err
	}

	// Update local operation state
	a.operation = operation

	return operation.Done, nil
}
