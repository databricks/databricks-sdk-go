// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

package {{.Name}}

import (
	"context"
	"io"
	"github.com/databricks/databricks-sdk-go/databricks/retries"
)

{{range .Services}}
{{.Comment "// " 80}}
//
// This is the high-level interface, that contains generated methods.
// 
// Evolving: this interface is under development. Method signatures may change.
type {{.PascalName}}Service interface {
	{{range .Methods}}
    {{.Comment "    // " 80}}
	{{- if .Pagination}}
	// 
	// Use {{.PascalName}}All() to get all {{.Pagination.Entity.PascalName}} instances{{if .Pagination.MultiRequest}}, which will iterate over every result page.{{end}}
	{{- end}}
    {{.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) {{if .Response}}({{if .Response.ArrayValue}}[]{{.Response.ArrayValue.PascalName}}{{else}}*{{.Response.PascalName}}{{end}}, error){{else}}error{{end}}
	{{if .Wait}}
	// {{.PascalName}}AndWait calls {{.PascalName}}() and waits to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.PascalName}}AndWait(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error){{end}}
	{{- if .Shortcut}}
	// {{.Shortcut.PascalName}} calls {{.PascalName}}, but directly with primitive function arguments, 
	// instead of constructing request instance.
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.Shortcut.PascalName}}(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}) {{if .Response}}({{if .Response.ArrayValue}}[]{{.Response.ArrayValue.PascalName}}{{else}}*{{.Response.PascalName}}{{end}}, error){{else}}error{{end}}{{end}}
	{{- if .Pagination}}
	// {{.PascalName}}All calls {{.PascalName}}() to retrieve all available results from the platform.
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.PascalName}}All(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) ([]{{.Pagination.Entity.PascalName}}, error){{end}}
	{{if .NamedIdMap}}
	// {{.NamedIdMap.Entity.PascalName}}{{.NamedIdMap.Name.PascalName}}To{{.NamedIdMap.Id.PascalName}}Map retrieves a mapping to access ID by name
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.NamedIdMap.Entity.PascalName}}{{.NamedIdMap.Name.PascalName}}To{{.NamedIdMap.Id.PascalName}}Map(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) (map[string]{{template "type" .NamedIdMap.Id.Entity}}, error){{end}}
	{{if .GetByName}}
	// Get{{.NamedIdMap.Entity.PascalName}}By{{.NamedIdMap.Name.PascalName}} retrieves {{.GetByName.PascalName}} by name.
	// 
	// This method is generated by Databricks SDK Code Generator.
	Get{{.NamedIdMap.Entity.PascalName}}By{{.NamedIdMap.Name.PascalName}}(ctx context.Context, name string) (*{{.GetByName.PascalName}}, error){{end}}
	{{- if and .Shortcut .Wait}}
	// {{.Shortcut.PascalName}}AndWait calls {{.Shortcut.PascalName}} and waits until {{.Wait.Poll.Response.PascalName}} is in desired state.
	// 
	// This method is generated by Databricks SDK Code Generator.
	{{.Shortcut.PascalName}}AndWait(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}, options ...retries.Option[{{.Wait.Poll.Response.PascalName}}]) (*{{.Wait.Poll.Response.PascalName}}, error){{end}}
	{{end}}
	{{if eq .PascalName "Clusters"}}// GetOrCreateRunningCluster creates an autoterminating cluster if it doesn't exist
	GetOrCreateRunningCluster(ctx context.Context, name string, custom ...CreateCluster) (c *ClusterInfo, err error)
	{{end}}
	{{if eq .PascalName "Dbfs"}}// Overwrite uploads a file from supplied `io.Reader`
	Overwrite(ctx context.Context, path string, r io.Reader) error
	// Open returns `io.Reader` to download file in chunks
	Open(ctx context.Context, path string) (*FileReader, error)
	{{end}}
	{{if eq .PascalName "Libraries"}}// UpdateAndWait installs or uninstalls specified libraries 
	// and waits until they are in a usable state
	UpdateAndWait(ctx context.Context, update Update, options ...retries.Option[ClusterLibraryStatuses]) error
	// Wait returns only once the libraries are in the usable state
	Wait(ctx context.Context, wait Wait, options ...retries.Option[ClusterLibraryStatuses]) (*ClusterLibraryStatuses, error)
	{{end}}
	
}
{{end}}