// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

package {{.Name}}

import (
	"context"
	{{if or .HasPathParams .HasWaits}}"fmt"{{end}}
	{{if .HasWaits}}"time"

	"github.com/databricks/databricks-sdk-go/retries"{{end}}
	{{if .HasPagination}}"github.com/databricks/databricks-sdk-go/databricks/useragent"
	{{- end}}
	"github.com/databricks/databricks-sdk-go/databricks/client"
)
{{range .Services}}
func New{{.PascalName}}(client *client.DatabricksClient) {{.PascalName}}Service {
	return &{{.PascalName}}API{
		client: client,
	}
}

type {{.PascalName}}API struct {
	client *client.DatabricksClient
}

{{range .Methods}}{{.Comment "// " 80}}
{{- if .Pagination}}
// 
// Use {{.PascalName}}All() to get all {{.Pagination.Entity.PascalName}} instances{{if .Pagination.MultiRequest}}, which will iterate over every result page.{{end}}
{{- end}}
func (a *{{.Service.Name}}API) {{.PascalName}}(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) {{if .Response}}({{if .Response.ArrayValue}}[]{{.Response.ArrayValue.PascalName}}{{else}}*{{.Response.PascalName}}{{end}}, error){{else}}error{{end}} {
	{{if .Response}}var {{.Response.CamelName}} {{if .Response.ArrayValue}}[]{{.Response.ArrayValue.PascalName}}{{else}}{{.Response.PascalName}}{{end}}
	{{end -}}
	path := {{if .PathParts -}}
		fmt.Sprintf("{{range  .PathParts}}{{.Prefix}}{{if .Field}}%v{{end}}{{ end }}"{{ range .PathParts }}{{if .Field}}, request.{{.Field.PascalName}}{{end}}{{ end }})
	{{- else}}"{{.Path}}"{{end}}
	err := a.client.{{.TitleVerb}}(ctx, path, {{if .Request}}request{{else}}nil{{end}}{{if .Response}}, &{{.Response.CamelName}}{{else if .CanHaveResponseBody}}, nil{{end}})
	return {{if .Response}}{{if not .Response.ArrayValue}}&{{end}}{{.Response.CamelName}}, {{end}}err
}
{{if .Wait}}
// {{.PascalName}} and wait to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
func (a *{{.Service.Name}}API) {{.PascalName}}AndWait(ctx context.Context{{if .Request}}, {{.Request.CamelName}} {{.Request.PascalName}}{{end}}, timeout ...time.Duration) (*{{.Wait.Poll.Response.PascalName}}, error) {
	{{if .Wait.ForceBindRequest}}_, {{else if .Response}}{{.Response.CamelName}}, {{end}}err := a.{{.PascalName}}(ctx{{if .Request}}, {{.Request.CamelName}}{{end}})
	if err != nil {
		return nil, err
	}
	if len(timeout) == 0 {
		timeout = []time.Duration{20*time.Minute}
	}
	return retries.Poll[{{.Wait.Poll.Response.PascalName}}](ctx, timeout[0], func() (*{{.Wait.Poll.Response.PascalName}}, *retries.Err) {
		{{.Wait.Poll.Response.CamelName}}, err := a.{{.Wait.Poll.PascalName}}(ctx, {{.Wait.Poll.Request.PascalName}}{ {{range .Wait.Binding}}
			{{.PollField.PascalName}}: {{.Bind.Of.CamelName}}.{{.Bind.PascalName}},{{end}}
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		status := {{.Wait.Poll.Response.CamelName}}{{range .Wait.StatusPath}}.{{.PascalName}}{{end}}
		statusMessage := {{if .Wait.MessagePath}}{{.Wait.Poll.Response.CamelName}}{{range .Wait.MessagePath}}.{{.PascalName}}{{end}}{{else}}fmt.Sprintf("current status: %s", status){{end}}
		switch status {
		case {{range $i, $e := .Wait.Success}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}: // target state
			return {{.Wait.Poll.Response.CamelName}}, nil
		{{if .Wait.Failure}}case {{range $i, $e := .Wait.Failure}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}:
			err := fmt.Errorf("failed to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}%s{{end}}, got %s: %s",
				{{range $i, $e := .Wait.Success}}{{if $i}}, {{end}}{{$e.Entity.PascalName}}{{$e.PascalName}}{{end}}, status, statusMessage)
			return nil, retries.Halt(err)
		{{end}}default:
			return nil, retries.Continues(statusMessage)
		}
	})
}
{{end}}{{if .Pagination}}
// {{.PascalName}}All returns all {{.Pagination.Entity.PascalName}} instances{{if .Pagination.MultiRequest}} by calling {{.PascalName}} for every result page{{end}}
// 
// This method is generated by Databricks SDK Code Generator.
func (a *{{.Service.Name}}API) {{.PascalName}}All(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) ([]{{.Pagination.Entity.PascalName}}, error) {
	{{if .Pagination.MultiRequest}}var results []{{.Pagination.Entity.PascalName}}
	ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
	{{if eq .Pagination.Increment 1 -}}
	request.{{.Pagination.Offset.PascalName}} = 1 // start iterating from the first page
	{{end}}for {
		response, err := a.{{.PascalName}}(ctx{{if .Request}}, request{{end}})
		if err != nil {
			return nil, err
		}
		if len(response.{{.Pagination.Results.PascalName}}) == 0 {
			break
		}
		for _, v := range response.{{.Pagination.Results.PascalName}} {
			results = append(results, v)
		}
		{{if .Pagination.Token -}}
		request.{{.Pagination.Token.PollField.PascalName}} = response.{{.Pagination.Token.Bind.PascalName}}
		if response.{{.Pagination.Token.Bind.PascalName}} == "" {
			break
		}
		{{- else if eq .Pagination.Increment 1 -}}
		request.{{.Pagination.Offset.PascalName}}++
		{{- else -}}
		request.{{.Pagination.Offset.PascalName}} += {{template "type" .Pagination.Offset.Entity}}(len(response.{{.Pagination.Results.PascalName}})) // TODO: check for duplicates
		{{- end}}
	}
	return results, nil{{else if .Pagination.Results}}response, err := a.{{.PascalName}}(ctx{{if .Request}}, request{{end}})
	if err != nil {
		return nil, err
	}
	return response.{{.Pagination.Results.PascalName}}, nil{{else}}return a.{{.PascalName}}(ctx, request){{end}}
}
{{end}}{{if .NamedIdMap}}
func (a *{{.Service.Name}}API) {{.NamedIdMap.Entity.PascalName}}{{.NamedIdMap.Name.PascalName}}To{{.NamedIdMap.Id.PascalName}}Map(ctx context.Context{{if .Request}}, request {{.Request.PascalName}}{{end}}) (map[string]{{template "type" .NamedIdMap.Id.Entity}}, error) {
	mapping := map[string]{{template "type" .NamedIdMap.Id.Entity}}{}
	result, err := a.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end}}(ctx{{if .Request}}, request{{end}})
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		mapping[v.{{.NamedIdMap.Name.PascalName}}] = v.{{.NamedIdMap.Id.PascalName}}
	}
	return mapping, nil
}
{{end}}{{if .GetByName}}
func (a *{{.Service.Name}}API) Get{{.NamedIdMap.Entity.PascalName}}By{{.NamedIdMap.Name.PascalName}}(ctx context.Context, name string) (*{{.GetByName.PascalName}}, error) {
	result, err := a.{{.PascalName}}{{if not .NamedIdMap.Direct}}All{{end}}(ctx{{if .Request}}, {{.Request.PascalName}}{}{{end}})
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		if v.{{.NamedIdMap.Name.PascalName}} != name {
			continue
		}
		return &v, nil
	}
	return nil, fmt.Errorf("{{.NamedIdMap.Entity.PascalName}} named '%s' does not exist", name)
}
{{end}}{{if .Shortcut}}
{{.Comment "// " 80}}
func (a *{{.Service.Name}}API) {{.Shortcut.PascalName}}(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}) {{if .Response}}({{if .Response.ArrayValue}}[]{{.Response.ArrayValue.PascalName}}{{else}}*{{.Response.PascalName}}{{end}}, error){{else}}error{{end}} {
	return a.{{.PascalName}}(ctx, {{.Request.PascalName}}{
		{{- range .Shortcut.Params}}
		{{.PascalName}}: {{.CamelName}},{{end}}
	})
}
{{end}}{{if and .Shortcut .Wait}}
func (a *{{.Service.Name}}API) {{.Shortcut.PascalName}}AndWait(ctx context.Context{{range .Shortcut.Params}}, {{.CamelName}} {{template "type" .Entity}}{{end}}, timeout ...time.Duration) (*{{.Wait.Poll.Response.PascalName}}, error) {
	return a.{{.PascalName}}AndWait(ctx, {{.Request.PascalName}}{
		{{- range .Shortcut.Params}}
		{{.PascalName}}: {{.CamelName}},{{end}}
	}, timeout...)
}
{{end}}
{{end -}}
{{- end}}