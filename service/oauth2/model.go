// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

package oauth2

import (
	"encoding/json"
	"fmt"
)

// Create account federation policy
type CreateAccountFederationPolicyRequest struct {

	// Wire name: 'policy'
	Policy FederationPolicy `json:"policy"`
	// The identifier for the federation policy. The identifier must contain
	// only lowercase alphanumeric characters, numbers, hyphens, and slashes. If
	// unspecified, the id will be assigned by Databricks.
	PolicyId string `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreateAccountFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createAccountFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createAccountFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreateAccountFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := createAccountFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type CreateCustomAppIntegration struct {
	// This field indicates whether an OAuth client secret is required to
	// authenticate this client.
	// Wire name: 'confidential'
	Confidential bool `json:"confidential,omitempty"`
	// Name of the custom OAuth app
	// Wire name: 'name'
	Name string `json:"name,omitempty"`
	// List of OAuth redirect urls
	// Wire name: 'redirect_urls'
	RedirectUrls []string `json:"redirect_urls,omitempty"`
	// OAuth scopes granted to the application. Supported scopes: all-apis, sql,
	// offline_access, openid, profile, email.
	// Wire name: 'scopes'
	Scopes []string `json:"scopes,omitempty"`
	// Token access policy
	// Wire name: 'token_access_policy'
	TokenAccessPolicy *TokenAccessPolicy `json:"token_access_policy,omitempty"`
	// Scopes that will need to be consented by end user to mint the access
	// token. If the user does not authorize the access token will not be
	// minted. Must be a subset of scopes.
	// Wire name: 'user_authorized_scopes'
	UserAuthorizedScopes []string `json:"user_authorized_scopes,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreateCustomAppIntegration) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createCustomAppIntegrationPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createCustomAppIntegrationFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreateCustomAppIntegration) MarshalJSON() ([]byte, error) {
	pb, err := createCustomAppIntegrationToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type CreateCustomAppIntegrationOutput struct {
	// OAuth client-id generated by the Databricks
	// Wire name: 'client_id'
	ClientId string `json:"client_id,omitempty"`
	// OAuth client-secret generated by the Databricks. If this is a
	// confidential OAuth app client-secret will be generated.
	// Wire name: 'client_secret'
	ClientSecret string `json:"client_secret,omitempty"`
	// Unique integration id for the custom OAuth app
	// Wire name: 'integration_id'
	IntegrationId string `json:"integration_id,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreateCustomAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createCustomAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createCustomAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreateCustomAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := createCustomAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type CreatePublishedAppIntegration struct {
	// App id of the OAuth published app integration. For example power-bi,
	// tableau-deskop
	// Wire name: 'app_id'
	AppId string `json:"app_id,omitempty"`
	// Token access policy
	// Wire name: 'token_access_policy'
	TokenAccessPolicy *TokenAccessPolicy `json:"token_access_policy,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreatePublishedAppIntegration) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createPublishedAppIntegrationPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createPublishedAppIntegrationFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreatePublishedAppIntegration) MarshalJSON() ([]byte, error) {
	pb, err := createPublishedAppIntegrationToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type CreatePublishedAppIntegrationOutput struct {
	// Unique integration id for the published OAuth app
	// Wire name: 'integration_id'
	IntegrationId string `json:"integration_id,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreatePublishedAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createPublishedAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createPublishedAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreatePublishedAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := createPublishedAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Create service principal federation policy
type CreateServicePrincipalFederationPolicyRequest struct {

	// Wire name: 'policy'
	Policy FederationPolicy `json:"policy"`
	// The identifier for the federation policy. The identifier must contain
	// only lowercase alphanumeric characters, numbers, hyphens, and slashes. If
	// unspecified, the id will be assigned by Databricks.
	PolicyId string `json:"-" tf:"-"`
	// The service principal id for the federation policy.
	ServicePrincipalId int64 `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreateServicePrincipalFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createServicePrincipalFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createServicePrincipalFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreateServicePrincipalFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := createServicePrincipalFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type CreateServicePrincipalSecretRequest struct {
	// The lifetime of the secret in seconds. If this parameter is not provided,
	// the secret will have a default lifetime of 730 days (63072000s).
	// Wire name: 'lifetime'
	Lifetime string `json:"lifetime,omitempty"`
	// The service principal ID.
	ServicePrincipalId int64 `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreateServicePrincipalSecretRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createServicePrincipalSecretRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createServicePrincipalSecretRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreateServicePrincipalSecretRequest) MarshalJSON() ([]byte, error) {
	pb, err := createServicePrincipalSecretRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type CreateServicePrincipalSecretResponse struct {
	// UTC time when the secret was created
	// Wire name: 'create_time'
	CreateTime string `json:"create_time,omitempty"`
	// UTC time when the secret will expire. If the field is not present, the
	// secret does not expire.
	// Wire name: 'expire_time'
	ExpireTime string `json:"expire_time,omitempty"`
	// ID of the secret
	// Wire name: 'id'
	Id string `json:"id,omitempty"`
	// Secret Value
	// Wire name: 'secret'
	Secret string `json:"secret,omitempty"`
	// Secret Hash
	// Wire name: 'secret_hash'
	SecretHash string `json:"secret_hash,omitempty"`
	// Status of the secret
	// Wire name: 'status'
	Status string `json:"status,omitempty"`
	// UTC time when the secret was updated
	// Wire name: 'update_time'
	UpdateTime string `json:"update_time,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *CreateServicePrincipalSecretResponse) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &createServicePrincipalSecretResponsePb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := createServicePrincipalSecretResponseFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st CreateServicePrincipalSecretResponse) MarshalJSON() ([]byte, error) {
	pb, err := createServicePrincipalSecretResponseToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Delete account federation policy
type DeleteAccountFederationPolicyRequest struct {
	// The identifier for the federation policy.
	PolicyId string `json:"-" tf:"-"`
}

func (st *DeleteAccountFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deleteAccountFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deleteAccountFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeleteAccountFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := deleteAccountFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type DeleteCustomAppIntegrationOutput struct {
}

func (st *DeleteCustomAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deleteCustomAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deleteCustomAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeleteCustomAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := deleteCustomAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Delete Custom OAuth App Integration
type DeleteCustomAppIntegrationRequest struct {
	IntegrationId string `json:"-" tf:"-"`
}

func (st *DeleteCustomAppIntegrationRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deleteCustomAppIntegrationRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deleteCustomAppIntegrationRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeleteCustomAppIntegrationRequest) MarshalJSON() ([]byte, error) {
	pb, err := deleteCustomAppIntegrationRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type DeletePublishedAppIntegrationOutput struct {
}

func (st *DeletePublishedAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deletePublishedAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deletePublishedAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeletePublishedAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := deletePublishedAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Delete Published OAuth App Integration
type DeletePublishedAppIntegrationRequest struct {
	IntegrationId string `json:"-" tf:"-"`
}

func (st *DeletePublishedAppIntegrationRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deletePublishedAppIntegrationRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deletePublishedAppIntegrationRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeletePublishedAppIntegrationRequest) MarshalJSON() ([]byte, error) {
	pb, err := deletePublishedAppIntegrationRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type DeleteResponse struct {
}

func (st *DeleteResponse) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deleteResponsePb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deleteResponseFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeleteResponse) MarshalJSON() ([]byte, error) {
	pb, err := deleteResponseToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Delete service principal federation policy
type DeleteServicePrincipalFederationPolicyRequest struct {
	// The identifier for the federation policy.
	PolicyId string `json:"-" tf:"-"`
	// The service principal id for the federation policy.
	ServicePrincipalId int64 `json:"-" tf:"-"`
}

func (st *DeleteServicePrincipalFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deleteServicePrincipalFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deleteServicePrincipalFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeleteServicePrincipalFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := deleteServicePrincipalFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Delete service principal secret
type DeleteServicePrincipalSecretRequest struct {
	// The secret ID.
	SecretId string `json:"-" tf:"-"`
	// The service principal ID.
	ServicePrincipalId int64 `json:"-" tf:"-"`
}

func (st *DeleteServicePrincipalSecretRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &deleteServicePrincipalSecretRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := deleteServicePrincipalSecretRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st DeleteServicePrincipalSecretRequest) MarshalJSON() ([]byte, error) {
	pb, err := deleteServicePrincipalSecretRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type FederationPolicy struct {
	// Creation time of the federation policy.
	// Wire name: 'create_time'
	CreateTime string `json:"create_time,omitempty"`
	// Description of the federation policy.
	// Wire name: 'description'
	Description string `json:"description,omitempty"`
	// Resource name for the federation policy. Example values include
	// `accounts/<account-id>/federationPolicies/my-federation-policy` for
	// Account Federation Policies, and
	// `accounts/<account-id>/servicePrincipals/<service-principal-id>/federationPolicies/my-federation-policy`
	// for Service Principal Federation Policies. Typically an output parameter,
	// which does not need to be specified in create or update requests. If
	// specified in a request, must match the value in the request URL.
	// Wire name: 'name'
	Name string `json:"name,omitempty"`
	// Specifies the policy to use for validating OIDC claims in your federated
	// tokens.
	// Wire name: 'oidc_policy'
	OidcPolicy *OidcFederationPolicy `json:"oidc_policy,omitempty"`
	// The ID of the federation policy.
	// Wire name: 'policy_id'
	PolicyId string `json:"policy_id,omitempty"`
	// The service principal ID that this federation policy applies to. Only set
	// for service principal federation policies.
	// Wire name: 'service_principal_id'
	ServicePrincipalId int64 `json:"service_principal_id,omitempty"`
	// Unique, immutable id of the federation policy.
	// Wire name: 'uid'
	Uid string `json:"uid,omitempty"`
	// Last update time of the federation policy.
	// Wire name: 'update_time'
	UpdateTime string `json:"update_time,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *FederationPolicy) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &federationPolicyPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := federationPolicyFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st FederationPolicy) MarshalJSON() ([]byte, error) {
	pb, err := federationPolicyToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Get account federation policy
type GetAccountFederationPolicyRequest struct {
	// The identifier for the federation policy.
	PolicyId string `json:"-" tf:"-"`
}

func (st *GetAccountFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getAccountFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getAccountFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetAccountFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := getAccountFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type GetCustomAppIntegrationOutput struct {
	// The client id of the custom OAuth app
	// Wire name: 'client_id'
	ClientId string `json:"client_id,omitempty"`
	// This field indicates whether an OAuth client secret is required to
	// authenticate this client.
	// Wire name: 'confidential'
	Confidential bool `json:"confidential,omitempty"`

	// Wire name: 'create_time'
	CreateTime string `json:"create_time,omitempty"`

	// Wire name: 'created_by'
	CreatedBy int64 `json:"created_by,omitempty"`

	// Wire name: 'creator_username'
	CreatorUsername string `json:"creator_username,omitempty"`
	// ID of this custom app
	// Wire name: 'integration_id'
	IntegrationId string `json:"integration_id,omitempty"`
	// The display name of the custom OAuth app
	// Wire name: 'name'
	Name string `json:"name,omitempty"`
	// List of OAuth redirect urls
	// Wire name: 'redirect_urls'
	RedirectUrls []string `json:"redirect_urls,omitempty"`

	// Wire name: 'scopes'
	Scopes []string `json:"scopes,omitempty"`
	// Token access policy
	// Wire name: 'token_access_policy'
	TokenAccessPolicy *TokenAccessPolicy `json:"token_access_policy,omitempty"`
	// Scopes that will need to be consented by end user to mint the access
	// token. If the user does not authorize the access token will not be
	// minted. Must be a subset of scopes.
	// Wire name: 'user_authorized_scopes'
	UserAuthorizedScopes []string `json:"user_authorized_scopes,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *GetCustomAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getCustomAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getCustomAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetCustomAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := getCustomAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Get OAuth Custom App Integration
type GetCustomAppIntegrationRequest struct {
	// The OAuth app integration ID.
	IntegrationId string `json:"-" tf:"-"`
}

func (st *GetCustomAppIntegrationRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getCustomAppIntegrationRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getCustomAppIntegrationRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetCustomAppIntegrationRequest) MarshalJSON() ([]byte, error) {
	pb, err := getCustomAppIntegrationRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type GetCustomAppIntegrationsOutput struct {
	// List of Custom OAuth App Integrations defined for the account.
	// Wire name: 'apps'
	Apps []GetCustomAppIntegrationOutput `json:"apps,omitempty"`

	// Wire name: 'next_page_token'
	NextPageToken string `json:"next_page_token,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *GetCustomAppIntegrationsOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getCustomAppIntegrationsOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getCustomAppIntegrationsOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetCustomAppIntegrationsOutput) MarshalJSON() ([]byte, error) {
	pb, err := getCustomAppIntegrationsOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type GetPublishedAppIntegrationOutput struct {
	// App-id of the published app integration
	// Wire name: 'app_id'
	AppId string `json:"app_id,omitempty"`

	// Wire name: 'create_time'
	CreateTime string `json:"create_time,omitempty"`

	// Wire name: 'created_by'
	CreatedBy int64 `json:"created_by,omitempty"`
	// Unique integration id for the published OAuth app
	// Wire name: 'integration_id'
	IntegrationId string `json:"integration_id,omitempty"`
	// Display name of the published OAuth app
	// Wire name: 'name'
	Name string `json:"name,omitempty"`
	// Token access policy
	// Wire name: 'token_access_policy'
	TokenAccessPolicy *TokenAccessPolicy `json:"token_access_policy,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *GetPublishedAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getPublishedAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getPublishedAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetPublishedAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := getPublishedAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Get OAuth Published App Integration
type GetPublishedAppIntegrationRequest struct {
	IntegrationId string `json:"-" tf:"-"`
}

func (st *GetPublishedAppIntegrationRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getPublishedAppIntegrationRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getPublishedAppIntegrationRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetPublishedAppIntegrationRequest) MarshalJSON() ([]byte, error) {
	pb, err := getPublishedAppIntegrationRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type GetPublishedAppIntegrationsOutput struct {
	// List of Published OAuth App Integrations defined for the account.
	// Wire name: 'apps'
	Apps []GetPublishedAppIntegrationOutput `json:"apps,omitempty"`

	// Wire name: 'next_page_token'
	NextPageToken string `json:"next_page_token,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *GetPublishedAppIntegrationsOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getPublishedAppIntegrationsOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getPublishedAppIntegrationsOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetPublishedAppIntegrationsOutput) MarshalJSON() ([]byte, error) {
	pb, err := getPublishedAppIntegrationsOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type GetPublishedAppsOutput struct {
	// List of Published OAuth Apps.
	// Wire name: 'apps'
	Apps []PublishedAppOutput `json:"apps,omitempty"`
	// A token that can be used to get the next page of results. If not present,
	// there are no more results to show.
	// Wire name: 'next_page_token'
	NextPageToken string `json:"next_page_token,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *GetPublishedAppsOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getPublishedAppsOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getPublishedAppsOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetPublishedAppsOutput) MarshalJSON() ([]byte, error) {
	pb, err := getPublishedAppsOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Get service principal federation policy
type GetServicePrincipalFederationPolicyRequest struct {
	// The identifier for the federation policy.
	PolicyId string `json:"-" tf:"-"`
	// The service principal id for the federation policy.
	ServicePrincipalId int64 `json:"-" tf:"-"`
}

func (st *GetServicePrincipalFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &getServicePrincipalFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := getServicePrincipalFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st GetServicePrincipalFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := getServicePrincipalFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// List account federation policies
type ListAccountFederationPoliciesRequest struct {
	PageSize int `json:"-" tf:"-"`

	PageToken string `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListAccountFederationPoliciesRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listAccountFederationPoliciesRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listAccountFederationPoliciesRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListAccountFederationPoliciesRequest) MarshalJSON() ([]byte, error) {
	pb, err := listAccountFederationPoliciesRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Get custom oauth app integrations
type ListCustomAppIntegrationsRequest struct {
	IncludeCreatorUsername bool `json:"-" tf:"-"`

	PageSize int `json:"-" tf:"-"`

	PageToken string `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListCustomAppIntegrationsRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listCustomAppIntegrationsRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listCustomAppIntegrationsRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListCustomAppIntegrationsRequest) MarshalJSON() ([]byte, error) {
	pb, err := listCustomAppIntegrationsRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type ListFederationPoliciesResponse struct {

	// Wire name: 'next_page_token'
	NextPageToken string `json:"next_page_token,omitempty"`

	// Wire name: 'policies'
	Policies []FederationPolicy `json:"policies,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListFederationPoliciesResponse) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listFederationPoliciesResponsePb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listFederationPoliciesResponseFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListFederationPoliciesResponse) MarshalJSON() ([]byte, error) {
	pb, err := listFederationPoliciesResponseToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Get all the published OAuth apps
type ListOAuthPublishedAppsRequest struct {
	// The max number of OAuth published apps to return in one page.
	PageSize int `json:"-" tf:"-"`
	// A token that can be used to get the next page of results.
	PageToken string `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListOAuthPublishedAppsRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listOAuthPublishedAppsRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listOAuthPublishedAppsRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListOAuthPublishedAppsRequest) MarshalJSON() ([]byte, error) {
	pb, err := listOAuthPublishedAppsRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Get published oauth app integrations
type ListPublishedAppIntegrationsRequest struct {
	PageSize int `json:"-" tf:"-"`

	PageToken string `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListPublishedAppIntegrationsRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listPublishedAppIntegrationsRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listPublishedAppIntegrationsRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListPublishedAppIntegrationsRequest) MarshalJSON() ([]byte, error) {
	pb, err := listPublishedAppIntegrationsRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// List service principal federation policies
type ListServicePrincipalFederationPoliciesRequest struct {
	PageSize int `json:"-" tf:"-"`

	PageToken string `json:"-" tf:"-"`
	// The service principal id for the federation policy.
	ServicePrincipalId int64 `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListServicePrincipalFederationPoliciesRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listServicePrincipalFederationPoliciesRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listServicePrincipalFederationPoliciesRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListServicePrincipalFederationPoliciesRequest) MarshalJSON() ([]byte, error) {
	pb, err := listServicePrincipalFederationPoliciesRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// List service principal secrets
type ListServicePrincipalSecretsRequest struct {
	// An opaque page token which was the `next_page_token` in the response of
	// the previous request to list the secrets for this service principal.
	// Provide this token to retrieve the next page of secret entries. When
	// providing a `page_token`, all other parameters provided to the request
	// must match the previous request. To list all of the secrets for a service
	// principal, it is necessary to continue requesting pages of entries until
	// the response contains no `next_page_token`. Note that the number of
	// entries returned must not be used to determine when the listing is
	// complete.
	PageToken string `json:"-" tf:"-"`
	// The service principal ID.
	ServicePrincipalId int64 `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListServicePrincipalSecretsRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listServicePrincipalSecretsRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listServicePrincipalSecretsRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListServicePrincipalSecretsRequest) MarshalJSON() ([]byte, error) {
	pb, err := listServicePrincipalSecretsRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type ListServicePrincipalSecretsResponse struct {
	// A token, which can be sent as `page_token` to retrieve the next page.
	// Wire name: 'next_page_token'
	NextPageToken string `json:"next_page_token,omitempty"`
	// List of the secrets
	// Wire name: 'secrets'
	Secrets []SecretInfo `json:"secrets,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *ListServicePrincipalSecretsResponse) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &listServicePrincipalSecretsResponsePb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := listServicePrincipalSecretsResponseFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st ListServicePrincipalSecretsResponse) MarshalJSON() ([]byte, error) {
	pb, err := listServicePrincipalSecretsResponseToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Specifies the policy to use for validating OIDC claims in your federated
// tokens.
type OidcFederationPolicy struct {
	// The allowed token audiences, as specified in the 'aud' claim of federated
	// tokens. The audience identifier is intended to represent the recipient of
	// the token. Can be any non-empty string value. As long as the audience in
	// the token matches at least one audience in the policy, the token is
	// considered a match. If audiences is unspecified, defaults to your
	// Databricks account id.
	// Wire name: 'audiences'
	Audiences []string `json:"audiences,omitempty"`
	// The required token issuer, as specified in the 'iss' claim of federated
	// tokens.
	// Wire name: 'issuer'
	Issuer string `json:"issuer,omitempty"`
	// The public keys used to validate the signature of federated tokens, in
	// JWKS format. Most use cases should not need to specify this field. If
	// jwks_uri and jwks_json are both unspecified (recommended), Databricks
	// automatically fetches the public keys from your issuer’s well known
	// endpoint. Databricks strongly recommends relying on your issuer’s well
	// known endpoint for discovering public keys.
	// Wire name: 'jwks_json'
	JwksJson string `json:"jwks_json,omitempty"`
	// URL of the public keys used to validate the signature of federated
	// tokens, in JWKS format. Most use cases should not need to specify this
	// field. If jwks_uri and jwks_json are both unspecified (recommended),
	// Databricks automatically fetches the public keys from your issuer’s
	// well known endpoint. Databricks strongly recommends relying on your
	// issuer’s well known endpoint for discovering public keys.
	// Wire name: 'jwks_uri'
	JwksUri string `json:"jwks_uri,omitempty"`
	// The required token subject, as specified in the subject claim of
	// federated tokens. Must be specified for service principal federation
	// policies. Must not be specified for account federation policies.
	// Wire name: 'subject'
	Subject string `json:"subject,omitempty"`
	// The claim that contains the subject of the token. If unspecified, the
	// default value is 'sub'.
	// Wire name: 'subject_claim'
	SubjectClaim string `json:"subject_claim,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *OidcFederationPolicy) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &oidcFederationPolicyPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := oidcFederationPolicyFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st OidcFederationPolicy) MarshalJSON() ([]byte, error) {
	pb, err := oidcFederationPolicyToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type PublishedAppOutput struct {
	// Unique ID of the published OAuth app.
	// Wire name: 'app_id'
	AppId string `json:"app_id,omitempty"`
	// Client ID of the published OAuth app. It is the client_id in the OAuth
	// flow
	// Wire name: 'client_id'
	ClientId string `json:"client_id,omitempty"`
	// Description of the published OAuth app.
	// Wire name: 'description'
	Description string `json:"description,omitempty"`
	// Whether the published OAuth app is a confidential client. It is always
	// false for published OAuth apps.
	// Wire name: 'is_confidential_client'
	IsConfidentialClient bool `json:"is_confidential_client,omitempty"`
	// The display name of the published OAuth app.
	// Wire name: 'name'
	Name string `json:"name,omitempty"`
	// Redirect URLs of the published OAuth app.
	// Wire name: 'redirect_urls'
	RedirectUrls []string `json:"redirect_urls,omitempty"`
	// Required scopes for the published OAuth app.
	// Wire name: 'scopes'
	Scopes []string `json:"scopes,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *PublishedAppOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &publishedAppOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := publishedAppOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st PublishedAppOutput) MarshalJSON() ([]byte, error) {
	pb, err := publishedAppOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type SecretInfo struct {
	// UTC time when the secret was created
	// Wire name: 'create_time'
	CreateTime string `json:"create_time,omitempty"`
	// UTC time when the secret will expire. If the field is not present, the
	// secret does not expire.
	// Wire name: 'expire_time'
	ExpireTime string `json:"expire_time,omitempty"`
	// ID of the secret
	// Wire name: 'id'
	Id string `json:"id,omitempty"`
	// Secret Hash
	// Wire name: 'secret_hash'
	SecretHash string `json:"secret_hash,omitempty"`
	// Status of the secret
	// Wire name: 'status'
	Status string `json:"status,omitempty"`
	// UTC time when the secret was updated
	// Wire name: 'update_time'
	UpdateTime string `json:"update_time,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *SecretInfo) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &secretInfoPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := secretInfoFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st SecretInfo) MarshalJSON() ([]byte, error) {
	pb, err := secretInfoToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type TokenAccessPolicy struct {
	// access token time to live in minutes
	// Wire name: 'access_token_ttl_in_minutes'
	AccessTokenTtlInMinutes int `json:"access_token_ttl_in_minutes,omitempty"`
	// refresh token time to live in minutes
	// Wire name: 'refresh_token_ttl_in_minutes'
	RefreshTokenTtlInMinutes int `json:"refresh_token_ttl_in_minutes,omitempty"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *TokenAccessPolicy) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &tokenAccessPolicyPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := tokenAccessPolicyFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st TokenAccessPolicy) MarshalJSON() ([]byte, error) {
	pb, err := tokenAccessPolicyToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Update account federation policy
type UpdateAccountFederationPolicyRequest struct {

	// Wire name: 'policy'
	Policy FederationPolicy `json:"policy"`
	// The identifier for the federation policy.
	PolicyId string `json:"-" tf:"-"`
	// The field mask specifies which fields of the policy to update. To specify
	// multiple fields in the field mask, use comma as the separator (no space).
	// The special value '*' indicates that all fields should be updated (full
	// replacement). If unspecified, all fields that are set in the policy
	// provided in the update request will overwrite the corresponding fields in
	// the existing policy. Example value: 'description,oidc_policy.audiences'.
	UpdateMask string `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *UpdateAccountFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &updateAccountFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := updateAccountFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st UpdateAccountFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := updateAccountFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type UpdateCustomAppIntegration struct {
	IntegrationId string `json:"-" tf:"-"`
	// List of OAuth redirect urls to be updated in the custom OAuth app
	// integration
	// Wire name: 'redirect_urls'
	RedirectUrls []string `json:"redirect_urls,omitempty"`
	// List of OAuth scopes to be updated in the custom OAuth app integration,
	// similar to redirect URIs this will fully replace the existing values
	// instead of appending
	// Wire name: 'scopes'
	Scopes []string `json:"scopes,omitempty"`
	// Token access policy to be updated in the custom OAuth app integration
	// Wire name: 'token_access_policy'
	TokenAccessPolicy *TokenAccessPolicy `json:"token_access_policy,omitempty"`
	// Scopes that will need to be consented by end user to mint the access
	// token. If the user does not authorize the access token will not be
	// minted. Must be a subset of scopes.
	// Wire name: 'user_authorized_scopes'
	UserAuthorizedScopes []string `json:"user_authorized_scopes,omitempty"`
}

func (st *UpdateCustomAppIntegration) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &updateCustomAppIntegrationPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := updateCustomAppIntegrationFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st UpdateCustomAppIntegration) MarshalJSON() ([]byte, error) {
	pb, err := updateCustomAppIntegrationToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type UpdateCustomAppIntegrationOutput struct {
}

func (st *UpdateCustomAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &updateCustomAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := updateCustomAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st UpdateCustomAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := updateCustomAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type UpdatePublishedAppIntegration struct {
	IntegrationId string `json:"-" tf:"-"`
	// Token access policy to be updated in the published OAuth app integration
	// Wire name: 'token_access_policy'
	TokenAccessPolicy *TokenAccessPolicy `json:"token_access_policy,omitempty"`
}

func (st *UpdatePublishedAppIntegration) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &updatePublishedAppIntegrationPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := updatePublishedAppIntegrationFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st UpdatePublishedAppIntegration) MarshalJSON() ([]byte, error) {
	pb, err := updatePublishedAppIntegrationToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

type UpdatePublishedAppIntegrationOutput struct {
}

func (st *UpdatePublishedAppIntegrationOutput) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &updatePublishedAppIntegrationOutputPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := updatePublishedAppIntegrationOutputFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st UpdatePublishedAppIntegrationOutput) MarshalJSON() ([]byte, error) {
	pb, err := updatePublishedAppIntegrationOutputToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}

// Update service principal federation policy
type UpdateServicePrincipalFederationPolicyRequest struct {

	// Wire name: 'policy'
	Policy FederationPolicy `json:"policy"`
	// The identifier for the federation policy.
	PolicyId string `json:"-" tf:"-"`
	// The service principal id for the federation policy.
	ServicePrincipalId int64 `json:"-" tf:"-"`
	// The field mask specifies which fields of the policy to update. To specify
	// multiple fields in the field mask, use comma as the separator (no space).
	// The special value '*' indicates that all fields should be updated (full
	// replacement). If unspecified, all fields that are set in the policy
	// provided in the update request will overwrite the corresponding fields in
	// the existing policy. Example value: 'description,oidc_policy.audiences'.
	UpdateMask string `json:"-" tf:"-"`

	ForceSendFields []string `json:"-" tf:"-"`
}

func (st *UpdateServicePrincipalFederationPolicyRequest) UnmarshalJSON(b []byte) error {
	if st == nil {
		return fmt.Errorf("json.Unmarshal on nil pointer")
	}
	pb := &updateServicePrincipalFederationPolicyRequestPb{}
	err := json.Unmarshal(b, pb)
	if err != nil {
		return err
	}
	tmp, err := updateServicePrincipalFederationPolicyRequestFromPb(pb)
	if err != nil {
		return err
	}
	*st = *tmp
	return nil
}

func (st UpdateServicePrincipalFederationPolicyRequest) MarshalJSON() ([]byte, error) {
	pb, err := updateServicePrincipalFederationPolicyRequestToPb(&st)
	if err != nil {
		return nil, err
	}
	return json.Marshal(pb)
}
