// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Clean Room Asset Revisions, Clean Room Assets, Clean Room Auto Approval Rules, Clean Room Task Runs, Clean Rooms, etc.
package cleanrooms

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type CleanRoomAssetRevisionsInterface interface {

	// Get a specific revision of an asset
	Get(ctx context.Context, request GetCleanRoomAssetRevisionRequest) (*CleanRoomAsset, error)

	// List revisions for an asset
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListCleanRoomAssetRevisionsRequest) listing.Iterator[CleanRoomAsset]

	// List revisions for an asset
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListCleanRoomAssetRevisionsRequest) ([]CleanRoomAsset, error)
}

func NewCleanRoomAssetRevisions(client *client.DatabricksClient) *CleanRoomAssetRevisionsAPI {
	return &CleanRoomAssetRevisionsAPI{
		cleanRoomAssetRevisionsImpl: cleanRoomAssetRevisionsImpl{
			client: client,
		},
	}
}

// Clean Room Asset Revisions denote new versions of uploaded assets (e.g.
// notebooks) in the clean room.
type CleanRoomAssetRevisionsAPI struct {
	cleanRoomAssetRevisionsImpl
}

type CleanRoomAssetsInterface interface {

	// Create a clean room asset —share an asset like a notebook or table into the
	// clean room. For each UC asset that is added through this method, the clean
	// room owner must also have enough privilege on the asset to consume it. The
	// privilege must be maintained indefinitely for the clean room to be able to
	// access the asset. Typically, you should use a group as the clean room owner.
	Create(ctx context.Context, request CreateCleanRoomAssetRequest) (*CleanRoomAsset, error)

	// Submit an asset review
	CreateCleanRoomAssetReview(ctx context.Context, request CreateCleanRoomAssetReviewRequest) (*CreateCleanRoomAssetReviewResponse, error)

	// Delete a clean room asset - unshare/remove the asset from the clean room
	Delete(ctx context.Context, request DeleteCleanRoomAssetRequest) error

	// Delete a clean room asset - unshare/remove the asset from the clean room
	DeleteByCleanRoomNameAndAssetTypeAndName(ctx context.Context, cleanRoomName string, assetType CleanRoomAssetAssetType, name string) error

	// Get the details of a clean room asset by its type and full name.
	Get(ctx context.Context, request GetCleanRoomAssetRequest) (*CleanRoomAsset, error)

	// Get the details of a clean room asset by its type and full name.
	GetByCleanRoomNameAndAssetTypeAndName(ctx context.Context, cleanRoomName string, assetType CleanRoomAssetAssetType, name string) (*CleanRoomAsset, error)

	// List assets.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListCleanRoomAssetsRequest) listing.Iterator[CleanRoomAsset]

	// List assets.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListCleanRoomAssetsRequest) ([]CleanRoomAsset, error)

	// List assets.
	ListByCleanRoomName(ctx context.Context, cleanRoomName string) (*ListCleanRoomAssetsResponse, error)

	// Update a clean room asset. For example, updating the content of a notebook;
	// changing the shared partitions of a table; etc.
	Update(ctx context.Context, request UpdateCleanRoomAssetRequest) (*CleanRoomAsset, error)
}

func NewCleanRoomAssets(client *client.DatabricksClient) *CleanRoomAssetsAPI {
	return &CleanRoomAssetsAPI{
		cleanRoomAssetsImpl: cleanRoomAssetsImpl{
			client: client,
		},
	}
}

// Clean room assets are data and code objects — Tables, volumes, and
// notebooks that are shared with the clean room.
type CleanRoomAssetsAPI struct {
	cleanRoomAssetsImpl
}

// Delete a clean room asset - unshare/remove the asset from the clean room
func (a *CleanRoomAssetsAPI) DeleteByCleanRoomNameAndAssetTypeAndName(ctx context.Context, cleanRoomName string, assetType CleanRoomAssetAssetType, name string) error {
	return a.cleanRoomAssetsImpl.Delete(ctx, DeleteCleanRoomAssetRequest{
		CleanRoomName: cleanRoomName,
		AssetType:     assetType,
		Name:          name,
	})
}

// Get the details of a clean room asset by its type and full name.
func (a *CleanRoomAssetsAPI) GetByCleanRoomNameAndAssetTypeAndName(ctx context.Context, cleanRoomName string, assetType CleanRoomAssetAssetType, name string) (*CleanRoomAsset, error) {
	return a.cleanRoomAssetsImpl.Get(ctx, GetCleanRoomAssetRequest{
		CleanRoomName: cleanRoomName,
		AssetType:     assetType,
		Name:          name,
	})
}

// List assets.
func (a *CleanRoomAssetsAPI) ListByCleanRoomName(ctx context.Context, cleanRoomName string) (*ListCleanRoomAssetsResponse, error) {
	return a.cleanRoomAssetsImpl.internalList(ctx, ListCleanRoomAssetsRequest{
		CleanRoomName: cleanRoomName,
	})
}

type CleanRoomAutoApprovalRulesInterface interface {

	// Create an auto-approval rule
	Create(ctx context.Context, request CreateCleanRoomAutoApprovalRuleRequest) (*CleanRoomAutoApprovalRule, error)

	// Delete a auto-approval rule by rule ID
	Delete(ctx context.Context, request DeleteCleanRoomAutoApprovalRuleRequest) error

	// Get a auto-approval rule by rule ID
	Get(ctx context.Context, request GetCleanRoomAutoApprovalRuleRequest) (*CleanRoomAutoApprovalRule, error)

	// List all auto-approval rules for the caller
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListCleanRoomAutoApprovalRulesRequest) listing.Iterator[CleanRoomAutoApprovalRule]

	// List all auto-approval rules for the caller
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListCleanRoomAutoApprovalRulesRequest) ([]CleanRoomAutoApprovalRule, error)

	// Update a auto-approval rule by rule ID
	Update(ctx context.Context, request UpdateCleanRoomAutoApprovalRuleRequest) (*CleanRoomAutoApprovalRule, error)
}

func NewCleanRoomAutoApprovalRules(client *client.DatabricksClient) *CleanRoomAutoApprovalRulesAPI {
	return &CleanRoomAutoApprovalRulesAPI{
		cleanRoomAutoApprovalRulesImpl: cleanRoomAutoApprovalRulesImpl{
			client: client,
		},
	}
}

// Clean room auto-approval rules automatically create an approval on your
// behalf when an asset (e.g. notebook) meeting specific criteria is shared in a
// clean room.
type CleanRoomAutoApprovalRulesAPI struct {
	cleanRoomAutoApprovalRulesImpl
}

type CleanRoomTaskRunsInterface interface {

	// List all the historical notebook task runs in a clean room.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListCleanRoomNotebookTaskRunsRequest) listing.Iterator[CleanRoomNotebookTaskRun]

	// List all the historical notebook task runs in a clean room.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListCleanRoomNotebookTaskRunsRequest) ([]CleanRoomNotebookTaskRun, error)

	// List all the historical notebook task runs in a clean room.
	ListByCleanRoomName(ctx context.Context, cleanRoomName string) (*ListCleanRoomNotebookTaskRunsResponse, error)
}

func NewCleanRoomTaskRuns(client *client.DatabricksClient) *CleanRoomTaskRunsAPI {
	return &CleanRoomTaskRunsAPI{
		cleanRoomTaskRunsImpl: cleanRoomTaskRunsImpl{
			client: client,
		},
	}
}

// Clean room task runs are the executions of notebooks in a clean room.
type CleanRoomTaskRunsAPI struct {
	cleanRoomTaskRunsImpl
}

// List all the historical notebook task runs in a clean room.
func (a *CleanRoomTaskRunsAPI) ListByCleanRoomName(ctx context.Context, cleanRoomName string) (*ListCleanRoomNotebookTaskRunsResponse, error) {
	return a.cleanRoomTaskRunsImpl.internalList(ctx, ListCleanRoomNotebookTaskRunsRequest{
		CleanRoomName: cleanRoomName,
	})
}

type CleanRoomsInterface interface {

	// WaitGetCleanRoomActive repeatedly calls [CleanRoomsAPI.Get] and waits to reach ACTIVE state
	WaitGetCleanRoomActive(ctx context.Context, name string,
		timeout time.Duration, callback func(*CleanRoom)) (*CleanRoom, error)

	// Create a new clean room with the specified collaborators. This method is
	// asynchronous; the returned name field inside the clean_room field can be used
	// to poll the clean room status, using the :method:cleanrooms/get method. When
	// this method returns, the clean room will be in a PROVISIONING state, with
	// only name, owner, comment, created_at and status populated. The clean room
	// will be usable once it enters an ACTIVE state.
	//
	// The caller must be a metastore admin or have the **CREATE_CLEAN_ROOM**
	// privilege on the metastore.
	Create(ctx context.Context, createCleanRoomRequest CreateCleanRoomRequest) (*WaitGetCleanRoomActive[CleanRoom], error)

	// Calls [CleanRoomsAPIInterface.Create] and waits to reach ACTIVE state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[CleanRoom](60*time.Minute) functional option.
	//
	// Deprecated: use [CleanRoomsAPIInterface.Create].Get() or [CleanRoomsAPIInterface.WaitGetCleanRoomActive]
	CreateAndWait(ctx context.Context, createCleanRoomRequest CreateCleanRoomRequest, options ...retries.Option[CleanRoom]) (*CleanRoom, error)

	// Create the output catalog of the clean room.
	CreateOutputCatalog(ctx context.Context, request CreateCleanRoomOutputCatalogRequest) (*CreateCleanRoomOutputCatalogResponse, error)

	// Delete a clean room. After deletion, the clean room will be removed from the
	// metastore. If the other collaborators have not deleted the clean room, they
	// will still have the clean room in their metastore, but it will be in a
	// DELETED state and no operations other than deletion can be performed on it.
	Delete(ctx context.Context, request DeleteCleanRoomRequest) error

	// Delete a clean room. After deletion, the clean room will be removed from the
	// metastore. If the other collaborators have not deleted the clean room, they
	// will still have the clean room in their metastore, but it will be in a
	// DELETED state and no operations other than deletion can be performed on it.
	DeleteByName(ctx context.Context, name string) error

	// Get the details of a clean room given its name.
	Get(ctx context.Context, request GetCleanRoomRequest) (*CleanRoom, error)

	// Get the details of a clean room given its name.
	GetByName(ctx context.Context, name string) (*CleanRoom, error)

	// Get a list of all clean rooms of the metastore. Only clean rooms the caller
	// has access to are returned.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListCleanRoomsRequest) listing.Iterator[CleanRoom]

	// Get a list of all clean rooms of the metastore. Only clean rooms the caller
	// has access to are returned.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListCleanRoomsRequest) ([]CleanRoom, error)

	// Update a clean room. The caller must be the owner of the clean room, have
	// **MODIFY_CLEAN_ROOM** privilege, or be metastore admin.
	//
	// When the caller is a metastore admin, only the __owner__ field can be
	// updated.
	Update(ctx context.Context, request UpdateCleanRoomRequest) (*CleanRoom, error)
}

func NewCleanRooms(client *client.DatabricksClient) *CleanRoomsAPI {
	return &CleanRoomsAPI{
		cleanRoomsImpl: cleanRoomsImpl{
			client: client,
		},
	}
}

// A clean room uses Delta Sharing and serverless compute to provide a secure
// and privacy-protecting environment where multiple parties can work together
// on sensitive enterprise data without direct access to each other's data.
type CleanRoomsAPI struct {
	cleanRoomsImpl
}

// WaitGetCleanRoomActive repeatedly calls [CleanRoomsAPI.Get] and waits to reach ACTIVE state
func (a *CleanRoomsAPI) WaitGetCleanRoomActive(ctx context.Context, name string,
	timeout time.Duration, callback func(*CleanRoom)) (*CleanRoom, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[CleanRoom](ctx, timeout, func() (*CleanRoom, *retries.Err) {
		cleanRoom, err := a.Get(ctx, GetCleanRoomRequest{
			Name: name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(cleanRoom)
		}
		status := cleanRoom.Status
		statusMessage := fmt.Sprintf("current status: %s", status)
		switch status {
		case CleanRoomStatusEnumActive: // target state
			return cleanRoom, nil
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetCleanRoomActive is a wrapper that calls [CleanRoomsAPI.WaitGetCleanRoomActive] and waits to reach ACTIVE state.
type WaitGetCleanRoomActive[R any] struct {
	Response *R
	Name     string `json:"name"`
	Poll     func(time.Duration, func(*CleanRoom)) (*CleanRoom, error)
	callback func(*CleanRoom)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetCleanRoomActive[R]) OnProgress(callback func(*CleanRoom)) *WaitGetCleanRoomActive[R] {
	w.callback = callback
	return w
}

// Get the CleanRoom with the default timeout of 20 minutes.
func (w *WaitGetCleanRoomActive[R]) Get() (*CleanRoom, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the CleanRoom with custom timeout.
func (w *WaitGetCleanRoomActive[R]) GetWithTimeout(timeout time.Duration) (*CleanRoom, error) {
	return w.Poll(timeout, w.callback)
}

// Create a new clean room with the specified collaborators. This method is
// asynchronous; the returned name field inside the clean_room field can be used
// to poll the clean room status, using the :method:cleanrooms/get method. When
// this method returns, the clean room will be in a PROVISIONING state, with
// only name, owner, comment, created_at and status populated. The clean room
// will be usable once it enters an ACTIVE state.
//
// The caller must be a metastore admin or have the **CREATE_CLEAN_ROOM**
// privilege on the metastore.
func (a *CleanRoomsAPI) Create(ctx context.Context, createCleanRoomRequest CreateCleanRoomRequest) (*WaitGetCleanRoomActive[CleanRoom], error) {
	cleanRoom, err := a.cleanRoomsImpl.Create(ctx, createCleanRoomRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetCleanRoomActive[CleanRoom]{
		Response: cleanRoom,
		Name:     cleanRoom.Name,
		Poll: func(timeout time.Duration, callback func(*CleanRoom)) (*CleanRoom, error) {
			return a.WaitGetCleanRoomActive(ctx, cleanRoom.Name, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [CleanRoomsAPI.Create] and waits to reach ACTIVE state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[CleanRoom](60*time.Minute) functional option.
//
// Deprecated: use [CleanRoomsAPI.Create].Get() or [CleanRoomsAPI.WaitGetCleanRoomActive]
func (a *CleanRoomsAPI) CreateAndWait(ctx context.Context, createCleanRoomRequest CreateCleanRoomRequest, options ...retries.Option[CleanRoom]) (*CleanRoom, error) {
	wait, err := a.Create(ctx, createCleanRoomRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[CleanRoom]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *CleanRoom) {
		for _, o := range options {
			o(&retries.Info[CleanRoom]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Delete a clean room. After deletion, the clean room will be removed from the
// metastore. If the other collaborators have not deleted the clean room, they
// will still have the clean room in their metastore, but it will be in a
// DELETED state and no operations other than deletion can be performed on it.
func (a *CleanRoomsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.cleanRoomsImpl.Delete(ctx, DeleteCleanRoomRequest{
		Name: name,
	})
}

// Get the details of a clean room given its name.
func (a *CleanRoomsAPI) GetByName(ctx context.Context, name string) (*CleanRoom, error) {
	return a.cleanRoomsImpl.Get(ctx, GetCleanRoomRequest{
		Name: name,
	})
}
