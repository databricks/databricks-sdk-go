// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Ip Access Lists, Account Settings, Aibi Dashboard Embedding Access Policy, Aibi Dashboard Embedding Approved Domains, Automatic Cluster Update, Compliance Security Profile, Credentials Manager, Csp Enablement Account, Default Namespace, Disable Legacy Access, Disable Legacy Dbfs, Disable Legacy Features, Enable Ip Access Lists, Enhanced Security Monitoring, Esm Enablement Account, Ip Access Lists, Network Connectivity, Notification Destinations, Personal Compute, Restrict Workspace Admins, Settings, Token Management, Tokens, Workspace Conf, etc.
package settings

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AccountIpAccessListsInterface interface {

	// Create access list.
	//
	// Creates an IP access list for the account.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteAccountIpAccessListRequest) error

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Get IP access list.
	//
	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetAccountIpAccessListRequest) (*GetIpAccessListResponse, error)

	// Get IP access list.
	//
	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error)

	// Get access lists.
	//
	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Get access lists.
	//
	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replace access list.
	//
	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Update access list.
	//
	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewAccountIpAccessLists(client *client.DatabricksClient) *AccountIpAccessListsAPI {
	return &AccountIpAccessListsAPI{
		accountIpAccessListsImpl: accountIpAccessListsImpl{
			client: client,
		},
	}
}

// The Accounts IP Access List API enables account admins to configure IP access
// lists for access to the account console.
//
// Account IP Access Lists affect web application access and REST API access to
// the account console and account APIs. If the feature is disabled for the
// account, all access is allowed for this account. There is support for allow
// lists (inclusion) and block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the account, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the account, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the account supports a maximum
// of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the account-level IP access lists, it can take a few minutes
// for changes to take effect.
type AccountIpAccessListsAPI struct {
	accountIpAccessListsImpl
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.accountIpAccessListsImpl.Delete(ctx, DeleteAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get IP access list.
//
// Gets an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error) {
	return a.accountIpAccessListsImpl.Get(ctx, GetAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type AccountSettingsInterface interface {

	// The compliance security profile settings at the account level control
	// whether to enable it for new workspaces. By default, this account-level
	// setting is disabled for new workspaces. After workspace creation, account
	// admins can enable the compliance security profile individually for each
	// workspace.
	//
	// This settings can be disabled so that new workspaces do not have
	// compliance security profile enabled by default.
	CspEnablementAccount() CspEnablementAccountInterface

	// Disable legacy features for new Databricks workspaces.
	//
	// For newly created workspaces: 1. Disables the use of DBFS root and
	// mounts. 2. Hive Metastore will not be provisioned. 3. Disables the use of
	// ‘No-isolation clusters’. 4. Disables Databricks Runtime versions
	// prior to 13.3LTS.
	DisableLegacyFeatures() DisableLegacyFeaturesInterface

	// Controls the enforcement of IP access lists for accessing the account
	// console. Allowing you to enable or disable restricted access based on IP
	// addresses.
	EnableIpAccessLists() EnableIpAccessListsInterface

	// The enhanced security monitoring setting at the account level controls
	// whether to enable the feature on new workspaces. By default, this
	// account-level setting is disabled for new workspaces. After workspace
	// creation, account admins can enable enhanced security monitoring
	// individually for each workspace.
	EsmEnablementAccount() EsmEnablementAccountInterface

	// The Personal Compute enablement setting lets you control which users can
	// use the Personal Compute default policy to create compute resources. By
	// default all users in all workspaces have access (ON), but you can change
	// the setting to instead let individual workspaces configure access control
	// (DELEGATE).
	//
	// There is only one instance of this setting per account. Since this
	// setting has a default value, this setting is present on all accounts even
	// though it's never set on a given account. Deletion reverts the value of
	// the setting back to the default value.
	PersonalCompute() PersonalComputeInterface
}

func NewAccountSettings(client *client.DatabricksClient) *AccountSettingsAPI {
	return &AccountSettingsAPI{
		accountSettingsImpl: accountSettingsImpl{
			client: client,
		},

		cspEnablementAccount: NewCspEnablementAccount(client),

		disableLegacyFeatures: NewDisableLegacyFeatures(client),

		enableIpAccessLists: NewEnableIpAccessLists(client),

		esmEnablementAccount: NewEsmEnablementAccount(client),

		personalCompute: NewPersonalCompute(client),
	}
}

// Accounts Settings API allows users to manage settings at the account level.
type AccountSettingsAPI struct {
	accountSettingsImpl

	// The compliance security profile settings at the account level control
	// whether to enable it for new workspaces. By default, this account-level
	// setting is disabled for new workspaces. After workspace creation, account
	// admins can enable the compliance security profile individually for each
	// workspace.
	//
	// This settings can be disabled so that new workspaces do not have
	// compliance security profile enabled by default.
	cspEnablementAccount CspEnablementAccountInterface

	// Disable legacy features for new Databricks workspaces.
	//
	// For newly created workspaces: 1. Disables the use of DBFS root and
	// mounts. 2. Hive Metastore will not be provisioned. 3. Disables the use of
	// ‘No-isolation clusters’. 4. Disables Databricks Runtime versions
	// prior to 13.3LTS.
	disableLegacyFeatures DisableLegacyFeaturesInterface

	// Controls the enforcement of IP access lists for accessing the account
	// console. Allowing you to enable or disable restricted access based on IP
	// addresses.
	enableIpAccessLists EnableIpAccessListsInterface

	// The enhanced security monitoring setting at the account level controls
	// whether to enable the feature on new workspaces. By default, this
	// account-level setting is disabled for new workspaces. After workspace
	// creation, account admins can enable enhanced security monitoring
	// individually for each workspace.
	esmEnablementAccount EsmEnablementAccountInterface

	// The Personal Compute enablement setting lets you control which users can
	// use the Personal Compute default policy to create compute resources. By
	// default all users in all workspaces have access (ON), but you can change
	// the setting to instead let individual workspaces configure access control
	// (DELEGATE).
	//
	// There is only one instance of this setting per account. Since this
	// setting has a default value, this setting is present on all accounts even
	// though it's never set on a given account. Deletion reverts the value of
	// the setting back to the default value.
	personalCompute PersonalComputeInterface
}

func (a *AccountSettingsAPI) CspEnablementAccount() CspEnablementAccountInterface {
	return a.cspEnablementAccount
}

func (a *AccountSettingsAPI) DisableLegacyFeatures() DisableLegacyFeaturesInterface {
	return a.disableLegacyFeatures
}

func (a *AccountSettingsAPI) EnableIpAccessLists() EnableIpAccessListsInterface {
	return a.enableIpAccessLists
}

func (a *AccountSettingsAPI) EsmEnablementAccount() EsmEnablementAccountInterface {
	return a.esmEnablementAccount
}

func (a *AccountSettingsAPI) PersonalCompute() PersonalComputeInterface {
	return a.personalCompute
}

type AibiDashboardEmbeddingAccessPolicyInterface interface {

	// Delete the AI/BI dashboard embedding access policy.
	//
	// Delete the AI/BI dashboard embedding access policy, reverting back to the
	// default.
	Delete(ctx context.Context, request DeleteAibiDashboardEmbeddingAccessPolicySettingRequest) (*DeleteAibiDashboardEmbeddingAccessPolicySettingResponse, error)

	// Retrieve the AI/BI dashboard embedding access policy.
	//
	// Retrieves the AI/BI dashboard embedding access policy. The default setting is
	// ALLOW_APPROVED_DOMAINS, permitting AI/BI dashboards to be embedded on
	// approved domains.
	Get(ctx context.Context, request GetAibiDashboardEmbeddingAccessPolicySettingRequest) (*AibiDashboardEmbeddingAccessPolicySetting, error)

	// Update the AI/BI dashboard embedding access policy.
	//
	// Updates the AI/BI dashboard embedding access policy at the workspace level.
	Update(ctx context.Context, request UpdateAibiDashboardEmbeddingAccessPolicySettingRequest) (*AibiDashboardEmbeddingAccessPolicySetting, error)
}

func NewAibiDashboardEmbeddingAccessPolicy(client *client.DatabricksClient) *AibiDashboardEmbeddingAccessPolicyAPI {
	return &AibiDashboardEmbeddingAccessPolicyAPI{
		aibiDashboardEmbeddingAccessPolicyImpl: aibiDashboardEmbeddingAccessPolicyImpl{
			client: client,
		},
	}
}

// Controls whether AI/BI published dashboard embedding is enabled,
// conditionally enabled, or disabled at the workspace level. By default, this
// setting is conditionally enabled (ALLOW_APPROVED_DOMAINS).
type AibiDashboardEmbeddingAccessPolicyAPI struct {
	aibiDashboardEmbeddingAccessPolicyImpl
}

type AibiDashboardEmbeddingApprovedDomainsInterface interface {

	// Delete AI/BI dashboard embedding approved domains.
	//
	// Delete the list of domains approved to host embedded AI/BI dashboards,
	// reverting back to the default empty list.
	Delete(ctx context.Context, request DeleteAibiDashboardEmbeddingApprovedDomainsSettingRequest) (*DeleteAibiDashboardEmbeddingApprovedDomainsSettingResponse, error)

	// Retrieve the list of domains approved to host embedded AI/BI dashboards.
	//
	// Retrieves the list of domains approved to host embedded AI/BI dashboards.
	Get(ctx context.Context, request GetAibiDashboardEmbeddingApprovedDomainsSettingRequest) (*AibiDashboardEmbeddingApprovedDomainsSetting, error)

	// Update the list of domains approved to host embedded AI/BI dashboards.
	//
	// Updates the list of domains approved to host embedded AI/BI dashboards. This
	// update will fail if the current workspace access policy is not
	// ALLOW_APPROVED_DOMAINS.
	Update(ctx context.Context, request UpdateAibiDashboardEmbeddingApprovedDomainsSettingRequest) (*AibiDashboardEmbeddingApprovedDomainsSetting, error)
}

func NewAibiDashboardEmbeddingApprovedDomains(client *client.DatabricksClient) *AibiDashboardEmbeddingApprovedDomainsAPI {
	return &AibiDashboardEmbeddingApprovedDomainsAPI{
		aibiDashboardEmbeddingApprovedDomainsImpl: aibiDashboardEmbeddingApprovedDomainsImpl{
			client: client,
		},
	}
}

// Controls the list of domains approved to host the embedded AI/BI dashboards.
// The approved domains list can't be mutated when the current access policy is
// not set to ALLOW_APPROVED_DOMAINS.
type AibiDashboardEmbeddingApprovedDomainsAPI struct {
	aibiDashboardEmbeddingApprovedDomainsImpl
}

type AutomaticClusterUpdateInterface interface {

	// Get the automatic cluster update setting.
	//
	// Gets the automatic cluster update setting.
	Get(ctx context.Context, request GetAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error)

	// Update the automatic cluster update setting.
	//
	// Updates the automatic cluster update setting for the workspace. A fresh etag
	// needs to be provided in `PATCH` requests (as part of the setting field). The
	// etag can be retrieved by making a `GET` request before the `PATCH` request.
	// If the setting is updated concurrently, `PATCH` fails with 409 and the
	// request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error)
}

func NewAutomaticClusterUpdate(client *client.DatabricksClient) *AutomaticClusterUpdateAPI {
	return &AutomaticClusterUpdateAPI{
		automaticClusterUpdateImpl: automaticClusterUpdateImpl{
			client: client,
		},
	}
}

// Controls whether automatic cluster update is enabled for the current
// workspace. By default, it is turned off.
type AutomaticClusterUpdateAPI struct {
	automaticClusterUpdateImpl
}

type ComplianceSecurityProfileInterface interface {

	// Get the compliance security profile setting.
	//
	// Gets the compliance security profile setting.
	Get(ctx context.Context, request GetComplianceSecurityProfileSettingRequest) (*ComplianceSecurityProfileSetting, error)

	// Update the compliance security profile setting.
	//
	// Updates the compliance security profile setting for the workspace. A fresh
	// etag needs to be provided in `PATCH` requests (as part of the setting field).
	// The etag can be retrieved by making a `GET` request before the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateComplianceSecurityProfileSettingRequest) (*ComplianceSecurityProfileSetting, error)
}

func NewComplianceSecurityProfile(client *client.DatabricksClient) *ComplianceSecurityProfileAPI {
	return &ComplianceSecurityProfileAPI{
		complianceSecurityProfileImpl: complianceSecurityProfileImpl{
			client: client,
		},
	}
}

// Controls whether to enable the compliance security profile for the current
// workspace. Enabling it on a workspace is permanent. By default, it is turned
// off.
//
// This settings can NOT be disabled once it is enabled.
type ComplianceSecurityProfileAPI struct {
	complianceSecurityProfileImpl
}

type CredentialsManagerInterface interface {

	// Exchange token.
	//
	// Exchange tokens with an Identity Provider to get a new access token. It
	// allows specifying scopes to determine token permissions.
	ExchangeToken(ctx context.Context, request ExchangeTokenRequest) (*ExchangeTokenResponse, error)
}

func NewCredentialsManager(client *client.DatabricksClient) *CredentialsManagerAPI {
	return &CredentialsManagerAPI{
		credentialsManagerImpl: credentialsManagerImpl{
			client: client,
		},
	}
}

// Credentials manager interacts with with Identity Providers to to perform
// token exchanges using stored credentials and refresh tokens.
type CredentialsManagerAPI struct {
	credentialsManagerImpl
}

type CspEnablementAccountInterface interface {

	// Get the compliance security profile setting for new workspaces.
	//
	// Gets the compliance security profile setting for new workspaces.
	Get(ctx context.Context, request GetCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error)

	// Update the compliance security profile setting for new workspaces.
	//
	// Updates the value of the compliance security profile setting for new
	// workspaces.
	Update(ctx context.Context, request UpdateCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error)
}

func NewCspEnablementAccount(client *client.DatabricksClient) *CspEnablementAccountAPI {
	return &CspEnablementAccountAPI{
		cspEnablementAccountImpl: cspEnablementAccountImpl{
			client: client,
		},
	}
}

// The compliance security profile settings at the account level control whether
// to enable it for new workspaces. By default, this account-level setting is
// disabled for new workspaces. After workspace creation, account admins can
// enable the compliance security profile individually for each workspace.
//
// This settings can be disabled so that new workspaces do not have compliance
// security profile enabled by default.
type CspEnablementAccountAPI struct {
	cspEnablementAccountImpl
}

type DefaultNamespaceInterface interface {

	// Delete the default namespace setting.
	//
	// Deletes the default namespace setting for the workspace. A fresh etag needs
	// to be provided in `DELETE` requests (as a query parameter). The etag can be
	// retrieved by making a `GET` request before the `DELETE` request. If the
	// setting is updated/deleted concurrently, `DELETE` fails with 409 and the
	// request must be retried by using the fresh etag in the 409 response.
	Delete(ctx context.Context, request DeleteDefaultNamespaceSettingRequest) (*DeleteDefaultNamespaceSettingResponse, error)

	// Get the default namespace setting.
	//
	// Gets the default namespace setting.
	Get(ctx context.Context, request GetDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)

	// Update the default namespace setting.
	//
	// Updates the default namespace setting for the workspace. A fresh etag needs
	// to be provided in `PATCH` requests (as part of the setting field). The etag
	// can be retrieved by making a `GET` request before the `PATCH` request. Note
	// that if the setting does not exist, `GET` returns a NOT_FOUND error and the
	// etag is present in the error response, which should be set in the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)
}

func NewDefaultNamespace(client *client.DatabricksClient) *DefaultNamespaceAPI {
	return &DefaultNamespaceAPI{
		defaultNamespaceImpl: defaultNamespaceImpl{
			client: client,
		},
	}
}

// The default namespace setting API allows users to configure the default
// namespace for a Databricks workspace.
//
// Through this API, users can retrieve, set, or modify the default namespace
// used when queries do not reference a fully qualified three-level name. For
// example, if you use the API to set 'retail_prod' as the default catalog, then
// a query 'SELECT * FROM myTable' would reference the object
// 'retail_prod.default.myTable' (the schema 'default' is always assumed).
//
// This setting requires a restart of clusters and SQL warehouses to take
// effect. Additionally, the default namespace only applies when using Unity
// Catalog-enabled compute.
type DefaultNamespaceAPI struct {
	defaultNamespaceImpl
}

type DisableLegacyAccessInterface interface {

	// Delete Legacy Access Disablement Status.
	//
	// Deletes legacy access disablement status.
	Delete(ctx context.Context, request DeleteDisableLegacyAccessRequest) (*DeleteDisableLegacyAccessResponse, error)

	// Retrieve Legacy Access Disablement Status.
	//
	// Retrieves legacy access disablement Status.
	Get(ctx context.Context, request GetDisableLegacyAccessRequest) (*DisableLegacyAccess, error)

	// Update Legacy Access Disablement Status.
	//
	// Updates legacy access disablement status.
	Update(ctx context.Context, request UpdateDisableLegacyAccessRequest) (*DisableLegacyAccess, error)
}

func NewDisableLegacyAccess(client *client.DatabricksClient) *DisableLegacyAccessAPI {
	return &DisableLegacyAccessAPI{
		disableLegacyAccessImpl: disableLegacyAccessImpl{
			client: client,
		},
	}
}

// 'Disabling legacy access' has the following impacts:
//
// 1. Disables direct access to the Hive Metastore. However, you can still
// access Hive Metastore through HMS Federation. 2. Disables Fallback Mode (docs
// link) on any External Location access from the workspace. 3. Alters DBFS path
// access to use External Location permissions in place of legacy credentials.
// 4. Enforces Unity Catalog access on all path based access.
type DisableLegacyAccessAPI struct {
	disableLegacyAccessImpl
}

type DisableLegacyDbfsInterface interface {

	// Delete the disable legacy DBFS setting.
	//
	// Deletes the disable legacy DBFS setting for a workspace, reverting back to
	// the default.
	Delete(ctx context.Context, request DeleteDisableLegacyDbfsRequest) (*DeleteDisableLegacyDbfsResponse, error)

	// Get the disable legacy DBFS setting.
	//
	// Gets the disable legacy DBFS setting.
	Get(ctx context.Context, request GetDisableLegacyDbfsRequest) (*DisableLegacyDbfs, error)

	// Update the disable legacy DBFS setting.
	//
	// Updates the disable legacy DBFS setting for the workspace.
	Update(ctx context.Context, request UpdateDisableLegacyDbfsRequest) (*DisableLegacyDbfs, error)
}

func NewDisableLegacyDbfs(client *client.DatabricksClient) *DisableLegacyDbfsAPI {
	return &DisableLegacyDbfsAPI{
		disableLegacyDbfsImpl: disableLegacyDbfsImpl{
			client: client,
		},
	}
}

// When this setting is on, access to DBFS root and DBFS mounts is disallowed
// (as well as creation of new mounts). When the setting is off, all DBFS
// functionality is enabled
type DisableLegacyDbfsAPI struct {
	disableLegacyDbfsImpl
}

type DisableLegacyFeaturesInterface interface {

	// Delete the disable legacy features setting.
	//
	// Deletes the disable legacy features setting.
	Delete(ctx context.Context, request DeleteDisableLegacyFeaturesRequest) (*DeleteDisableLegacyFeaturesResponse, error)

	// Get the disable legacy features setting.
	//
	// Gets the value of the disable legacy features setting.
	Get(ctx context.Context, request GetDisableLegacyFeaturesRequest) (*DisableLegacyFeatures, error)

	// Update the disable legacy features setting.
	//
	// Updates the value of the disable legacy features setting.
	Update(ctx context.Context, request UpdateDisableLegacyFeaturesRequest) (*DisableLegacyFeatures, error)
}

func NewDisableLegacyFeatures(client *client.DatabricksClient) *DisableLegacyFeaturesAPI {
	return &DisableLegacyFeaturesAPI{
		disableLegacyFeaturesImpl: disableLegacyFeaturesImpl{
			client: client,
		},
	}
}

// Disable legacy features for new Databricks workspaces.
//
// For newly created workspaces: 1. Disables the use of DBFS root and mounts. 2.
// Hive Metastore will not be provisioned. 3. Disables the use of
// ‘No-isolation clusters’. 4. Disables Databricks Runtime versions prior to
// 13.3LTS.
type DisableLegacyFeaturesAPI struct {
	disableLegacyFeaturesImpl
}

type EnableIpAccessListsInterface interface {

	// Delete the account IP access toggle setting.
	//
	// Reverts the value of the account IP access toggle setting to default (ON)
	Delete(ctx context.Context, request DeleteAccountIpAccessEnableRequest) (*DeleteAccountIpAccessEnableResponse, error)

	// Get the account IP access toggle setting.
	//
	// Gets the value of the account IP access toggle setting.
	Get(ctx context.Context, request GetAccountIpAccessEnableRequest) (*AccountIpAccessEnable, error)

	// Update the account IP access toggle setting.
	//
	// Updates the value of the account IP access toggle setting.
	Update(ctx context.Context, request UpdateAccountIpAccessEnableRequest) (*AccountIpAccessEnable, error)
}

func NewEnableIpAccessLists(client *client.DatabricksClient) *EnableIpAccessListsAPI {
	return &EnableIpAccessListsAPI{
		enableIpAccessListsImpl: enableIpAccessListsImpl{
			client: client,
		},
	}
}

// Controls the enforcement of IP access lists for accessing the account
// console. Allowing you to enable or disable restricted access based on IP
// addresses.
type EnableIpAccessListsAPI struct {
	enableIpAccessListsImpl
}

type EnhancedSecurityMonitoringInterface interface {

	// Get the enhanced security monitoring setting.
	//
	// Gets the enhanced security monitoring setting.
	Get(ctx context.Context, request GetEnhancedSecurityMonitoringSettingRequest) (*EnhancedSecurityMonitoringSetting, error)

	// Update the enhanced security monitoring setting.
	//
	// Updates the enhanced security monitoring setting for the workspace. A fresh
	// etag needs to be provided in `PATCH` requests (as part of the setting field).
	// The etag can be retrieved by making a `GET` request before the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateEnhancedSecurityMonitoringSettingRequest) (*EnhancedSecurityMonitoringSetting, error)
}

func NewEnhancedSecurityMonitoring(client *client.DatabricksClient) *EnhancedSecurityMonitoringAPI {
	return &EnhancedSecurityMonitoringAPI{
		enhancedSecurityMonitoringImpl: enhancedSecurityMonitoringImpl{
			client: client,
		},
	}
}

// Controls whether enhanced security monitoring is enabled for the current
// workspace. If the compliance security profile is enabled, this is
// automatically enabled. By default, it is disabled. However, if the compliance
// security profile is enabled, this is automatically enabled.
//
// If the compliance security profile is disabled, you can enable or disable
// this setting and it is not permanent.
type EnhancedSecurityMonitoringAPI struct {
	enhancedSecurityMonitoringImpl
}

type EsmEnablementAccountInterface interface {

	// Get the enhanced security monitoring setting for new workspaces.
	//
	// Gets the enhanced security monitoring setting for new workspaces.
	Get(ctx context.Context, request GetEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error)

	// Update the enhanced security monitoring setting for new workspaces.
	//
	// Updates the value of the enhanced security monitoring setting for new
	// workspaces.
	Update(ctx context.Context, request UpdateEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error)
}

func NewEsmEnablementAccount(client *client.DatabricksClient) *EsmEnablementAccountAPI {
	return &EsmEnablementAccountAPI{
		esmEnablementAccountImpl: esmEnablementAccountImpl{
			client: client,
		},
	}
}

// The enhanced security monitoring setting at the account level controls
// whether to enable the feature on new workspaces. By default, this
// account-level setting is disabled for new workspaces. After workspace
// creation, account admins can enable enhanced security monitoring individually
// for each workspace.
type EsmEnablementAccountAPI struct {
	esmEnablementAccountImpl
}

type IpAccessListsInterface interface {

	// Create access list.
	//
	// Creates an IP access list for this workspace.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. **Note**: Your new
	// IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteIpAccessListRequest) error

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Get access list.
	//
	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetIpAccessListRequest) (*FetchIpAccessListResponse, error)

	// Get access list.
	//
	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error)

	// Get access lists.
	//
	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Get access lists.
	//
	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replace access list.
	//
	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	// Note that your resulting IP access list has no effect until you enable the
	// feature. See :method:workspaceconf/setStatus.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Update access list.
	//
	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. Note that your
	// resulting IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewIpAccessLists(client *client.DatabricksClient) *IpAccessListsAPI {
	return &IpAccessListsAPI{
		ipAccessListsImpl: ipAccessListsImpl{
			client: client,
		},
	}
}

// IP Access List enables admins to configure IP access lists.
//
// IP access lists affect web application access and REST API access to this
// workspace only. If the feature is disabled for a workspace, all access is
// allowed for this workspace. There is support for allow lists (inclusion) and
// block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the workspace, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the workspace, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the workspace supports a
// maximum of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the IP access list feature, it can take a few minutes for
// changes to take effect.
type IpAccessListsAPI struct {
	ipAccessListsImpl
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.ipAccessListsImpl.Delete(ctx, DeleteIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access list.
//
// Gets an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error) {
	return a.ipAccessListsImpl.Get(ctx, GetIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type NetworkConnectivityInterface interface {

	// Create a network connectivity configuration.
	CreateNetworkConnectivityConfiguration(ctx context.Context, request CreateNetworkConnectivityConfigRequest) (*NetworkConnectivityConfiguration, error)

	// Create a private endpoint rule.
	//
	// Create a private endpoint rule for the specified network connectivity config
	// object. Once the object is created, Databricks asynchronously provisions a
	// new Azure private endpoint to your specified Azure resource.
	//
	// **IMPORTANT**: You must use Azure portal or other Azure tools to approve the
	// private endpoint to complete the connection. To get the information of the
	// private endpoint created, make a `GET` request on the new private endpoint
	// rule. See [serverless private link].
	//
	// [serverless private link]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security/serverless-private-link
	CreatePrivateEndpointRule(ctx context.Context, request CreatePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Delete a network connectivity configuration.
	//
	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfiguration(ctx context.Context, request DeleteNetworkConnectivityConfigurationRequest) error

	// Delete a network connectivity configuration.
	//
	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error

	// Delete a private endpoint rule.
	//
	// Initiates deleting a private endpoint rule. If the connection state is
	// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
	// the private endpoint is deactivated and will be deleted after seven days of
	// deactivation. When a private endpoint is deactivated, the `deactivated` field
	// is set to `true` and the private endpoint is not available to your serverless
	// compute resources.
	DeletePrivateEndpointRule(ctx context.Context, request DeletePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Delete a private endpoint rule.
	//
	// Initiates deleting a private endpoint rule. If the connection state is
	// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
	// the private endpoint is deactivated and will be deleted after seven days of
	// deactivation. When a private endpoint is deactivated, the `deactivated` field
	// is set to `true` and the private endpoint is not available to your serverless
	// compute resources.
	DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error)

	// Get a network connectivity configuration.
	//
	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfiguration(ctx context.Context, request GetNetworkConnectivityConfigurationRequest) (*NetworkConnectivityConfiguration, error)

	// Get a network connectivity configuration.
	//
	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error)

	// Get a private endpoint rule.
	//
	// Gets the private endpoint rule.
	GetPrivateEndpointRule(ctx context.Context, request GetPrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Get a private endpoint rule.
	//
	// Gets the private endpoint rule.
	GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error)

	// List network connectivity configurations.
	//
	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurations(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) listing.Iterator[NetworkConnectivityConfiguration]

	// List network connectivity configurations.
	//
	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurationsAll(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) ([]NetworkConnectivityConfiguration, error)

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRules(ctx context.Context, request ListPrivateEndpointRulesRequest) listing.Iterator[NccAzurePrivateEndpointRule]

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRulesAll(ctx context.Context, request ListPrivateEndpointRulesRequest) ([]NccAzurePrivateEndpointRule, error)

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error)
}

func NewNetworkConnectivity(client *client.DatabricksClient) *NetworkConnectivityAPI {
	return &NetworkConnectivityAPI{
		networkConnectivityImpl: networkConnectivityImpl{
			client: client,
		},
	}
}

// These APIs provide configurations for the network connectivity of your
// workspaces for serverless compute resources.
type NetworkConnectivityAPI struct {
	networkConnectivityImpl
}

// Delete a network connectivity configuration.
//
// Deletes a network connectivity configuration.
func (a *NetworkConnectivityAPI) DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error {
	return a.networkConnectivityImpl.DeleteNetworkConnectivityConfiguration(ctx, DeleteNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Delete a private endpoint rule.
//
// Initiates deleting a private endpoint rule. If the connection state is
// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
// the private endpoint is deactivated and will be deleted after seven days of
// deactivation. When a private endpoint is deactivated, the `deactivated` field
// is set to `true` and the private endpoint is not available to your serverless
// compute resources.
func (a *NetworkConnectivityAPI) DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.networkConnectivityImpl.DeletePrivateEndpointRule(ctx, DeletePrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// Get a network connectivity configuration.
//
// Gets a network connectivity configuration.
func (a *NetworkConnectivityAPI) GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error) {
	return a.networkConnectivityImpl.GetNetworkConnectivityConfiguration(ctx, GetNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Get a private endpoint rule.
//
// Gets the private endpoint rule.
func (a *NetworkConnectivityAPI) GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.networkConnectivityImpl.GetPrivateEndpointRule(ctx, GetPrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error) {
	return a.networkConnectivityImpl.internalListPrivateEndpointRules(ctx, ListPrivateEndpointRulesRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

type NotificationDestinationsInterface interface {

	// Create a notification destination.
	//
	// Creates a notification destination. Requires workspace admin permissions.
	Create(ctx context.Context, request CreateNotificationDestinationRequest) (*NotificationDestination, error)

	// Delete a notification destination.
	//
	// Deletes a notification destination. Requires workspace admin permissions.
	Delete(ctx context.Context, request DeleteNotificationDestinationRequest) error

	// Delete a notification destination.
	//
	// Deletes a notification destination. Requires workspace admin permissions.
	DeleteById(ctx context.Context, id string) error

	// Get a notification destination.
	//
	// Gets a notification destination.
	Get(ctx context.Context, request GetNotificationDestinationRequest) (*NotificationDestination, error)

	// Get a notification destination.
	//
	// Gets a notification destination.
	GetById(ctx context.Context, id string) (*NotificationDestination, error)

	// List notification destinations.
	//
	// Lists notification destinations.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListNotificationDestinationsRequest) listing.Iterator[ListNotificationDestinationsResult]

	// List notification destinations.
	//
	// Lists notification destinations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListNotificationDestinationsRequest) ([]ListNotificationDestinationsResult, error)

	// Update a notification destination.
	//
	// Updates a notification destination. Requires workspace admin permissions. At
	// least one field is required in the request body.
	Update(ctx context.Context, request UpdateNotificationDestinationRequest) (*NotificationDestination, error)
}

func NewNotificationDestinations(client *client.DatabricksClient) *NotificationDestinationsAPI {
	return &NotificationDestinationsAPI{
		notificationDestinationsImpl: notificationDestinationsImpl{
			client: client,
		},
	}
}

// The notification destinations API lets you programmatically manage a
// workspace's notification destinations. Notification destinations are used to
// send notifications for query alerts and jobs to destinations outside of
// Databricks. Only workspace admins can create, update, and delete notification
// destinations.
type NotificationDestinationsAPI struct {
	notificationDestinationsImpl
}

// Delete a notification destination.
//
// Deletes a notification destination. Requires workspace admin permissions.
func (a *NotificationDestinationsAPI) DeleteById(ctx context.Context, id string) error {
	return a.notificationDestinationsImpl.Delete(ctx, DeleteNotificationDestinationRequest{
		Id: id,
	})
}

// Get a notification destination.
//
// Gets a notification destination.
func (a *NotificationDestinationsAPI) GetById(ctx context.Context, id string) (*NotificationDestination, error) {
	return a.notificationDestinationsImpl.Get(ctx, GetNotificationDestinationRequest{
		Id: id,
	})
}

type PersonalComputeInterface interface {

	// Delete Personal Compute setting.
	//
	// Reverts back the Personal Compute setting value to default (ON)
	Delete(ctx context.Context, request DeletePersonalComputeSettingRequest) (*DeletePersonalComputeSettingResponse, error)

	// Get Personal Compute setting.
	//
	// Gets the value of the Personal Compute setting.
	Get(ctx context.Context, request GetPersonalComputeSettingRequest) (*PersonalComputeSetting, error)

	// Update Personal Compute setting.
	//
	// Updates the value of the Personal Compute setting.
	Update(ctx context.Context, request UpdatePersonalComputeSettingRequest) (*PersonalComputeSetting, error)
}

func NewPersonalCompute(client *client.DatabricksClient) *PersonalComputeAPI {
	return &PersonalComputeAPI{
		personalComputeImpl: personalComputeImpl{
			client: client,
		},
	}
}

// The Personal Compute enablement setting lets you control which users can use
// the Personal Compute default policy to create compute resources. By default
// all users in all workspaces have access (ON), but you can change the setting
// to instead let individual workspaces configure access control (DELEGATE).
//
// There is only one instance of this setting per account. Since this setting
// has a default value, this setting is present on all accounts even though it's
// never set on a given account. Deletion reverts the value of the setting back
// to the default value.
type PersonalComputeAPI struct {
	personalComputeImpl
}

type RestrictWorkspaceAdminsInterface interface {

	// Delete the restrict workspace admins setting.
	//
	// Reverts the restrict workspace admins setting status for the workspace. A
	// fresh etag needs to be provided in `DELETE` requests (as a query parameter).
	// The etag can be retrieved by making a `GET` request before the DELETE
	// request. If the setting is updated/deleted concurrently, `DELETE` fails with
	// 409 and the request must be retried by using the fresh etag in the 409
	// response.
	Delete(ctx context.Context, request DeleteRestrictWorkspaceAdminsSettingRequest) (*DeleteRestrictWorkspaceAdminsSettingResponse, error)

	// Get the restrict workspace admins setting.
	//
	// Gets the restrict workspace admins setting.
	Get(ctx context.Context, request GetRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)

	// Update the restrict workspace admins setting.
	//
	// Updates the restrict workspace admins setting for the workspace. A fresh etag
	// needs to be provided in `PATCH` requests (as part of the setting field). The
	// etag can be retrieved by making a GET request before the `PATCH` request. If
	// the setting is updated concurrently, `PATCH` fails with 409 and the request
	// must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)
}

func NewRestrictWorkspaceAdmins(client *client.DatabricksClient) *RestrictWorkspaceAdminsAPI {
	return &RestrictWorkspaceAdminsAPI{
		restrictWorkspaceAdminsImpl: restrictWorkspaceAdminsImpl{
			client: client,
		},
	}
}

// The Restrict Workspace Admins setting lets you control the capabilities of
// workspace admins. With the setting status set to ALLOW_ALL, workspace admins
// can create service principal personal access tokens on behalf of any service
// principal in their workspace. Workspace admins can also change a job owner to
// any user in their workspace. And they can change the job run_as setting to
// any user in their workspace or to a service principal on which they have the
// Service Principal User role. With the setting status set to
// RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins can only create personal
// access tokens on behalf of service principals they have the Service Principal
// User role on. They can also only change a job owner to themselves. And they
// can change the job run_as setting to themselves or to a service principal on
// which they have the Service Principal User role.
type RestrictWorkspaceAdminsAPI struct {
	restrictWorkspaceAdminsImpl
}

type SettingsInterface interface {

	// Controls whether AI/BI published dashboard embedding is enabled,
	// conditionally enabled, or disabled at the workspace level. By default,
	// this setting is conditionally enabled (ALLOW_APPROVED_DOMAINS).
	AibiDashboardEmbeddingAccessPolicy() AibiDashboardEmbeddingAccessPolicyInterface

	// Controls the list of domains approved to host the embedded AI/BI
	// dashboards. The approved domains list can't be mutated when the current
	// access policy is not set to ALLOW_APPROVED_DOMAINS.
	AibiDashboardEmbeddingApprovedDomains() AibiDashboardEmbeddingApprovedDomainsInterface

	// Controls whether automatic cluster update is enabled for the current
	// workspace. By default, it is turned off.
	AutomaticClusterUpdate() AutomaticClusterUpdateInterface

	// Controls whether to enable the compliance security profile for the
	// current workspace. Enabling it on a workspace is permanent. By default,
	// it is turned off.
	//
	// This settings can NOT be disabled once it is enabled.
	ComplianceSecurityProfile() ComplianceSecurityProfileInterface

	// The default namespace setting API allows users to configure the default
	// namespace for a Databricks workspace.
	//
	// Through this API, users can retrieve, set, or modify the default
	// namespace used when queries do not reference a fully qualified
	// three-level name. For example, if you use the API to set 'retail_prod' as
	// the default catalog, then a query 'SELECT * FROM myTable' would reference
	// the object 'retail_prod.default.myTable' (the schema 'default' is always
	// assumed).
	//
	// This setting requires a restart of clusters and SQL warehouses to take
	// effect. Additionally, the default namespace only applies when using Unity
	// Catalog-enabled compute.
	DefaultNamespace() DefaultNamespaceInterface

	// 'Disabling legacy access' has the following impacts:
	//
	// 1. Disables direct access to the Hive Metastore. However, you can still
	// access Hive Metastore through HMS Federation. 2. Disables Fallback Mode
	// (docs link) on any External Location access from the workspace. 3. Alters
	// DBFS path access to use External Location permissions in place of legacy
	// credentials. 4. Enforces Unity Catalog access on all path based access.
	DisableLegacyAccess() DisableLegacyAccessInterface

	// When this setting is on, access to DBFS root and DBFS mounts is
	// disallowed (as well as creation of new mounts). When the setting is off,
	// all DBFS functionality is enabled
	DisableLegacyDbfs() DisableLegacyDbfsInterface

	// Controls whether enhanced security monitoring is enabled for the current
	// workspace. If the compliance security profile is enabled, this is
	// automatically enabled. By default, it is disabled. However, if the
	// compliance security profile is enabled, this is automatically enabled.
	//
	// If the compliance security profile is disabled, you can enable or disable
	// this setting and it is not permanent.
	EnhancedSecurityMonitoring() EnhancedSecurityMonitoringInterface

	// The Restrict Workspace Admins setting lets you control the capabilities
	// of workspace admins. With the setting status set to ALLOW_ALL, workspace
	// admins can create service principal personal access tokens on behalf of
	// any service principal in their workspace. Workspace admins can also
	// change a job owner to any user in their workspace. And they can change
	// the job run_as setting to any user in their workspace or to a service
	// principal on which they have the Service Principal User role. With the
	// setting status set to RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins
	// can only create personal access tokens on behalf of service principals
	// they have the Service Principal User role on. They can also only change a
	// job owner to themselves. And they can change the job run_as setting to
	// themselves or to a service principal on which they have the Service
	// Principal User role.
	RestrictWorkspaceAdmins() RestrictWorkspaceAdminsInterface
}

func NewSettings(client *client.DatabricksClient) *SettingsAPI {
	return &SettingsAPI{
		settingsImpl: settingsImpl{
			client: client,
		},

		aibiDashboardEmbeddingAccessPolicy: NewAibiDashboardEmbeddingAccessPolicy(client),

		aibiDashboardEmbeddingApprovedDomains: NewAibiDashboardEmbeddingApprovedDomains(client),

		automaticClusterUpdate: NewAutomaticClusterUpdate(client),

		complianceSecurityProfile: NewComplianceSecurityProfile(client),

		defaultNamespace: NewDefaultNamespace(client),

		disableLegacyAccess: NewDisableLegacyAccess(client),

		disableLegacyDbfs: NewDisableLegacyDbfs(client),

		enhancedSecurityMonitoring: NewEnhancedSecurityMonitoring(client),

		restrictWorkspaceAdmins: NewRestrictWorkspaceAdmins(client),
	}
}

// Workspace Settings API allows users to manage settings at the workspace
// level.
type SettingsAPI struct {
	settingsImpl

	// Controls whether AI/BI published dashboard embedding is enabled,
	// conditionally enabled, or disabled at the workspace level. By default,
	// this setting is conditionally enabled (ALLOW_APPROVED_DOMAINS).
	aibiDashboardEmbeddingAccessPolicy AibiDashboardEmbeddingAccessPolicyInterface

	// Controls the list of domains approved to host the embedded AI/BI
	// dashboards. The approved domains list can't be mutated when the current
	// access policy is not set to ALLOW_APPROVED_DOMAINS.
	aibiDashboardEmbeddingApprovedDomains AibiDashboardEmbeddingApprovedDomainsInterface

	// Controls whether automatic cluster update is enabled for the current
	// workspace. By default, it is turned off.
	automaticClusterUpdate AutomaticClusterUpdateInterface

	// Controls whether to enable the compliance security profile for the
	// current workspace. Enabling it on a workspace is permanent. By default,
	// it is turned off.
	//
	// This settings can NOT be disabled once it is enabled.
	complianceSecurityProfile ComplianceSecurityProfileInterface

	// The default namespace setting API allows users to configure the default
	// namespace for a Databricks workspace.
	//
	// Through this API, users can retrieve, set, or modify the default
	// namespace used when queries do not reference a fully qualified
	// three-level name. For example, if you use the API to set 'retail_prod' as
	// the default catalog, then a query 'SELECT * FROM myTable' would reference
	// the object 'retail_prod.default.myTable' (the schema 'default' is always
	// assumed).
	//
	// This setting requires a restart of clusters and SQL warehouses to take
	// effect. Additionally, the default namespace only applies when using Unity
	// Catalog-enabled compute.
	defaultNamespace DefaultNamespaceInterface

	// 'Disabling legacy access' has the following impacts:
	//
	// 1. Disables direct access to the Hive Metastore. However, you can still
	// access Hive Metastore through HMS Federation. 2. Disables Fallback Mode
	// (docs link) on any External Location access from the workspace. 3. Alters
	// DBFS path access to use External Location permissions in place of legacy
	// credentials. 4. Enforces Unity Catalog access on all path based access.
	disableLegacyAccess DisableLegacyAccessInterface

	// When this setting is on, access to DBFS root and DBFS mounts is
	// disallowed (as well as creation of new mounts). When the setting is off,
	// all DBFS functionality is enabled
	disableLegacyDbfs DisableLegacyDbfsInterface

	// Controls whether enhanced security monitoring is enabled for the current
	// workspace. If the compliance security profile is enabled, this is
	// automatically enabled. By default, it is disabled. However, if the
	// compliance security profile is enabled, this is automatically enabled.
	//
	// If the compliance security profile is disabled, you can enable or disable
	// this setting and it is not permanent.
	enhancedSecurityMonitoring EnhancedSecurityMonitoringInterface

	// The Restrict Workspace Admins setting lets you control the capabilities
	// of workspace admins. With the setting status set to ALLOW_ALL, workspace
	// admins can create service principal personal access tokens on behalf of
	// any service principal in their workspace. Workspace admins can also
	// change a job owner to any user in their workspace. And they can change
	// the job run_as setting to any user in their workspace or to a service
	// principal on which they have the Service Principal User role. With the
	// setting status set to RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins
	// can only create personal access tokens on behalf of service principals
	// they have the Service Principal User role on. They can also only change a
	// job owner to themselves. And they can change the job run_as setting to
	// themselves or to a service principal on which they have the Service
	// Principal User role.
	restrictWorkspaceAdmins RestrictWorkspaceAdminsInterface
}

func (a *SettingsAPI) AibiDashboardEmbeddingAccessPolicy() AibiDashboardEmbeddingAccessPolicyInterface {
	return a.aibiDashboardEmbeddingAccessPolicy
}

func (a *SettingsAPI) AibiDashboardEmbeddingApprovedDomains() AibiDashboardEmbeddingApprovedDomainsInterface {
	return a.aibiDashboardEmbeddingApprovedDomains
}

func (a *SettingsAPI) AutomaticClusterUpdate() AutomaticClusterUpdateInterface {
	return a.automaticClusterUpdate
}

func (a *SettingsAPI) ComplianceSecurityProfile() ComplianceSecurityProfileInterface {
	return a.complianceSecurityProfile
}

func (a *SettingsAPI) DefaultNamespace() DefaultNamespaceInterface {
	return a.defaultNamespace
}

func (a *SettingsAPI) DisableLegacyAccess() DisableLegacyAccessInterface {
	return a.disableLegacyAccess
}

func (a *SettingsAPI) DisableLegacyDbfs() DisableLegacyDbfsInterface {
	return a.disableLegacyDbfs
}

func (a *SettingsAPI) EnhancedSecurityMonitoring() EnhancedSecurityMonitoringInterface {
	return a.enhancedSecurityMonitoring
}

func (a *SettingsAPI) RestrictWorkspaceAdmins() RestrictWorkspaceAdminsInterface {
	return a.restrictWorkspaceAdmins
}

type TokenManagementInterface interface {

	// Create on-behalf token.
	//
	// Creates a token on behalf of a service principal.
	CreateOboToken(ctx context.Context, request CreateOboTokenRequest) (*CreateOboTokenResponse, error)

	// Delete a token.
	//
	// Deletes a token, specified by its ID.
	Delete(ctx context.Context, request DeleteTokenManagementRequest) error

	// Delete a token.
	//
	// Deletes a token, specified by its ID.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// Get token info.
	//
	// Gets information about a token, specified by its ID.
	Get(ctx context.Context, request GetTokenManagementRequest) (*GetTokenResponse, error)

	// Get token info.
	//
	// Gets information about a token, specified by its ID.
	GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error)

	// Get token permission levels.
	//
	// Gets the permission levels that a user can have on an object.
	GetPermissionLevels(ctx context.Context) (*GetTokenPermissionLevelsResponse, error)

	// Get token permissions.
	//
	// Gets the permissions of all tokens. Tokens can inherit permissions from their
	// root object.
	GetPermissions(ctx context.Context) (*TokenPermissions, error)

	// List all tokens.
	//
	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListTokenManagementRequest) listing.Iterator[TokenInfo]

	// List all tokens.
	//
	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListTokenManagementRequest) ([]TokenInfo, error)

	// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error)

	// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*TokenInfo, error)

	// Set token permissions.
	//
	// Sets permissions on an object, replacing existing permissions if they exist.
	// Deletes all direct permissions if none are specified. Objects can inherit
	// permissions from their root object.
	SetPermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)

	// Update token permissions.
	//
	// Updates the permissions on all tokens. Tokens can inherit permissions from
	// their root object.
	UpdatePermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)
}

func NewTokenManagement(client *client.DatabricksClient) *TokenManagementAPI {
	return &TokenManagementAPI{
		tokenManagementImpl: tokenManagementImpl{
			client: client,
		},
	}
}

// Enables administrators to get all tokens and delete tokens for other users.
// Admins can either get every token, get a specific token by ID, or get all
// tokens for a particular user.
type TokenManagementAPI struct {
	tokenManagementImpl
}

// Delete a token.
//
// Deletes a token, specified by its ID.
func (a *TokenManagementAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.tokenManagementImpl.Delete(ctx, DeleteTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Get token info.
//
// Gets information about a token, specified by its ID.
func (a *TokenManagementAPI) GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error) {
	return a.tokenManagementImpl.Get(ctx, GetTokenManagementRequest{
		TokenId: tokenId,
	})
}

// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) GetByComment(ctx context.Context, name string) (*TokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTokenManagementRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type TokensInterface interface {

	// Create a user token.
	//
	// Creates and returns a token for a user. If this call is made through token
	// authentication, it creates a token with the same client ID as the
	// authenticated token. If the user's token quota is exceeded, this call returns
	// an error **QUOTA_EXCEEDED**.
	Create(ctx context.Context, request CreateTokenRequest) (*CreateTokenResponse, error)

	// Revoke token.
	//
	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	Delete(ctx context.Context, request RevokeTokenRequest) error

	// Revoke token.
	//
	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// List tokens.
	//
	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[PublicTokenInfo]

	// List tokens.
	//
	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]PublicTokenInfo, error)

	// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error)

	// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error)
}

func NewTokens(client *client.DatabricksClient) *TokensAPI {
	return &TokensAPI{
		tokensImpl: tokensImpl{
			client: client,
		},
	}
}

// The Token API allows you to create, list, and revoke tokens that can be used
// to authenticate and access Databricks REST APIs.
type TokensAPI struct {
	tokensImpl
}

// Revoke token.
//
// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *TokensAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.tokensImpl.Delete(ctx, RevokeTokenRequest{
		TokenId: tokenId,
	})
}

// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PublicTokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PublicTokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PublicTokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type WorkspaceConfInterface interface {

	// Check configuration status.
	//
	// Gets the configuration status for a workspace.
	GetStatus(ctx context.Context, request GetStatusRequest) (*map[string]string, error)

	// Enable/disable features.
	//
	// Sets the configuration status for a workspace, including enabling or
	// disabling it.
	SetStatus(ctx context.Context, request WorkspaceConf) error
}

func NewWorkspaceConf(client *client.DatabricksClient) *WorkspaceConfAPI {
	return &WorkspaceConfAPI{
		workspaceConfImpl: workspaceConfImpl{
			client: client,
		},
	}
}

// This API allows updating known workspace settings for advanced users.
type WorkspaceConfAPI struct {
	workspaceConfImpl
}
