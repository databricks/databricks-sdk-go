// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Ip Access Lists, Account Settings, Aibi Dashboard Embedding Access Policy, Aibi Dashboard Embedding Approved Domains, Automatic Cluster Update, Compliance Security Profile, Credentials Manager, Csp Enablement Account, Dashboard Email Subscriptions, Default Namespace, Default Warehouse Id, Disable Legacy Access, Disable Legacy Dbfs, Disable Legacy Features, Enable Export Notebook, Enable Ip Access Lists, Enable Notebook Table Clipboard, Enable Results Downloading, Enhanced Security Monitoring, Esm Enablement Account, Ip Access Lists, Llm Proxy Partner Powered Account, Llm Proxy Partner Powered Enforce, Llm Proxy Partner Powered Workspace, Network Connectivity, Network Policies, Notification Destinations, Personal Compute, Restrict Workspace Admins, Settings, Sql Results Download, Token Management, Tokens, Workspace Conf, Workspace Network Configuration, etc.
package settings

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AccountIpAccessListsInterface interface {

	// Creates an IP access list for the account.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteAccountIpAccessListRequest) error

	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetAccountIpAccessListRequest) (*GetIpAccessListResponse, error)

	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error)

	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewAccountIpAccessLists(client *client.DatabricksClient) *AccountIpAccessListsAPI {
	return &AccountIpAccessListsAPI{
		accountIpAccessListsImpl: accountIpAccessListsImpl{
			client: client,
		},
	}
}

// The Accounts IP Access List API enables account admins to configure IP access
// lists for access to the account console.
//
// Account IP Access Lists affect web application access and REST API access to
// the account console and account APIs. If the feature is disabled for the
// account, all access is allowed for this account. There is support for allow
// lists (inclusion) and block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the account, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the account, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the account supports a maximum
// of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the account-level IP access lists, it can take a few minutes
// for changes to take effect.
type AccountIpAccessListsAPI struct {
	accountIpAccessListsImpl
}

// Deletes an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.accountIpAccessListsImpl.Delete(ctx, DeleteAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Gets an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error) {
	return a.accountIpAccessListsImpl.Get(ctx, GetAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type AccountSettingsInterface interface {

	// The compliance security profile settings at the account level control
	// whether to enable it for new workspaces. By default, this account-level
	// setting is disabled for new workspaces. After workspace creation, account
	// admins can enable the compliance security profile individually for each
	// workspace.
	//
	// This settings can be disabled so that new workspaces do not have
	// compliance security profile enabled by default.
	CspEnablementAccount() CspEnablementAccountInterface

	// Disable legacy features for new Databricks workspaces.
	//
	// For newly created workspaces: 1. Disables the use of DBFS root and
	// mounts. 2. Hive Metastore will not be provisioned. 3. Disables the use of
	// ‘No-isolation clusters’. 4. Disables Databricks Runtime versions
	// prior to 13.3LTS.
	DisableLegacyFeatures() DisableLegacyFeaturesInterface

	// Controls the enforcement of IP access lists for accessing the account
	// console. Allowing you to enable or disable restricted access based on IP
	// addresses.
	EnableIpAccessLists() EnableIpAccessListsInterface

	// The enhanced security monitoring setting at the account level controls
	// whether to enable the feature on new workspaces. By default, this
	// account-level setting is disabled for new workspaces. After workspace
	// creation, account admins can enable enhanced security monitoring
	// individually for each workspace.
	EsmEnablementAccount() EsmEnablementAccountInterface

	// Determines if partner powered models are enabled or not for a specific
	// account
	LlmProxyPartnerPoweredAccount() LlmProxyPartnerPoweredAccountInterface

	// Determines if the account-level partner-powered setting value is enforced
	// upon the workspace-level partner-powered setting
	LlmProxyPartnerPoweredEnforce() LlmProxyPartnerPoweredEnforceInterface

	// The Personal Compute enablement setting lets you control which users can
	// use the Personal Compute default policy to create compute resources. By
	// default all users in all workspaces have access (ON), but you can change
	// the setting to instead let individual workspaces configure access control
	// (DELEGATE).
	//
	// There is only one instance of this setting per account. Since this
	// setting has a default value, this setting is present on all accounts even
	// though it's never set on a given account. Deletion reverts the value of
	// the setting back to the default value.
	PersonalCompute() PersonalComputeInterface
}

func NewAccountSettings(client *client.DatabricksClient) *AccountSettingsAPI {
	return &AccountSettingsAPI{
		accountSettingsImpl: accountSettingsImpl{
			client: client,
		},

		cspEnablementAccount: NewCspEnablementAccount(client),

		disableLegacyFeatures: NewDisableLegacyFeatures(client),

		enableIpAccessLists: NewEnableIpAccessLists(client),

		esmEnablementAccount: NewEsmEnablementAccount(client),

		llmProxyPartnerPoweredAccount: NewLlmProxyPartnerPoweredAccount(client),

		llmProxyPartnerPoweredEnforce: NewLlmProxyPartnerPoweredEnforce(client),

		personalCompute: NewPersonalCompute(client),
	}
}

// Accounts Settings API allows users to manage settings at the account level.
type AccountSettingsAPI struct {
	accountSettingsImpl

	// The compliance security profile settings at the account level control
	// whether to enable it for new workspaces. By default, this account-level
	// setting is disabled for new workspaces. After workspace creation, account
	// admins can enable the compliance security profile individually for each
	// workspace.
	//
	// This settings can be disabled so that new workspaces do not have
	// compliance security profile enabled by default.
	cspEnablementAccount CspEnablementAccountInterface

	// Disable legacy features for new Databricks workspaces.
	//
	// For newly created workspaces: 1. Disables the use of DBFS root and
	// mounts. 2. Hive Metastore will not be provisioned. 3. Disables the use of
	// ‘No-isolation clusters’. 4. Disables Databricks Runtime versions
	// prior to 13.3LTS.
	disableLegacyFeatures DisableLegacyFeaturesInterface

	// Controls the enforcement of IP access lists for accessing the account
	// console. Allowing you to enable or disable restricted access based on IP
	// addresses.
	enableIpAccessLists EnableIpAccessListsInterface

	// The enhanced security monitoring setting at the account level controls
	// whether to enable the feature on new workspaces. By default, this
	// account-level setting is disabled for new workspaces. After workspace
	// creation, account admins can enable enhanced security monitoring
	// individually for each workspace.
	esmEnablementAccount EsmEnablementAccountInterface

	// Determines if partner powered models are enabled or not for a specific
	// account
	llmProxyPartnerPoweredAccount LlmProxyPartnerPoweredAccountInterface

	// Determines if the account-level partner-powered setting value is enforced
	// upon the workspace-level partner-powered setting
	llmProxyPartnerPoweredEnforce LlmProxyPartnerPoweredEnforceInterface

	// The Personal Compute enablement setting lets you control which users can
	// use the Personal Compute default policy to create compute resources. By
	// default all users in all workspaces have access (ON), but you can change
	// the setting to instead let individual workspaces configure access control
	// (DELEGATE).
	//
	// There is only one instance of this setting per account. Since this
	// setting has a default value, this setting is present on all accounts even
	// though it's never set on a given account. Deletion reverts the value of
	// the setting back to the default value.
	personalCompute PersonalComputeInterface
}

func (a *AccountSettingsAPI) CspEnablementAccount() CspEnablementAccountInterface {
	return a.cspEnablementAccount
}

func (a *AccountSettingsAPI) DisableLegacyFeatures() DisableLegacyFeaturesInterface {
	return a.disableLegacyFeatures
}

func (a *AccountSettingsAPI) EnableIpAccessLists() EnableIpAccessListsInterface {
	return a.enableIpAccessLists
}

func (a *AccountSettingsAPI) EsmEnablementAccount() EsmEnablementAccountInterface {
	return a.esmEnablementAccount
}

func (a *AccountSettingsAPI) LlmProxyPartnerPoweredAccount() LlmProxyPartnerPoweredAccountInterface {
	return a.llmProxyPartnerPoweredAccount
}

func (a *AccountSettingsAPI) LlmProxyPartnerPoweredEnforce() LlmProxyPartnerPoweredEnforceInterface {
	return a.llmProxyPartnerPoweredEnforce
}

func (a *AccountSettingsAPI) PersonalCompute() PersonalComputeInterface {
	return a.personalCompute
}

type AibiDashboardEmbeddingAccessPolicyInterface interface {

	// Delete the AI/BI dashboard embedding access policy, reverting back to the
	// default.
	Delete(ctx context.Context, request DeleteAibiDashboardEmbeddingAccessPolicySettingRequest) (*DeleteAibiDashboardEmbeddingAccessPolicySettingResponse, error)

	// Retrieves the AI/BI dashboard embedding access policy. The default setting is
	// ALLOW_APPROVED_DOMAINS, permitting AI/BI dashboards to be embedded on
	// approved domains.
	Get(ctx context.Context, request GetAibiDashboardEmbeddingAccessPolicySettingRequest) (*AibiDashboardEmbeddingAccessPolicySetting, error)

	// Updates the AI/BI dashboard embedding access policy at the workspace level.
	Update(ctx context.Context, request UpdateAibiDashboardEmbeddingAccessPolicySettingRequest) (*AibiDashboardEmbeddingAccessPolicySetting, error)
}

func NewAibiDashboardEmbeddingAccessPolicy(client *client.DatabricksClient) *AibiDashboardEmbeddingAccessPolicyAPI {
	return &AibiDashboardEmbeddingAccessPolicyAPI{
		aibiDashboardEmbeddingAccessPolicyImpl: aibiDashboardEmbeddingAccessPolicyImpl{
			client: client,
		},
	}
}

// Controls whether AI/BI published dashboard embedding is enabled,
// conditionally enabled, or disabled at the workspace level. By default, this
// setting is conditionally enabled (ALLOW_APPROVED_DOMAINS).
type AibiDashboardEmbeddingAccessPolicyAPI struct {
	aibiDashboardEmbeddingAccessPolicyImpl
}

type AibiDashboardEmbeddingApprovedDomainsInterface interface {

	// Delete the list of domains approved to host embedded AI/BI dashboards,
	// reverting back to the default empty list.
	Delete(ctx context.Context, request DeleteAibiDashboardEmbeddingApprovedDomainsSettingRequest) (*DeleteAibiDashboardEmbeddingApprovedDomainsSettingResponse, error)

	// Retrieves the list of domains approved to host embedded AI/BI dashboards.
	Get(ctx context.Context, request GetAibiDashboardEmbeddingApprovedDomainsSettingRequest) (*AibiDashboardEmbeddingApprovedDomainsSetting, error)

	// Updates the list of domains approved to host embedded AI/BI dashboards. This
	// update will fail if the current workspace access policy is not
	// ALLOW_APPROVED_DOMAINS.
	Update(ctx context.Context, request UpdateAibiDashboardEmbeddingApprovedDomainsSettingRequest) (*AibiDashboardEmbeddingApprovedDomainsSetting, error)
}

func NewAibiDashboardEmbeddingApprovedDomains(client *client.DatabricksClient) *AibiDashboardEmbeddingApprovedDomainsAPI {
	return &AibiDashboardEmbeddingApprovedDomainsAPI{
		aibiDashboardEmbeddingApprovedDomainsImpl: aibiDashboardEmbeddingApprovedDomainsImpl{
			client: client,
		},
	}
}

// Controls the list of domains approved to host the embedded AI/BI dashboards.
// The approved domains list can't be mutated when the current access policy is
// not set to ALLOW_APPROVED_DOMAINS.
type AibiDashboardEmbeddingApprovedDomainsAPI struct {
	aibiDashboardEmbeddingApprovedDomainsImpl
}

type AutomaticClusterUpdateInterface interface {

	// Gets the automatic cluster update setting.
	Get(ctx context.Context, request GetAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error)

	// Updates the automatic cluster update setting for the workspace. A fresh etag
	// needs to be provided in `PATCH` requests (as part of the setting field). The
	// etag can be retrieved by making a `GET` request before the `PATCH` request.
	// If the setting is updated concurrently, `PATCH` fails with 409 and the
	// request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error)
}

func NewAutomaticClusterUpdate(client *client.DatabricksClient) *AutomaticClusterUpdateAPI {
	return &AutomaticClusterUpdateAPI{
		automaticClusterUpdateImpl: automaticClusterUpdateImpl{
			client: client,
		},
	}
}

// Controls whether automatic cluster update is enabled for the current
// workspace. By default, it is turned off.
type AutomaticClusterUpdateAPI struct {
	automaticClusterUpdateImpl
}

type ComplianceSecurityProfileInterface interface {

	// Gets the compliance security profile setting.
	Get(ctx context.Context, request GetComplianceSecurityProfileSettingRequest) (*ComplianceSecurityProfileSetting, error)

	// Updates the compliance security profile setting for the workspace. A fresh
	// etag needs to be provided in `PATCH` requests (as part of the setting field).
	// The etag can be retrieved by making a `GET` request before the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateComplianceSecurityProfileSettingRequest) (*ComplianceSecurityProfileSetting, error)
}

func NewComplianceSecurityProfile(client *client.DatabricksClient) *ComplianceSecurityProfileAPI {
	return &ComplianceSecurityProfileAPI{
		complianceSecurityProfileImpl: complianceSecurityProfileImpl{
			client: client,
		},
	}
}

// Controls whether to enable the compliance security profile for the current
// workspace. Enabling it on a workspace is permanent. By default, it is turned
// off.
//
// This settings can NOT be disabled once it is enabled.
type ComplianceSecurityProfileAPI struct {
	complianceSecurityProfileImpl
}

type CredentialsManagerInterface interface {

	// Exchange tokens with an Identity Provider to get a new access token. It
	// allows specifying scopes to determine token permissions.
	ExchangeToken(ctx context.Context, request ExchangeTokenRequest) (*ExchangeTokenResponse, error)
}

func NewCredentialsManager(client *client.DatabricksClient) *CredentialsManagerAPI {
	return &CredentialsManagerAPI{
		credentialsManagerImpl: credentialsManagerImpl{
			client: client,
		},
	}
}

// Credentials manager interacts with with Identity Providers to to perform
// token exchanges using stored credentials and refresh tokens.
type CredentialsManagerAPI struct {
	credentialsManagerImpl
}

type CspEnablementAccountInterface interface {

	// Gets the compliance security profile setting for new workspaces.
	Get(ctx context.Context, request GetCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error)

	// Updates the value of the compliance security profile setting for new
	// workspaces.
	Update(ctx context.Context, request UpdateCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error)
}

func NewCspEnablementAccount(client *client.DatabricksClient) *CspEnablementAccountAPI {
	return &CspEnablementAccountAPI{
		cspEnablementAccountImpl: cspEnablementAccountImpl{
			client: client,
		},
	}
}

// The compliance security profile settings at the account level control whether
// to enable it for new workspaces. By default, this account-level setting is
// disabled for new workspaces. After workspace creation, account admins can
// enable the compliance security profile individually for each workspace.
//
// This settings can be disabled so that new workspaces do not have compliance
// security profile enabled by default.
type CspEnablementAccountAPI struct {
	cspEnablementAccountImpl
}

type DashboardEmailSubscriptionsInterface interface {

	// Reverts the Dashboard Email Subscriptions setting to its default value.
	Delete(ctx context.Context, request DeleteDashboardEmailSubscriptionsRequest) (*DeleteDashboardEmailSubscriptionsResponse, error)

	// Gets the Dashboard Email Subscriptions setting.
	Get(ctx context.Context, request GetDashboardEmailSubscriptionsRequest) (*DashboardEmailSubscriptions, error)

	// Updates the Dashboard Email Subscriptions setting.
	Update(ctx context.Context, request UpdateDashboardEmailSubscriptionsRequest) (*DashboardEmailSubscriptions, error)
}

func NewDashboardEmailSubscriptions(client *client.DatabricksClient) *DashboardEmailSubscriptionsAPI {
	return &DashboardEmailSubscriptionsAPI{
		dashboardEmailSubscriptionsImpl: dashboardEmailSubscriptionsImpl{
			client: client,
		},
	}
}

// Controls whether schedules or workload tasks for refreshing AI/BI Dashboards
// in the workspace can send subscription emails containing PDFs and/or images
// of the dashboard. By default, this setting is enabled (set to `true`)
type DashboardEmailSubscriptionsAPI struct {
	dashboardEmailSubscriptionsImpl
}

type DefaultNamespaceInterface interface {

	// Deletes the default namespace setting for the workspace. A fresh etag needs
	// to be provided in `DELETE` requests (as a query parameter). The etag can be
	// retrieved by making a `GET` request before the `DELETE` request. If the
	// setting is updated/deleted concurrently, `DELETE` fails with 409 and the
	// request must be retried by using the fresh etag in the 409 response.
	Delete(ctx context.Context, request DeleteDefaultNamespaceSettingRequest) (*DeleteDefaultNamespaceSettingResponse, error)

	// Gets the default namespace setting.
	Get(ctx context.Context, request GetDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)

	// Updates the default namespace setting for the workspace. A fresh etag needs
	// to be provided in `PATCH` requests (as part of the setting field). The etag
	// can be retrieved by making a `GET` request before the `PATCH` request. Note
	// that if the setting does not exist, `GET` returns a NOT_FOUND error and the
	// etag is present in the error response, which should be set in the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)
}

func NewDefaultNamespace(client *client.DatabricksClient) *DefaultNamespaceAPI {
	return &DefaultNamespaceAPI{
		defaultNamespaceImpl: defaultNamespaceImpl{
			client: client,
		},
	}
}

// The default namespace setting API allows users to configure the default
// namespace for a Databricks workspace.
//
// Through this API, users can retrieve, set, or modify the default namespace
// used when queries do not reference a fully qualified three-level name. For
// example, if you use the API to set 'retail_prod' as the default catalog, then
// a query 'SELECT * FROM myTable' would reference the object
// 'retail_prod.default.myTable' (the schema 'default' is always assumed).
//
// This setting requires a restart of clusters and SQL warehouses to take
// effect. Additionally, the default namespace only applies when using Unity
// Catalog-enabled compute.
type DefaultNamespaceAPI struct {
	defaultNamespaceImpl
}

type DefaultWarehouseIdInterface interface {

	// Reverts the Default Warehouse Id setting to its default value.
	Delete(ctx context.Context, request DeleteDefaultWarehouseIdRequest) (*DeleteDefaultWarehouseIdResponse, error)

	// Gets the Default Warehouse Id setting.
	Get(ctx context.Context, request GetDefaultWarehouseIdRequest) (*DefaultWarehouseId, error)

	// Updates the Default Warehouse Id setting.
	Update(ctx context.Context, request UpdateDefaultWarehouseIdRequest) (*DefaultWarehouseId, error)
}

func NewDefaultWarehouseId(client *client.DatabricksClient) *DefaultWarehouseIdAPI {
	return &DefaultWarehouseIdAPI{
		defaultWarehouseIdImpl: defaultWarehouseIdImpl{
			client: client,
		},
	}
}

// Warehouse to be selected by default for users in this workspace. Covers SQL
// workloads only and can be overridden by users.
type DefaultWarehouseIdAPI struct {
	defaultWarehouseIdImpl
}

type DisableLegacyAccessInterface interface {

	// Deletes legacy access disablement status.
	Delete(ctx context.Context, request DeleteDisableLegacyAccessRequest) (*DeleteDisableLegacyAccessResponse, error)

	// Retrieves legacy access disablement Status.
	Get(ctx context.Context, request GetDisableLegacyAccessRequest) (*DisableLegacyAccess, error)

	// Updates legacy access disablement status.
	Update(ctx context.Context, request UpdateDisableLegacyAccessRequest) (*DisableLegacyAccess, error)
}

func NewDisableLegacyAccess(client *client.DatabricksClient) *DisableLegacyAccessAPI {
	return &DisableLegacyAccessAPI{
		disableLegacyAccessImpl: disableLegacyAccessImpl{
			client: client,
		},
	}
}

// 'Disabling legacy access' has the following impacts:
//
// 1. Disables direct access to Hive Metastores from the workspace. However, you
// can still access a Hive Metastore through Hive Metastore federation. 2.
// Disables fallback mode on external location access from the workspace. 3.
// Disables Databricks Runtime versions prior to 13.3LTS.
type DisableLegacyAccessAPI struct {
	disableLegacyAccessImpl
}

type DisableLegacyDbfsInterface interface {

	// Deletes the disable legacy DBFS setting for a workspace, reverting back to
	// the default.
	Delete(ctx context.Context, request DeleteDisableLegacyDbfsRequest) (*DeleteDisableLegacyDbfsResponse, error)

	// Gets the disable legacy DBFS setting.
	Get(ctx context.Context, request GetDisableLegacyDbfsRequest) (*DisableLegacyDbfs, error)

	// Updates the disable legacy DBFS setting for the workspace.
	Update(ctx context.Context, request UpdateDisableLegacyDbfsRequest) (*DisableLegacyDbfs, error)
}

func NewDisableLegacyDbfs(client *client.DatabricksClient) *DisableLegacyDbfsAPI {
	return &DisableLegacyDbfsAPI{
		disableLegacyDbfsImpl: disableLegacyDbfsImpl{
			client: client,
		},
	}
}

// Disabling legacy DBFS has the following implications:
//
// 1. Access to DBFS root and DBFS mounts is disallowed (as well as the creation
// of new mounts). 2. Disables Databricks Runtime versions prior to 13.3LTS.
//
// When the setting is off, all DBFS functionality is enabled and no
// restrictions are imposed on Databricks Runtime versions. This setting can
// take up to 20 minutes to take effect and requires a manual restart of
// all-purpose compute clusters and SQL warehouses.
type DisableLegacyDbfsAPI struct {
	disableLegacyDbfsImpl
}

type DisableLegacyFeaturesInterface interface {

	// Deletes the disable legacy features setting.
	Delete(ctx context.Context, request DeleteDisableLegacyFeaturesRequest) (*DeleteDisableLegacyFeaturesResponse, error)

	// Gets the value of the disable legacy features setting.
	Get(ctx context.Context, request GetDisableLegacyFeaturesRequest) (*DisableLegacyFeatures, error)

	// Updates the value of the disable legacy features setting.
	Update(ctx context.Context, request UpdateDisableLegacyFeaturesRequest) (*DisableLegacyFeatures, error)
}

func NewDisableLegacyFeatures(client *client.DatabricksClient) *DisableLegacyFeaturesAPI {
	return &DisableLegacyFeaturesAPI{
		disableLegacyFeaturesImpl: disableLegacyFeaturesImpl{
			client: client,
		},
	}
}

// Disable legacy features for new Databricks workspaces.
//
// For newly created workspaces: 1. Disables the use of DBFS root and mounts. 2.
// Hive Metastore will not be provisioned. 3. Disables the use of
// ‘No-isolation clusters’. 4. Disables Databricks Runtime versions prior to
// 13.3LTS.
type DisableLegacyFeaturesAPI struct {
	disableLegacyFeaturesImpl
}

type EnableExportNotebookInterface interface {

	// Gets the Notebook and File exporting setting.
	GetEnableExportNotebook(ctx context.Context) (*EnableExportNotebook, error)

	// Updates the Notebook and File exporting setting. The model follows eventual
	// consistency, which means the get after the update operation might receive
	// stale values for some time.
	PatchEnableExportNotebook(ctx context.Context, request UpdateEnableExportNotebookRequest) (*EnableExportNotebook, error)
}

func NewEnableExportNotebook(client *client.DatabricksClient) *EnableExportNotebookAPI {
	return &EnableExportNotebookAPI{
		enableExportNotebookImpl: enableExportNotebookImpl{
			client: client,
		},
	}
}

// Controls whether users can export notebooks and files from the Workspace UI.
// By default, this setting is enabled.
type EnableExportNotebookAPI struct {
	enableExportNotebookImpl
}

type EnableIpAccessListsInterface interface {

	// Reverts the value of the account IP access toggle setting to default (ON)
	Delete(ctx context.Context, request DeleteAccountIpAccessEnableRequest) (*DeleteAccountIpAccessEnableResponse, error)

	// Gets the value of the account IP access toggle setting.
	Get(ctx context.Context, request GetAccountIpAccessEnableRequest) (*AccountIpAccessEnable, error)

	// Updates the value of the account IP access toggle setting.
	Update(ctx context.Context, request UpdateAccountIpAccessEnableRequest) (*AccountIpAccessEnable, error)
}

func NewEnableIpAccessLists(client *client.DatabricksClient) *EnableIpAccessListsAPI {
	return &EnableIpAccessListsAPI{
		enableIpAccessListsImpl: enableIpAccessListsImpl{
			client: client,
		},
	}
}

// Controls the enforcement of IP access lists for accessing the account
// console. Allowing you to enable or disable restricted access based on IP
// addresses.
type EnableIpAccessListsAPI struct {
	enableIpAccessListsImpl
}

type EnableNotebookTableClipboardInterface interface {

	// Gets the Results Table Clipboard features setting.
	GetEnableNotebookTableClipboard(ctx context.Context) (*EnableNotebookTableClipboard, error)

	// Updates the Results Table Clipboard features setting. The model follows
	// eventual consistency, which means the get after the update operation might
	// receive stale values for some time.
	PatchEnableNotebookTableClipboard(ctx context.Context, request UpdateEnableNotebookTableClipboardRequest) (*EnableNotebookTableClipboard, error)
}

func NewEnableNotebookTableClipboard(client *client.DatabricksClient) *EnableNotebookTableClipboardAPI {
	return &EnableNotebookTableClipboardAPI{
		enableNotebookTableClipboardImpl: enableNotebookTableClipboardImpl{
			client: client,
		},
	}
}

// Controls whether users can copy tabular data to the clipboard via the UI. By
// default, this setting is enabled.
type EnableNotebookTableClipboardAPI struct {
	enableNotebookTableClipboardImpl
}

type EnableResultsDownloadingInterface interface {

	// Gets the Notebook results download setting.
	GetEnableResultsDownloading(ctx context.Context) (*EnableResultsDownloading, error)

	// Updates the Notebook results download setting. The model follows eventual
	// consistency, which means the get after the update operation might receive
	// stale values for some time.
	PatchEnableResultsDownloading(ctx context.Context, request UpdateEnableResultsDownloadingRequest) (*EnableResultsDownloading, error)
}

func NewEnableResultsDownloading(client *client.DatabricksClient) *EnableResultsDownloadingAPI {
	return &EnableResultsDownloadingAPI{
		enableResultsDownloadingImpl: enableResultsDownloadingImpl{
			client: client,
		},
	}
}

// Controls whether users can download notebook results. By default, this
// setting is enabled.
type EnableResultsDownloadingAPI struct {
	enableResultsDownloadingImpl
}

type EnhancedSecurityMonitoringInterface interface {

	// Gets the enhanced security monitoring setting.
	Get(ctx context.Context, request GetEnhancedSecurityMonitoringSettingRequest) (*EnhancedSecurityMonitoringSetting, error)

	// Updates the enhanced security monitoring setting for the workspace. A fresh
	// etag needs to be provided in `PATCH` requests (as part of the setting field).
	// The etag can be retrieved by making a `GET` request before the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateEnhancedSecurityMonitoringSettingRequest) (*EnhancedSecurityMonitoringSetting, error)
}

func NewEnhancedSecurityMonitoring(client *client.DatabricksClient) *EnhancedSecurityMonitoringAPI {
	return &EnhancedSecurityMonitoringAPI{
		enhancedSecurityMonitoringImpl: enhancedSecurityMonitoringImpl{
			client: client,
		},
	}
}

// Controls whether enhanced security monitoring is enabled for the current
// workspace. If the compliance security profile is enabled, this is
// automatically enabled. By default, it is disabled. However, if the compliance
// security profile is enabled, this is automatically enabled.
//
// If the compliance security profile is disabled, you can enable or disable
// this setting and it is not permanent.
type EnhancedSecurityMonitoringAPI struct {
	enhancedSecurityMonitoringImpl
}

type EsmEnablementAccountInterface interface {

	// Gets the enhanced security monitoring setting for new workspaces.
	Get(ctx context.Context, request GetEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error)

	// Updates the value of the enhanced security monitoring setting for new
	// workspaces.
	Update(ctx context.Context, request UpdateEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error)
}

func NewEsmEnablementAccount(client *client.DatabricksClient) *EsmEnablementAccountAPI {
	return &EsmEnablementAccountAPI{
		esmEnablementAccountImpl: esmEnablementAccountImpl{
			client: client,
		},
	}
}

// The enhanced security monitoring setting at the account level controls
// whether to enable the feature on new workspaces. By default, this
// account-level setting is disabled for new workspaces. After workspace
// creation, account admins can enable enhanced security monitoring individually
// for each workspace.
type EsmEnablementAccountAPI struct {
	esmEnablementAccountImpl
}

type IpAccessListsInterface interface {

	// Creates an IP access list for this workspace.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. **Note**: Your new
	// IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteIpAccessListRequest) error

	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetIpAccessListRequest) (*FetchIpAccessListResponse, error)

	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error)

	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	// Note that your resulting IP access list has no effect until you enable the
	// feature. See :method:workspaceconf/setStatus.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. Note that your
	// resulting IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewIpAccessLists(client *client.DatabricksClient) *IpAccessListsAPI {
	return &IpAccessListsAPI{
		ipAccessListsImpl: ipAccessListsImpl{
			client: client,
		},
	}
}

// IP Access List enables admins to configure IP access lists.
//
// IP access lists affect web application access and REST API access to this
// workspace only. If the feature is disabled for a workspace, all access is
// allowed for this workspace. There is support for allow lists (inclusion) and
// block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the workspace, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the workspace, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the workspace supports a
// maximum of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the IP access list feature, it can take a few minutes for
// changes to take effect.
type IpAccessListsAPI struct {
	ipAccessListsImpl
}

// Deletes an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.ipAccessListsImpl.Delete(ctx, DeleteIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Gets an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error) {
	return a.ipAccessListsImpl.Get(ctx, GetIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type LlmProxyPartnerPoweredAccountInterface interface {

	// Gets the enable partner powered AI features account setting.
	Get(ctx context.Context, request GetLlmProxyPartnerPoweredAccountRequest) (*LlmProxyPartnerPoweredAccount, error)

	// Updates the enable partner powered AI features account setting.
	Update(ctx context.Context, request UpdateLlmProxyPartnerPoweredAccountRequest) (*LlmProxyPartnerPoweredAccount, error)
}

func NewLlmProxyPartnerPoweredAccount(client *client.DatabricksClient) *LlmProxyPartnerPoweredAccountAPI {
	return &LlmProxyPartnerPoweredAccountAPI{
		llmProxyPartnerPoweredAccountImpl: llmProxyPartnerPoweredAccountImpl{
			client: client,
		},
	}
}

// Determines if partner powered models are enabled or not for a specific
// account
type LlmProxyPartnerPoweredAccountAPI struct {
	llmProxyPartnerPoweredAccountImpl
}

type LlmProxyPartnerPoweredEnforceInterface interface {

	// Gets the enforcement status of partner powered AI features account setting.
	Get(ctx context.Context, request GetLlmProxyPartnerPoweredEnforceRequest) (*LlmProxyPartnerPoweredEnforce, error)

	// Updates the enable enforcement status of partner powered AI features account
	// setting.
	Update(ctx context.Context, request UpdateLlmProxyPartnerPoweredEnforceRequest) (*LlmProxyPartnerPoweredEnforce, error)
}

func NewLlmProxyPartnerPoweredEnforce(client *client.DatabricksClient) *LlmProxyPartnerPoweredEnforceAPI {
	return &LlmProxyPartnerPoweredEnforceAPI{
		llmProxyPartnerPoweredEnforceImpl: llmProxyPartnerPoweredEnforceImpl{
			client: client,
		},
	}
}

// Determines if the account-level partner-powered setting value is enforced
// upon the workspace-level partner-powered setting
type LlmProxyPartnerPoweredEnforceAPI struct {
	llmProxyPartnerPoweredEnforceImpl
}

type LlmProxyPartnerPoweredWorkspaceInterface interface {

	// Reverts the enable partner powered AI features workspace setting to its
	// default value.
	Delete(ctx context.Context, request DeleteLlmProxyPartnerPoweredWorkspaceRequest) (*DeleteLlmProxyPartnerPoweredWorkspaceResponse, error)

	// Gets the enable partner powered AI features workspace setting.
	Get(ctx context.Context, request GetLlmProxyPartnerPoweredWorkspaceRequest) (*LlmProxyPartnerPoweredWorkspace, error)

	// Updates the enable partner powered AI features workspace setting.
	Update(ctx context.Context, request UpdateLlmProxyPartnerPoweredWorkspaceRequest) (*LlmProxyPartnerPoweredWorkspace, error)
}

func NewLlmProxyPartnerPoweredWorkspace(client *client.DatabricksClient) *LlmProxyPartnerPoweredWorkspaceAPI {
	return &LlmProxyPartnerPoweredWorkspaceAPI{
		llmProxyPartnerPoweredWorkspaceImpl: llmProxyPartnerPoweredWorkspaceImpl{
			client: client,
		},
	}
}

// Determines if partner powered models are enabled or not for a specific
// workspace
type LlmProxyPartnerPoweredWorkspaceAPI struct {
	llmProxyPartnerPoweredWorkspaceImpl
}

type NetworkConnectivityInterface interface {

	// Creates a network connectivity configuration (NCC), which provides stable
	// Azure service subnets when accessing your Azure Storage accounts. You can
	// also use a network connectivity configuration to create Databricks managed
	// private endpoints so that Databricks serverless compute resources privately
	// access your resources.
	//
	// **IMPORTANT**: After you create the network connectivity configuration, you
	// must assign one or more workspaces to the new network connectivity
	// configuration. You can share one network connectivity configuration with
	// multiple workspaces from the same Azure region within the same Databricks
	// account. See [configure serverless secure connectivity].
	//
	// [configure serverless secure connectivity]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security
	CreateNetworkConnectivityConfiguration(ctx context.Context, request CreateNetworkConnectivityConfigRequest) (*NetworkConnectivityConfiguration, error)

	// Create a private endpoint rule for the specified network connectivity config
	// object. Once the object is created, Databricks asynchronously provisions a
	// new Azure private endpoint to your specified Azure resource.
	//
	// **IMPORTANT**: You must use Azure portal or other Azure tools to approve the
	// private endpoint to complete the connection. To get the information of the
	// private endpoint created, make a `GET` request on the new private endpoint
	// rule. See [serverless private link].
	//
	// [serverless private link]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security/serverless-private-link
	CreatePrivateEndpointRule(ctx context.Context, request CreatePrivateEndpointRuleRequest) (*NccPrivateEndpointRule, error)

	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfiguration(ctx context.Context, request DeleteNetworkConnectivityConfigurationRequest) error

	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error

	// Initiates deleting a private endpoint rule. If the connection state is
	// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
	// the private endpoint is deactivated and will be deleted after seven days of
	// deactivation. When a private endpoint is deactivated, the `deactivated` field
	// is set to `true` and the private endpoint is not available to your serverless
	// compute resources.
	DeletePrivateEndpointRule(ctx context.Context, request DeletePrivateEndpointRuleRequest) (*NccPrivateEndpointRule, error)

	// Initiates deleting a private endpoint rule. If the connection state is
	// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
	// the private endpoint is deactivated and will be deleted after seven days of
	// deactivation. When a private endpoint is deactivated, the `deactivated` field
	// is set to `true` and the private endpoint is not available to your serverless
	// compute resources.
	DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccPrivateEndpointRule, error)

	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfiguration(ctx context.Context, request GetNetworkConnectivityConfigurationRequest) (*NetworkConnectivityConfiguration, error)

	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error)

	// Gets the private endpoint rule.
	GetPrivateEndpointRule(ctx context.Context, request GetPrivateEndpointRuleRequest) (*NccPrivateEndpointRule, error)

	// Gets the private endpoint rule.
	GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccPrivateEndpointRule, error)

	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurations(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) listing.Iterator[NetworkConnectivityConfiguration]

	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurationsAll(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) ([]NetworkConnectivityConfiguration, error)

	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRules(ctx context.Context, request ListPrivateEndpointRulesRequest) listing.Iterator[NccPrivateEndpointRule]

	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRulesAll(ctx context.Context, request ListPrivateEndpointRulesRequest) ([]NccPrivateEndpointRule, error)

	// Gets an array of private endpoint rules.
	ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListPrivateEndpointRulesResponse, error)

	// Updates a private endpoint rule. Currently only a private endpoint rule to
	// customer-managed resources is allowed to be updated.
	UpdatePrivateEndpointRule(ctx context.Context, request UpdateNccPrivateEndpointRuleRequest) (*NccPrivateEndpointRule, error)
}

func NewNetworkConnectivity(client *client.DatabricksClient) *NetworkConnectivityAPI {
	return &NetworkConnectivityAPI{
		networkConnectivityImpl: networkConnectivityImpl{
			client: client,
		},
	}
}

// These APIs provide configurations for the network connectivity of your
// workspaces for serverless compute resources. This API provides stable subnets
// for your workspace so that you can configure your firewalls on your Azure
// Storage accounts to allow access from Databricks. You can also use the API to
// provision private endpoints for Databricks to privately connect serverless
// compute resources to your Azure resources using Azure Private Link. See
// [configure serverless secure connectivity].
//
// [configure serverless secure connectivity]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security
type NetworkConnectivityAPI struct {
	networkConnectivityImpl
}

// Deletes a network connectivity configuration.
func (a *NetworkConnectivityAPI) DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error {
	return a.networkConnectivityImpl.DeleteNetworkConnectivityConfiguration(ctx, DeleteNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Initiates deleting a private endpoint rule. If the connection state is
// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
// the private endpoint is deactivated and will be deleted after seven days of
// deactivation. When a private endpoint is deactivated, the `deactivated` field
// is set to `true` and the private endpoint is not available to your serverless
// compute resources.
func (a *NetworkConnectivityAPI) DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccPrivateEndpointRule, error) {
	return a.networkConnectivityImpl.DeletePrivateEndpointRule(ctx, DeletePrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// Gets a network connectivity configuration.
func (a *NetworkConnectivityAPI) GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error) {
	return a.networkConnectivityImpl.GetNetworkConnectivityConfiguration(ctx, GetNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Gets the private endpoint rule.
func (a *NetworkConnectivityAPI) GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccPrivateEndpointRule, error) {
	return a.networkConnectivityImpl.GetPrivateEndpointRule(ctx, GetPrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// Gets an array of private endpoint rules.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListPrivateEndpointRulesResponse, error) {
	return a.networkConnectivityImpl.internalListPrivateEndpointRules(ctx, ListPrivateEndpointRulesRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

type NetworkPoliciesInterface interface {

	// Creates a new network policy to manage which network destinations can be
	// accessed from the Databricks environment.
	CreateNetworkPolicyRpc(ctx context.Context, request CreateNetworkPolicyRequest) (*AccountNetworkPolicy, error)

	// Deletes a network policy. Cannot be called on 'default-policy'.
	DeleteNetworkPolicyRpc(ctx context.Context, request DeleteNetworkPolicyRequest) error

	// Deletes a network policy. Cannot be called on 'default-policy'.
	DeleteNetworkPolicyRpcByNetworkPolicyId(ctx context.Context, networkPolicyId string) error

	// Gets a network policy.
	GetNetworkPolicyRpc(ctx context.Context, request GetNetworkPolicyRequest) (*AccountNetworkPolicy, error)

	// Gets a network policy.
	GetNetworkPolicyRpcByNetworkPolicyId(ctx context.Context, networkPolicyId string) (*AccountNetworkPolicy, error)

	// Gets an array of network policies.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkPoliciesRpc(ctx context.Context, request ListNetworkPoliciesRequest) listing.Iterator[AccountNetworkPolicy]

	// Gets an array of network policies.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkPoliciesRpcAll(ctx context.Context, request ListNetworkPoliciesRequest) ([]AccountNetworkPolicy, error)

	// Updates a network policy. This allows you to modify the configuration of a
	// network policy.
	UpdateNetworkPolicyRpc(ctx context.Context, request UpdateNetworkPolicyRequest) (*AccountNetworkPolicy, error)
}

func NewNetworkPolicies(client *client.DatabricksClient) *NetworkPoliciesAPI {
	return &NetworkPoliciesAPI{
		networkPoliciesImpl: networkPoliciesImpl{
			client: client,
		},
	}
}

// These APIs manage network policies for this account. Network policies control
// which network destinations can be accessed from the Databricks environment.
// Each Databricks account includes a default policy named 'default-policy'.
// 'default-policy' is associated with any workspace lacking an explicit network
// policy assignment, and is automatically associated with each newly created
// workspace. 'default-policy' is reserved and cannot be deleted, but it can be
// updated to customize the default network access rules for your account.
type NetworkPoliciesAPI struct {
	networkPoliciesImpl
}

// Deletes a network policy. Cannot be called on 'default-policy'.
func (a *NetworkPoliciesAPI) DeleteNetworkPolicyRpcByNetworkPolicyId(ctx context.Context, networkPolicyId string) error {
	return a.networkPoliciesImpl.DeleteNetworkPolicyRpc(ctx, DeleteNetworkPolicyRequest{
		NetworkPolicyId: networkPolicyId,
	})
}

// Gets a network policy.
func (a *NetworkPoliciesAPI) GetNetworkPolicyRpcByNetworkPolicyId(ctx context.Context, networkPolicyId string) (*AccountNetworkPolicy, error) {
	return a.networkPoliciesImpl.GetNetworkPolicyRpc(ctx, GetNetworkPolicyRequest{
		NetworkPolicyId: networkPolicyId,
	})
}

type NotificationDestinationsInterface interface {

	// Creates a notification destination. Requires workspace admin permissions.
	Create(ctx context.Context, request CreateNotificationDestinationRequest) (*NotificationDestination, error)

	// Deletes a notification destination. Requires workspace admin permissions.
	Delete(ctx context.Context, request DeleteNotificationDestinationRequest) error

	// Deletes a notification destination. Requires workspace admin permissions.
	DeleteById(ctx context.Context, id string) error

	// Gets a notification destination.
	Get(ctx context.Context, request GetNotificationDestinationRequest) (*NotificationDestination, error)

	// Gets a notification destination.
	GetById(ctx context.Context, id string) (*NotificationDestination, error)

	// Lists notification destinations.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListNotificationDestinationsRequest) listing.Iterator[ListNotificationDestinationsResult]

	// Lists notification destinations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListNotificationDestinationsRequest) ([]ListNotificationDestinationsResult, error)

	// Updates a notification destination. Requires workspace admin permissions. At
	// least one field is required in the request body.
	Update(ctx context.Context, request UpdateNotificationDestinationRequest) (*NotificationDestination, error)
}

func NewNotificationDestinations(client *client.DatabricksClient) *NotificationDestinationsAPI {
	return &NotificationDestinationsAPI{
		notificationDestinationsImpl: notificationDestinationsImpl{
			client: client,
		},
	}
}

// The notification destinations API lets you programmatically manage a
// workspace's notification destinations. Notification destinations are used to
// send notifications for query alerts and jobs to destinations outside of
// Databricks. Only workspace admins can create, update, and delete notification
// destinations.
type NotificationDestinationsAPI struct {
	notificationDestinationsImpl
}

// Deletes a notification destination. Requires workspace admin permissions.
func (a *NotificationDestinationsAPI) DeleteById(ctx context.Context, id string) error {
	return a.notificationDestinationsImpl.Delete(ctx, DeleteNotificationDestinationRequest{
		Id: id,
	})
}

// Gets a notification destination.
func (a *NotificationDestinationsAPI) GetById(ctx context.Context, id string) (*NotificationDestination, error) {
	return a.notificationDestinationsImpl.Get(ctx, GetNotificationDestinationRequest{
		Id: id,
	})
}

type PersonalComputeInterface interface {

	// Reverts back the Personal Compute setting value to default (ON)
	Delete(ctx context.Context, request DeletePersonalComputeSettingRequest) (*DeletePersonalComputeSettingResponse, error)

	// Gets the value of the Personal Compute setting.
	Get(ctx context.Context, request GetPersonalComputeSettingRequest) (*PersonalComputeSetting, error)

	// Updates the value of the Personal Compute setting.
	Update(ctx context.Context, request UpdatePersonalComputeSettingRequest) (*PersonalComputeSetting, error)
}

func NewPersonalCompute(client *client.DatabricksClient) *PersonalComputeAPI {
	return &PersonalComputeAPI{
		personalComputeImpl: personalComputeImpl{
			client: client,
		},
	}
}

// The Personal Compute enablement setting lets you control which users can use
// the Personal Compute default policy to create compute resources. By default
// all users in all workspaces have access (ON), but you can change the setting
// to instead let individual workspaces configure access control (DELEGATE).
//
// There is only one instance of this setting per account. Since this setting
// has a default value, this setting is present on all accounts even though it's
// never set on a given account. Deletion reverts the value of the setting back
// to the default value.
type PersonalComputeAPI struct {
	personalComputeImpl
}

type RestrictWorkspaceAdminsInterface interface {

	// Reverts the restrict workspace admins setting status for the workspace. A
	// fresh etag needs to be provided in `DELETE` requests (as a query parameter).
	// The etag can be retrieved by making a `GET` request before the DELETE
	// request. If the setting is updated/deleted concurrently, `DELETE` fails with
	// 409 and the request must be retried by using the fresh etag in the 409
	// response.
	Delete(ctx context.Context, request DeleteRestrictWorkspaceAdminsSettingRequest) (*DeleteRestrictWorkspaceAdminsSettingResponse, error)

	// Gets the restrict workspace admins setting.
	Get(ctx context.Context, request GetRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)

	// Updates the restrict workspace admins setting for the workspace. A fresh etag
	// needs to be provided in `PATCH` requests (as part of the setting field). The
	// etag can be retrieved by making a GET request before the `PATCH` request. If
	// the setting is updated concurrently, `PATCH` fails with 409 and the request
	// must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)
}

func NewRestrictWorkspaceAdmins(client *client.DatabricksClient) *RestrictWorkspaceAdminsAPI {
	return &RestrictWorkspaceAdminsAPI{
		restrictWorkspaceAdminsImpl: restrictWorkspaceAdminsImpl{
			client: client,
		},
	}
}

// The Restrict Workspace Admins setting lets you control the capabilities of
// workspace admins. With the setting status set to ALLOW_ALL, workspace admins
// can create service principal personal access tokens on behalf of any service
// principal in their workspace. Workspace admins can also change a job owner to
// any user in their workspace. And they can change the job run_as setting to
// any user in their workspace or to a service principal on which they have the
// Service Principal User role. With the setting status set to
// RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins can only create personal
// access tokens on behalf of service principals they have the Service Principal
// User role on. They can also only change a job owner to themselves. And they
// can change the job run_as setting to themselves or to a service principal on
// which they have the Service Principal User role.
type RestrictWorkspaceAdminsAPI struct {
	restrictWorkspaceAdminsImpl
}

type SettingsInterface interface {

	// Controls whether AI/BI published dashboard embedding is enabled,
	// conditionally enabled, or disabled at the workspace level. By default,
	// this setting is conditionally enabled (ALLOW_APPROVED_DOMAINS).
	AibiDashboardEmbeddingAccessPolicy() AibiDashboardEmbeddingAccessPolicyInterface

	// Controls the list of domains approved to host the embedded AI/BI
	// dashboards. The approved domains list can't be mutated when the current
	// access policy is not set to ALLOW_APPROVED_DOMAINS.
	AibiDashboardEmbeddingApprovedDomains() AibiDashboardEmbeddingApprovedDomainsInterface

	// Controls whether automatic cluster update is enabled for the current
	// workspace. By default, it is turned off.
	AutomaticClusterUpdate() AutomaticClusterUpdateInterface

	// Controls whether to enable the compliance security profile for the
	// current workspace. Enabling it on a workspace is permanent. By default,
	// it is turned off.
	//
	// This settings can NOT be disabled once it is enabled.
	ComplianceSecurityProfile() ComplianceSecurityProfileInterface

	// Controls whether schedules or workload tasks for refreshing AI/BI
	// Dashboards in the workspace can send subscription emails containing PDFs
	// and/or images of the dashboard. By default, this setting is enabled (set
	// to `true`)
	DashboardEmailSubscriptions() DashboardEmailSubscriptionsInterface

	// The default namespace setting API allows users to configure the default
	// namespace for a Databricks workspace.
	//
	// Through this API, users can retrieve, set, or modify the default
	// namespace used when queries do not reference a fully qualified
	// three-level name. For example, if you use the API to set 'retail_prod' as
	// the default catalog, then a query 'SELECT * FROM myTable' would reference
	// the object 'retail_prod.default.myTable' (the schema 'default' is always
	// assumed).
	//
	// This setting requires a restart of clusters and SQL warehouses to take
	// effect. Additionally, the default namespace only applies when using Unity
	// Catalog-enabled compute.
	DefaultNamespace() DefaultNamespaceInterface

	// Warehouse to be selected by default for users in this workspace. Covers
	// SQL workloads only and can be overridden by users.
	DefaultWarehouseId() DefaultWarehouseIdInterface

	// 'Disabling legacy access' has the following impacts:
	//
	// 1. Disables direct access to Hive Metastores from the workspace. However,
	// you can still access a Hive Metastore through Hive Metastore federation.
	// 2. Disables fallback mode on external location access from the workspace.
	// 3. Disables Databricks Runtime versions prior to 13.3LTS.
	DisableLegacyAccess() DisableLegacyAccessInterface

	// Disabling legacy DBFS has the following implications:
	//
	// 1. Access to DBFS root and DBFS mounts is disallowed (as well as the
	// creation of new mounts). 2. Disables Databricks Runtime versions prior to
	// 13.3LTS.
	//
	// When the setting is off, all DBFS functionality is enabled and no
	// restrictions are imposed on Databricks Runtime versions. This setting can
	// take up to 20 minutes to take effect and requires a manual restart of
	// all-purpose compute clusters and SQL warehouses.
	DisableLegacyDbfs() DisableLegacyDbfsInterface

	// Controls whether users can export notebooks and files from the Workspace
	// UI. By default, this setting is enabled.
	EnableExportNotebook() EnableExportNotebookInterface

	// Controls whether users can copy tabular data to the clipboard via the UI.
	// By default, this setting is enabled.
	EnableNotebookTableClipboard() EnableNotebookTableClipboardInterface

	// Controls whether users can download notebook results. By default, this
	// setting is enabled.
	EnableResultsDownloading() EnableResultsDownloadingInterface

	// Controls whether enhanced security monitoring is enabled for the current
	// workspace. If the compliance security profile is enabled, this is
	// automatically enabled. By default, it is disabled. However, if the
	// compliance security profile is enabled, this is automatically enabled.
	//
	// If the compliance security profile is disabled, you can enable or disable
	// this setting and it is not permanent.
	EnhancedSecurityMonitoring() EnhancedSecurityMonitoringInterface

	// Determines if partner powered models are enabled or not for a specific
	// workspace
	LlmProxyPartnerPoweredWorkspace() LlmProxyPartnerPoweredWorkspaceInterface

	// The Restrict Workspace Admins setting lets you control the capabilities
	// of workspace admins. With the setting status set to ALLOW_ALL, workspace
	// admins can create service principal personal access tokens on behalf of
	// any service principal in their workspace. Workspace admins can also
	// change a job owner to any user in their workspace. And they can change
	// the job run_as setting to any user in their workspace or to a service
	// principal on which they have the Service Principal User role. With the
	// setting status set to RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins
	// can only create personal access tokens on behalf of service principals
	// they have the Service Principal User role on. They can also only change a
	// job owner to themselves. And they can change the job run_as setting to
	// themselves or to a service principal on which they have the Service
	// Principal User role.
	RestrictWorkspaceAdmins() RestrictWorkspaceAdminsInterface

	// Controls whether users within the workspace are allowed to download
	// results from the SQL Editor and AI/BI Dashboards UIs. By default, this
	// setting is enabled (set to `true`)
	SqlResultsDownload() SqlResultsDownloadInterface
}

func NewSettings(client *client.DatabricksClient) *SettingsAPI {
	return &SettingsAPI{
		settingsImpl: settingsImpl{
			client: client,
		},

		aibiDashboardEmbeddingAccessPolicy: NewAibiDashboardEmbeddingAccessPolicy(client),

		aibiDashboardEmbeddingApprovedDomains: NewAibiDashboardEmbeddingApprovedDomains(client),

		automaticClusterUpdate: NewAutomaticClusterUpdate(client),

		complianceSecurityProfile: NewComplianceSecurityProfile(client),

		dashboardEmailSubscriptions: NewDashboardEmailSubscriptions(client),

		defaultNamespace: NewDefaultNamespace(client),

		defaultWarehouseId: NewDefaultWarehouseId(client),

		disableLegacyAccess: NewDisableLegacyAccess(client),

		disableLegacyDbfs: NewDisableLegacyDbfs(client),

		enableExportNotebook: NewEnableExportNotebook(client),

		enableNotebookTableClipboard: NewEnableNotebookTableClipboard(client),

		enableResultsDownloading: NewEnableResultsDownloading(client),

		enhancedSecurityMonitoring: NewEnhancedSecurityMonitoring(client),

		llmProxyPartnerPoweredWorkspace: NewLlmProxyPartnerPoweredWorkspace(client),

		restrictWorkspaceAdmins: NewRestrictWorkspaceAdmins(client),

		sqlResultsDownload: NewSqlResultsDownload(client),
	}
}

// Workspace Settings API allows users to manage settings at the workspace
// level.
type SettingsAPI struct {
	settingsImpl

	// Controls whether AI/BI published dashboard embedding is enabled,
	// conditionally enabled, or disabled at the workspace level. By default,
	// this setting is conditionally enabled (ALLOW_APPROVED_DOMAINS).
	aibiDashboardEmbeddingAccessPolicy AibiDashboardEmbeddingAccessPolicyInterface

	// Controls the list of domains approved to host the embedded AI/BI
	// dashboards. The approved domains list can't be mutated when the current
	// access policy is not set to ALLOW_APPROVED_DOMAINS.
	aibiDashboardEmbeddingApprovedDomains AibiDashboardEmbeddingApprovedDomainsInterface

	// Controls whether automatic cluster update is enabled for the current
	// workspace. By default, it is turned off.
	automaticClusterUpdate AutomaticClusterUpdateInterface

	// Controls whether to enable the compliance security profile for the
	// current workspace. Enabling it on a workspace is permanent. By default,
	// it is turned off.
	//
	// This settings can NOT be disabled once it is enabled.
	complianceSecurityProfile ComplianceSecurityProfileInterface

	// Controls whether schedules or workload tasks for refreshing AI/BI
	// Dashboards in the workspace can send subscription emails containing PDFs
	// and/or images of the dashboard. By default, this setting is enabled (set
	// to `true`)
	dashboardEmailSubscriptions DashboardEmailSubscriptionsInterface

	// The default namespace setting API allows users to configure the default
	// namespace for a Databricks workspace.
	//
	// Through this API, users can retrieve, set, or modify the default
	// namespace used when queries do not reference a fully qualified
	// three-level name. For example, if you use the API to set 'retail_prod' as
	// the default catalog, then a query 'SELECT * FROM myTable' would reference
	// the object 'retail_prod.default.myTable' (the schema 'default' is always
	// assumed).
	//
	// This setting requires a restart of clusters and SQL warehouses to take
	// effect. Additionally, the default namespace only applies when using Unity
	// Catalog-enabled compute.
	defaultNamespace DefaultNamespaceInterface

	// Warehouse to be selected by default for users in this workspace. Covers
	// SQL workloads only and can be overridden by users.
	defaultWarehouseId DefaultWarehouseIdInterface

	// 'Disabling legacy access' has the following impacts:
	//
	// 1. Disables direct access to Hive Metastores from the workspace. However,
	// you can still access a Hive Metastore through Hive Metastore federation.
	// 2. Disables fallback mode on external location access from the workspace.
	// 3. Disables Databricks Runtime versions prior to 13.3LTS.
	disableLegacyAccess DisableLegacyAccessInterface

	// Disabling legacy DBFS has the following implications:
	//
	// 1. Access to DBFS root and DBFS mounts is disallowed (as well as the
	// creation of new mounts). 2. Disables Databricks Runtime versions prior to
	// 13.3LTS.
	//
	// When the setting is off, all DBFS functionality is enabled and no
	// restrictions are imposed on Databricks Runtime versions. This setting can
	// take up to 20 minutes to take effect and requires a manual restart of
	// all-purpose compute clusters and SQL warehouses.
	disableLegacyDbfs DisableLegacyDbfsInterface

	// Controls whether users can export notebooks and files from the Workspace
	// UI. By default, this setting is enabled.
	enableExportNotebook EnableExportNotebookInterface

	// Controls whether users can copy tabular data to the clipboard via the UI.
	// By default, this setting is enabled.
	enableNotebookTableClipboard EnableNotebookTableClipboardInterface

	// Controls whether users can download notebook results. By default, this
	// setting is enabled.
	enableResultsDownloading EnableResultsDownloadingInterface

	// Controls whether enhanced security monitoring is enabled for the current
	// workspace. If the compliance security profile is enabled, this is
	// automatically enabled. By default, it is disabled. However, if the
	// compliance security profile is enabled, this is automatically enabled.
	//
	// If the compliance security profile is disabled, you can enable or disable
	// this setting and it is not permanent.
	enhancedSecurityMonitoring EnhancedSecurityMonitoringInterface

	// Determines if partner powered models are enabled or not for a specific
	// workspace
	llmProxyPartnerPoweredWorkspace LlmProxyPartnerPoweredWorkspaceInterface

	// The Restrict Workspace Admins setting lets you control the capabilities
	// of workspace admins. With the setting status set to ALLOW_ALL, workspace
	// admins can create service principal personal access tokens on behalf of
	// any service principal in their workspace. Workspace admins can also
	// change a job owner to any user in their workspace. And they can change
	// the job run_as setting to any user in their workspace or to a service
	// principal on which they have the Service Principal User role. With the
	// setting status set to RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins
	// can only create personal access tokens on behalf of service principals
	// they have the Service Principal User role on. They can also only change a
	// job owner to themselves. And they can change the job run_as setting to
	// themselves or to a service principal on which they have the Service
	// Principal User role.
	restrictWorkspaceAdmins RestrictWorkspaceAdminsInterface

	// Controls whether users within the workspace are allowed to download
	// results from the SQL Editor and AI/BI Dashboards UIs. By default, this
	// setting is enabled (set to `true`)
	sqlResultsDownload SqlResultsDownloadInterface
}

func (a *SettingsAPI) AibiDashboardEmbeddingAccessPolicy() AibiDashboardEmbeddingAccessPolicyInterface {
	return a.aibiDashboardEmbeddingAccessPolicy
}

func (a *SettingsAPI) AibiDashboardEmbeddingApprovedDomains() AibiDashboardEmbeddingApprovedDomainsInterface {
	return a.aibiDashboardEmbeddingApprovedDomains
}

func (a *SettingsAPI) AutomaticClusterUpdate() AutomaticClusterUpdateInterface {
	return a.automaticClusterUpdate
}

func (a *SettingsAPI) ComplianceSecurityProfile() ComplianceSecurityProfileInterface {
	return a.complianceSecurityProfile
}

func (a *SettingsAPI) DashboardEmailSubscriptions() DashboardEmailSubscriptionsInterface {
	return a.dashboardEmailSubscriptions
}

func (a *SettingsAPI) DefaultNamespace() DefaultNamespaceInterface {
	return a.defaultNamespace
}

func (a *SettingsAPI) DefaultWarehouseId() DefaultWarehouseIdInterface {
	return a.defaultWarehouseId
}

func (a *SettingsAPI) DisableLegacyAccess() DisableLegacyAccessInterface {
	return a.disableLegacyAccess
}

func (a *SettingsAPI) DisableLegacyDbfs() DisableLegacyDbfsInterface {
	return a.disableLegacyDbfs
}

func (a *SettingsAPI) EnableExportNotebook() EnableExportNotebookInterface {
	return a.enableExportNotebook
}

func (a *SettingsAPI) EnableNotebookTableClipboard() EnableNotebookTableClipboardInterface {
	return a.enableNotebookTableClipboard
}

func (a *SettingsAPI) EnableResultsDownloading() EnableResultsDownloadingInterface {
	return a.enableResultsDownloading
}

func (a *SettingsAPI) EnhancedSecurityMonitoring() EnhancedSecurityMonitoringInterface {
	return a.enhancedSecurityMonitoring
}

func (a *SettingsAPI) LlmProxyPartnerPoweredWorkspace() LlmProxyPartnerPoweredWorkspaceInterface {
	return a.llmProxyPartnerPoweredWorkspace
}

func (a *SettingsAPI) RestrictWorkspaceAdmins() RestrictWorkspaceAdminsInterface {
	return a.restrictWorkspaceAdmins
}

func (a *SettingsAPI) SqlResultsDownload() SqlResultsDownloadInterface {
	return a.sqlResultsDownload
}

type SqlResultsDownloadInterface interface {

	// Reverts the SQL Results Download setting to its default value.
	Delete(ctx context.Context, request DeleteSqlResultsDownloadRequest) (*DeleteSqlResultsDownloadResponse, error)

	// Gets the SQL Results Download setting.
	Get(ctx context.Context, request GetSqlResultsDownloadRequest) (*SqlResultsDownload, error)

	// Updates the SQL Results Download setting.
	Update(ctx context.Context, request UpdateSqlResultsDownloadRequest) (*SqlResultsDownload, error)
}

func NewSqlResultsDownload(client *client.DatabricksClient) *SqlResultsDownloadAPI {
	return &SqlResultsDownloadAPI{
		sqlResultsDownloadImpl: sqlResultsDownloadImpl{
			client: client,
		},
	}
}

// Controls whether users within the workspace are allowed to download results
// from the SQL Editor and AI/BI Dashboards UIs. By default, this setting is
// enabled (set to `true`)
type SqlResultsDownloadAPI struct {
	sqlResultsDownloadImpl
}

type TokenManagementInterface interface {

	// Creates a token on behalf of a service principal.
	CreateOboToken(ctx context.Context, request CreateOboTokenRequest) (*CreateOboTokenResponse, error)

	// Deletes a token, specified by its ID.
	Delete(ctx context.Context, request DeleteTokenManagementRequest) error

	// Deletes a token, specified by its ID.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// Gets information about a token, specified by its ID.
	Get(ctx context.Context, request GetTokenManagementRequest) (*GetTokenResponse, error)

	// Gets information about a token, specified by its ID.
	GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error)

	// Gets the permission levels that a user can have on an object.
	GetPermissionLevels(ctx context.Context) (*GetTokenPermissionLevelsResponse, error)

	// Gets the permissions of all tokens. Tokens can inherit permissions from their
	// root object.
	GetPermissions(ctx context.Context) (*TokenPermissions, error)

	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListTokenManagementRequest) listing.Iterator[TokenInfo]

	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListTokenManagementRequest) ([]TokenInfo, error)

	// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error)

	// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*TokenInfo, error)

	// Sets permissions on an object, replacing existing permissions if they exist.
	// Deletes all direct permissions if none are specified. Objects can inherit
	// permissions from their root object.
	SetPermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)

	// Updates the permissions on all tokens. Tokens can inherit permissions from
	// their root object.
	UpdatePermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)
}

func NewTokenManagement(client *client.DatabricksClient) *TokenManagementAPI {
	return &TokenManagementAPI{
		tokenManagementImpl: tokenManagementImpl{
			client: client,
		},
	}
}

// Enables administrators to get all tokens and delete tokens for other users.
// Admins can either get every token, get a specific token by ID, or get all
// tokens for a particular user.
type TokenManagementAPI struct {
	tokenManagementImpl
}

// Deletes a token, specified by its ID.
func (a *TokenManagementAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.tokenManagementImpl.Delete(ctx, DeleteTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Gets information about a token, specified by its ID.
func (a *TokenManagementAPI) GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error) {
	return a.tokenManagementImpl.Get(ctx, GetTokenManagementRequest{
		TokenId: tokenId,
	})
}

// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) GetByComment(ctx context.Context, name string) (*TokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTokenManagementRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type TokensInterface interface {

	// Creates and returns a token for a user. If this call is made through token
	// authentication, it creates a token with the same client ID as the
	// authenticated token. If the user's token quota is exceeded, this call returns
	// an error **QUOTA_EXCEEDED**.
	Create(ctx context.Context, request CreateTokenRequest) (*CreateTokenResponse, error)

	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	Delete(ctx context.Context, request RevokeTokenRequest) error

	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[PublicTokenInfo]

	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]PublicTokenInfo, error)

	// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error)

	// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error)
}

func NewTokens(client *client.DatabricksClient) *TokensAPI {
	return &TokensAPI{
		tokensImpl: tokensImpl{
			client: client,
		},
	}
}

// The Token API allows you to create, list, and revoke tokens that can be used
// to authenticate and access Databricks REST APIs.
type TokensAPI struct {
	tokensImpl
}

// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *TokensAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.tokensImpl.Delete(ctx, RevokeTokenRequest{
		TokenId: tokenId,
	})
}

// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PublicTokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PublicTokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PublicTokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type WorkspaceConfInterface interface {

	// Gets the configuration status for a workspace.
	GetStatus(ctx context.Context, request GetStatusRequest) (*map[string]string, error)

	// Sets the configuration status for a workspace, including enabling or
	// disabling it.
	SetStatus(ctx context.Context, request WorkspaceConf) error
}

func NewWorkspaceConf(client *client.DatabricksClient) *WorkspaceConfAPI {
	return &WorkspaceConfAPI{
		workspaceConfImpl: workspaceConfImpl{
			client: client,
		},
	}
}

// This API allows updating known workspace settings for advanced users.
type WorkspaceConfAPI struct {
	workspaceConfImpl
}

type WorkspaceNetworkConfigurationInterface interface {

	// Gets the network option for a workspace. Every workspace has exactly one
	// network policy binding, with 'default-policy' used if no explicit assignment
	// exists.
	GetWorkspaceNetworkOptionRpc(ctx context.Context, request GetWorkspaceNetworkOptionRequest) (*WorkspaceNetworkOption, error)

	// Gets the network option for a workspace. Every workspace has exactly one
	// network policy binding, with 'default-policy' used if no explicit assignment
	// exists.
	GetWorkspaceNetworkOptionRpcByWorkspaceId(ctx context.Context, workspaceId int64) (*WorkspaceNetworkOption, error)

	// Updates the network option for a workspace. This operation associates the
	// workspace with the specified network policy. To revert to the default policy,
	// specify 'default-policy' as the network_policy_id.
	UpdateWorkspaceNetworkOptionRpc(ctx context.Context, request UpdateWorkspaceNetworkOptionRequest) (*WorkspaceNetworkOption, error)
}

func NewWorkspaceNetworkConfiguration(client *client.DatabricksClient) *WorkspaceNetworkConfigurationAPI {
	return &WorkspaceNetworkConfigurationAPI{
		workspaceNetworkConfigurationImpl: workspaceNetworkConfigurationImpl{
			client: client,
		},
	}
}

// These APIs allow configuration of network settings for Databricks workspaces
// by selecting which network policy to associate with the workspace. Each
// workspace is always associated with exactly one network policy that controls
// which network destinations can be accessed from the Databricks environment.
// By default, workspaces are associated with the 'default-policy' network
// policy. You cannot create or delete a workspace's network option, only update
// it to associate the workspace with a different policy
type WorkspaceNetworkConfigurationAPI struct {
	workspaceNetworkConfigurationImpl
}

// Gets the network option for a workspace. Every workspace has exactly one
// network policy binding, with 'default-policy' used if no explicit assignment
// exists.
func (a *WorkspaceNetworkConfigurationAPI) GetWorkspaceNetworkOptionRpcByWorkspaceId(ctx context.Context, workspaceId int64) (*WorkspaceNetworkOption, error) {
	return a.workspaceNetworkConfigurationImpl.GetWorkspaceNetworkOptionRpc(ctx, GetWorkspaceNetworkOptionRequest{
		WorkspaceId: workspaceId,
	})
}
