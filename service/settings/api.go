// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Ip Access Lists, Account Settings, Automatic Cluster Update, Credentials Manager, Csp Enablement, Csp Enablement Account, Default Namespace, Esm Enablement, Esm Enablement Account, Ip Access Lists, Network Connectivity, Personal Compute, Restrict Workspace Admins, Settings, Token Management, Tokens, Workspace Conf, etc.
package settings

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AccountIpAccessListsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAccountIpAccessListsInterface instead.
	WithImpl(impl AccountIpAccessListsService) AccountIpAccessListsInterface

	// Impl returns low-level AccountIpAccessLists API implementation
	// Deprecated: use MockAccountIpAccessListsInterface instead.
	Impl() AccountIpAccessListsService

	// Create access list.
	//
	// Creates an IP access list for the account.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteAccountIpAccessListRequest) error

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Get IP access list.
	//
	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetAccountIpAccessListRequest) (*GetIpAccessListResponse, error)

	// Get IP access list.
	//
	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error)

	// Get access lists.
	//
	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Get access lists.
	//
	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replace access list.
	//
	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Update access list.
	//
	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewAccountIpAccessLists(client *client.DatabricksClient) *AccountIpAccessListsAPI {
	return &AccountIpAccessListsAPI{
		impl: &accountIpAccessListsImpl{
			client: client,
		},
	}
}

// The Accounts IP Access List API enables account admins to configure IP access
// lists for access to the account console.
//
// Account IP Access Lists affect web application access and REST API access to
// the account console and account APIs. If the feature is disabled for the
// account, all access is allowed for this account. There is support for allow
// lists (inclusion) and block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the account, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the account, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the account supports a maximum
// of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the account-level IP access lists, it can take a few minutes
// for changes to take effect.
type AccountIpAccessListsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AccountIpAccessListsService)
	impl AccountIpAccessListsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAccountIpAccessListsInterface instead.
func (a *AccountIpAccessListsAPI) WithImpl(impl AccountIpAccessListsService) AccountIpAccessListsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AccountIpAccessLists API implementation
// Deprecated: use MockAccountIpAccessListsInterface instead.
func (a *AccountIpAccessListsAPI) Impl() AccountIpAccessListsService {
	return a.impl
}

// Create access list.
//
// Creates an IP access list for the account.
//
// A list can be an allow list or a block list. See the top of this file for a
// description of how the server treats allow lists and block lists at runtime.
//
// When creating or updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the new list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect.
func (a *AccountIpAccessListsAPI) Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error) {
	return a.impl.Create(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) Delete(ctx context.Context, request DeleteAccountIpAccessListRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.impl.Delete(ctx, DeleteAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get IP access list.
//
// Gets an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) Get(ctx context.Context, request GetAccountIpAccessListRequest) (*GetIpAccessListResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get IP access list.
//
// Gets an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error) {
	return a.impl.Get(ctx, GetAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access lists.
//
// Gets all IP access lists for the specified account.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) List(ctx context.Context) listing.Iterator[IpAccessListInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*GetIpAccessListsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *GetIpAccessListsResponse) []IpAccessListInfo {
		return resp.IpAccessLists
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// Get access lists.
//
// Gets all IP access lists for the specified account.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) ListAll(ctx context.Context) ([]IpAccessListInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[IpAccessListInfo](ctx, iterator)
}

// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Replace access list.
//
// Replaces an IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time. When replacing an IP access list: * For all allow lists and block lists
// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
// counts as a single value. Attempts to exceed that number return error 400
// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
// the calling user's current IP, error 400 is returned with `error_code` value
// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
func (a *AccountIpAccessListsAPI) Replace(ctx context.Context, request ReplaceIpAccessList) error {
	return a.impl.Replace(ctx, request)
}

// Update access list.
//
// Updates an existing IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time.
//
// When updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the updated list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect.
func (a *AccountIpAccessListsAPI) Update(ctx context.Context, request UpdateIpAccessList) error {
	return a.impl.Update(ctx, request)
}

type AccountSettingsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAccountSettingsInterface instead.
	WithImpl(impl AccountSettingsService) AccountSettingsInterface

	// Impl returns low-level AccountSettings API implementation
	// Deprecated: use MockAccountSettingsInterface instead.
	Impl() AccountSettingsService

	// The compliance security profile settings at the account level control
	// whether to enable it for new workspaces. By default, this account-level
	// setting is disabled for new workspaces. After workspace creation, account
	// admins can enable the compliance security profile individually for each
	// workspace.
	//
	// This settings can be disabled so that new workspaces do not have
	// compliance security profile enabled by default.
	CspEnablementAccount() CspEnablementAccountInterface

	// The enhanced security monitoring setting at the account level controls
	// whether to enable the feature on new workspaces. By default, this
	// account-level setting is disabled for new workspaces. After workspace
	// creation, account admins can enable enhanced security monitoring
	// individually for each workspace.
	EsmEnablementAccount() EsmEnablementAccountInterface

	// The Personal Compute enablement setting lets you control which users can
	// use the Personal Compute default policy to create compute resources. By
	// default all users in all workspaces have access (ON), but you can change
	// the setting to instead let individual workspaces configure access control
	// (DELEGATE).
	//
	// There is only one instance of this setting per account. Since this
	// setting has a default value, this setting is present on all accounts even
	// though it's never set on a given account. Deletion reverts the value of
	// the setting back to the default value.
	PersonalCompute() PersonalComputeInterface
}

func NewAccountSettings(client *client.DatabricksClient) *AccountSettingsAPI {
	return &AccountSettingsAPI{
		impl: &accountSettingsImpl{
			client: client,
		},

		cspEnablementAccount: NewCspEnablementAccount(client),

		esmEnablementAccount: NewEsmEnablementAccount(client),

		personalCompute: NewPersonalCompute(client),
	}
}

// Accounts Settings API allows users to manage settings at the account level.
type AccountSettingsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AccountSettingsService)
	impl AccountSettingsService

	// The compliance security profile settings at the account level control
	// whether to enable it for new workspaces. By default, this account-level
	// setting is disabled for new workspaces. After workspace creation, account
	// admins can enable the compliance security profile individually for each
	// workspace.
	//
	// This settings can be disabled so that new workspaces do not have
	// compliance security profile enabled by default.
	cspEnablementAccount CspEnablementAccountInterface

	// The enhanced security monitoring setting at the account level controls
	// whether to enable the feature on new workspaces. By default, this
	// account-level setting is disabled for new workspaces. After workspace
	// creation, account admins can enable enhanced security monitoring
	// individually for each workspace.
	esmEnablementAccount EsmEnablementAccountInterface

	// The Personal Compute enablement setting lets you control which users can
	// use the Personal Compute default policy to create compute resources. By
	// default all users in all workspaces have access (ON), but you can change
	// the setting to instead let individual workspaces configure access control
	// (DELEGATE).
	//
	// There is only one instance of this setting per account. Since this
	// setting has a default value, this setting is present on all accounts even
	// though it's never set on a given account. Deletion reverts the value of
	// the setting back to the default value.
	personalCompute PersonalComputeInterface
}

func (a *AccountSettingsAPI) CspEnablementAccount() CspEnablementAccountInterface {
	return a.cspEnablementAccount
}

func (a *AccountSettingsAPI) EsmEnablementAccount() EsmEnablementAccountInterface {
	return a.esmEnablementAccount
}

func (a *AccountSettingsAPI) PersonalCompute() PersonalComputeInterface {
	return a.personalCompute
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAccountSettingsInterface instead.
func (a *AccountSettingsAPI) WithImpl(impl AccountSettingsService) AccountSettingsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AccountSettings API implementation
// Deprecated: use MockAccountSettingsInterface instead.
func (a *AccountSettingsAPI) Impl() AccountSettingsService {
	return a.impl
}

type AutomaticClusterUpdateInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAutomaticClusterUpdateInterface instead.
	WithImpl(impl AutomaticClusterUpdateService) AutomaticClusterUpdateInterface

	// Impl returns low-level AutomaticClusterUpdate API implementation
	// Deprecated: use MockAutomaticClusterUpdateInterface instead.
	Impl() AutomaticClusterUpdateService

	// Get the automatic cluster update setting.
	//
	// Gets the automatic cluster update setting.
	Get(ctx context.Context, request GetAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error)

	// Update the automatic cluster update setting.
	//
	// Updates the automatic cluster update setting for the workspace. A fresh etag
	// needs to be provided in `PATCH` requests (as part of the setting field). The
	// etag can be retrieved by making a `GET` request before the `PATCH` request.
	// If the setting is updated concurrently, `PATCH` fails with 409 and the
	// request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error)
}

func NewAutomaticClusterUpdate(client *client.DatabricksClient) *AutomaticClusterUpdateAPI {
	return &AutomaticClusterUpdateAPI{
		impl: &automaticClusterUpdateImpl{
			client: client,
		},
	}
}

// Controls whether automatic cluster update is enabled for the current
// workspace. By default, it is turned off.
type AutomaticClusterUpdateAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AutomaticClusterUpdateService)
	impl AutomaticClusterUpdateService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAutomaticClusterUpdateInterface instead.
func (a *AutomaticClusterUpdateAPI) WithImpl(impl AutomaticClusterUpdateService) AutomaticClusterUpdateInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AutomaticClusterUpdate API implementation
// Deprecated: use MockAutomaticClusterUpdateInterface instead.
func (a *AutomaticClusterUpdateAPI) Impl() AutomaticClusterUpdateService {
	return a.impl
}

// Get the automatic cluster update setting.
//
// Gets the automatic cluster update setting.
func (a *AutomaticClusterUpdateAPI) Get(ctx context.Context, request GetAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update the automatic cluster update setting.
//
// Updates the automatic cluster update setting for the workspace. A fresh etag
// needs to be provided in `PATCH` requests (as part of the setting field). The
// etag can be retrieved by making a `GET` request before the `PATCH` request.
// If the setting is updated concurrently, `PATCH` fails with 409 and the
// request must be retried by using the fresh etag in the 409 response.
func (a *AutomaticClusterUpdateAPI) Update(ctx context.Context, request UpdateAutomaticClusterUpdateSettingRequest) (*AutomaticClusterUpdateSetting, error) {
	return a.impl.Update(ctx, request)
}

type CredentialsManagerInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockCredentialsManagerInterface instead.
	WithImpl(impl CredentialsManagerService) CredentialsManagerInterface

	// Impl returns low-level CredentialsManager API implementation
	// Deprecated: use MockCredentialsManagerInterface instead.
	Impl() CredentialsManagerService

	// Exchange token.
	//
	// Exchange tokens with an Identity Provider to get a new access token. It
	// allows specifying scopes to determine token permissions.
	ExchangeToken(ctx context.Context, request ExchangeTokenRequest) (*ExchangeTokenResponse, error)
}

func NewCredentialsManager(client *client.DatabricksClient) *CredentialsManagerAPI {
	return &CredentialsManagerAPI{
		impl: &credentialsManagerImpl{
			client: client,
		},
	}
}

// Credentials manager interacts with with Identity Providers to to perform
// token exchanges using stored credentials and refresh tokens.
type CredentialsManagerAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(CredentialsManagerService)
	impl CredentialsManagerService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockCredentialsManagerInterface instead.
func (a *CredentialsManagerAPI) WithImpl(impl CredentialsManagerService) CredentialsManagerInterface {
	a.impl = impl
	return a
}

// Impl returns low-level CredentialsManager API implementation
// Deprecated: use MockCredentialsManagerInterface instead.
func (a *CredentialsManagerAPI) Impl() CredentialsManagerService {
	return a.impl
}

// Exchange token.
//
// Exchange tokens with an Identity Provider to get a new access token. It
// allows specifying scopes to determine token permissions.
func (a *CredentialsManagerAPI) ExchangeToken(ctx context.Context, request ExchangeTokenRequest) (*ExchangeTokenResponse, error) {
	return a.impl.ExchangeToken(ctx, request)
}

type CspEnablementInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockCspEnablementInterface instead.
	WithImpl(impl CspEnablementService) CspEnablementInterface

	// Impl returns low-level CspEnablement API implementation
	// Deprecated: use MockCspEnablementInterface instead.
	Impl() CspEnablementService

	// Get the compliance security profile setting.
	//
	// Gets the compliance security profile setting.
	Get(ctx context.Context, request GetCspEnablementSettingRequest) (*CspEnablementSetting, error)

	// Update the compliance security profile setting.
	//
	// Updates the compliance security profile setting for the workspace. A fresh
	// etag needs to be provided in `PATCH` requests (as part of the setting field).
	// The etag can be retrieved by making a `GET` request before the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateCspEnablementSettingRequest) (*CspEnablementSetting, error)
}

func NewCspEnablement(client *client.DatabricksClient) *CspEnablementAPI {
	return &CspEnablementAPI{
		impl: &cspEnablementImpl{
			client: client,
		},
	}
}

// Controls whether to enable the compliance security profile for the current
// workspace. Enabling it on a workspace is permanent. By default, it is turned
// off.
//
// This settings can NOT be disabled once it is enabled.
type CspEnablementAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(CspEnablementService)
	impl CspEnablementService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockCspEnablementInterface instead.
func (a *CspEnablementAPI) WithImpl(impl CspEnablementService) CspEnablementInterface {
	a.impl = impl
	return a
}

// Impl returns low-level CspEnablement API implementation
// Deprecated: use MockCspEnablementInterface instead.
func (a *CspEnablementAPI) Impl() CspEnablementService {
	return a.impl
}

// Get the compliance security profile setting.
//
// Gets the compliance security profile setting.
func (a *CspEnablementAPI) Get(ctx context.Context, request GetCspEnablementSettingRequest) (*CspEnablementSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update the compliance security profile setting.
//
// Updates the compliance security profile setting for the workspace. A fresh
// etag needs to be provided in `PATCH` requests (as part of the setting field).
// The etag can be retrieved by making a `GET` request before the `PATCH`
// request. If the setting is updated concurrently, `PATCH` fails with 409 and
// the request must be retried by using the fresh etag in the 409 response.
func (a *CspEnablementAPI) Update(ctx context.Context, request UpdateCspEnablementSettingRequest) (*CspEnablementSetting, error) {
	return a.impl.Update(ctx, request)
}

type CspEnablementAccountInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockCspEnablementAccountInterface instead.
	WithImpl(impl CspEnablementAccountService) CspEnablementAccountInterface

	// Impl returns low-level CspEnablementAccount API implementation
	// Deprecated: use MockCspEnablementAccountInterface instead.
	Impl() CspEnablementAccountService

	// Get the compliance security profile setting for new workspaces.
	//
	// Gets the compliance security profile setting for new workspaces.
	Get(ctx context.Context, request GetCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error)

	// Update the compliance security profile setting for new workspaces.
	//
	// Updates the value of the compliance security profile setting for new
	// workspaces.
	Update(ctx context.Context, request UpdateCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error)
}

func NewCspEnablementAccount(client *client.DatabricksClient) *CspEnablementAccountAPI {
	return &CspEnablementAccountAPI{
		impl: &cspEnablementAccountImpl{
			client: client,
		},
	}
}

// The compliance security profile settings at the account level control whether
// to enable it for new workspaces. By default, this account-level setting is
// disabled for new workspaces. After workspace creation, account admins can
// enable the compliance security profile individually for each workspace.
//
// This settings can be disabled so that new workspaces do not have compliance
// security profile enabled by default.
type CspEnablementAccountAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(CspEnablementAccountService)
	impl CspEnablementAccountService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockCspEnablementAccountInterface instead.
func (a *CspEnablementAccountAPI) WithImpl(impl CspEnablementAccountService) CspEnablementAccountInterface {
	a.impl = impl
	return a
}

// Impl returns low-level CspEnablementAccount API implementation
// Deprecated: use MockCspEnablementAccountInterface instead.
func (a *CspEnablementAccountAPI) Impl() CspEnablementAccountService {
	return a.impl
}

// Get the compliance security profile setting for new workspaces.
//
// Gets the compliance security profile setting for new workspaces.
func (a *CspEnablementAccountAPI) Get(ctx context.Context, request GetCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update the compliance security profile setting for new workspaces.
//
// Updates the value of the compliance security profile setting for new
// workspaces.
func (a *CspEnablementAccountAPI) Update(ctx context.Context, request UpdateCspEnablementAccountSettingRequest) (*CspEnablementAccountSetting, error) {
	return a.impl.Update(ctx, request)
}

type DefaultNamespaceInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockDefaultNamespaceInterface instead.
	WithImpl(impl DefaultNamespaceService) DefaultNamespaceInterface

	// Impl returns low-level DefaultNamespace API implementation
	// Deprecated: use MockDefaultNamespaceInterface instead.
	Impl() DefaultNamespaceService

	// Delete the default namespace setting.
	//
	// Deletes the default namespace setting for the workspace. A fresh etag needs
	// to be provided in `DELETE` requests (as a query parameter). The etag can be
	// retrieved by making a `GET` request before the `DELETE` request. If the
	// setting is updated/deleted concurrently, `DELETE` fails with 409 and the
	// request must be retried by using the fresh etag in the 409 response.
	Delete(ctx context.Context, request DeleteDefaultNamespaceSettingRequest) (*DeleteDefaultNamespaceSettingResponse, error)

	// Get the default namespace setting.
	//
	// Gets the default namespace setting.
	Get(ctx context.Context, request GetDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)

	// Update the default namespace setting.
	//
	// Updates the default namespace setting for the workspace. A fresh etag needs
	// to be provided in `PATCH` requests (as part of the setting field). The etag
	// can be retrieved by making a `GET` request before the `PATCH` request. Note
	// that if the setting does not exist, `GET` returns a NOT_FOUND error and the
	// etag is present in the error response, which should be set in the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)
}

func NewDefaultNamespace(client *client.DatabricksClient) *DefaultNamespaceAPI {
	return &DefaultNamespaceAPI{
		impl: &defaultNamespaceImpl{
			client: client,
		},
	}
}

// The default namespace setting API allows users to configure the default
// namespace for a Databricks workspace.
//
// Through this API, users can retrieve, set, or modify the default namespace
// used when queries do not reference a fully qualified three-level name. For
// example, if you use the API to set 'retail_prod' as the default catalog, then
// a query 'SELECT * FROM myTable' would reference the object
// 'retail_prod.default.myTable' (the schema 'default' is always assumed).
//
// This setting requires a restart of clusters and SQL warehouses to take
// effect. Additionally, the default namespace only applies when using Unity
// Catalog-enabled compute.
type DefaultNamespaceAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(DefaultNamespaceService)
	impl DefaultNamespaceService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockDefaultNamespaceInterface instead.
func (a *DefaultNamespaceAPI) WithImpl(impl DefaultNamespaceService) DefaultNamespaceInterface {
	a.impl = impl
	return a
}

// Impl returns low-level DefaultNamespace API implementation
// Deprecated: use MockDefaultNamespaceInterface instead.
func (a *DefaultNamespaceAPI) Impl() DefaultNamespaceService {
	return a.impl
}

// Delete the default namespace setting.
//
// Deletes the default namespace setting for the workspace. A fresh etag needs
// to be provided in `DELETE` requests (as a query parameter). The etag can be
// retrieved by making a `GET` request before the `DELETE` request. If the
// setting is updated/deleted concurrently, `DELETE` fails with 409 and the
// request must be retried by using the fresh etag in the 409 response.
func (a *DefaultNamespaceAPI) Delete(ctx context.Context, request DeleteDefaultNamespaceSettingRequest) (*DeleteDefaultNamespaceSettingResponse, error) {
	return a.impl.Delete(ctx, request)
}

// Get the default namespace setting.
//
// Gets the default namespace setting.
func (a *DefaultNamespaceAPI) Get(ctx context.Context, request GetDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update the default namespace setting.
//
// Updates the default namespace setting for the workspace. A fresh etag needs
// to be provided in `PATCH` requests (as part of the setting field). The etag
// can be retrieved by making a `GET` request before the `PATCH` request. Note
// that if the setting does not exist, `GET` returns a NOT_FOUND error and the
// etag is present in the error response, which should be set in the `PATCH`
// request. If the setting is updated concurrently, `PATCH` fails with 409 and
// the request must be retried by using the fresh etag in the 409 response.
func (a *DefaultNamespaceAPI) Update(ctx context.Context, request UpdateDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error) {
	return a.impl.Update(ctx, request)
}

type EsmEnablementInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockEsmEnablementInterface instead.
	WithImpl(impl EsmEnablementService) EsmEnablementInterface

	// Impl returns low-level EsmEnablement API implementation
	// Deprecated: use MockEsmEnablementInterface instead.
	Impl() EsmEnablementService

	// Get the enhanced security monitoring setting.
	//
	// Gets the enhanced security monitoring setting.
	Get(ctx context.Context, request GetEsmEnablementSettingRequest) (*EsmEnablementSetting, error)

	// Update the enhanced security monitoring setting.
	//
	// Updates the enhanced security monitoring setting for the workspace. A fresh
	// etag needs to be provided in `PATCH` requests (as part of the setting field).
	// The etag can be retrieved by making a `GET` request before the `PATCH`
	// request. If the setting is updated concurrently, `PATCH` fails with 409 and
	// the request must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateEsmEnablementSettingRequest) (*EsmEnablementSetting, error)
}

func NewEsmEnablement(client *client.DatabricksClient) *EsmEnablementAPI {
	return &EsmEnablementAPI{
		impl: &esmEnablementImpl{
			client: client,
		},
	}
}

// Controls whether enhanced security monitoring is enabled for the current
// workspace. If the compliance security profile is enabled, this is
// automatically enabled. By default, it is disabled. However, if the compliance
// security profile is enabled, this is automatically enabled.
//
// If the compliance security profile is disabled, you can enable or disable
// this setting and it is not permanent.
type EsmEnablementAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(EsmEnablementService)
	impl EsmEnablementService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockEsmEnablementInterface instead.
func (a *EsmEnablementAPI) WithImpl(impl EsmEnablementService) EsmEnablementInterface {
	a.impl = impl
	return a
}

// Impl returns low-level EsmEnablement API implementation
// Deprecated: use MockEsmEnablementInterface instead.
func (a *EsmEnablementAPI) Impl() EsmEnablementService {
	return a.impl
}

// Get the enhanced security monitoring setting.
//
// Gets the enhanced security monitoring setting.
func (a *EsmEnablementAPI) Get(ctx context.Context, request GetEsmEnablementSettingRequest) (*EsmEnablementSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update the enhanced security monitoring setting.
//
// Updates the enhanced security monitoring setting for the workspace. A fresh
// etag needs to be provided in `PATCH` requests (as part of the setting field).
// The etag can be retrieved by making a `GET` request before the `PATCH`
// request. If the setting is updated concurrently, `PATCH` fails with 409 and
// the request must be retried by using the fresh etag in the 409 response.
func (a *EsmEnablementAPI) Update(ctx context.Context, request UpdateEsmEnablementSettingRequest) (*EsmEnablementSetting, error) {
	return a.impl.Update(ctx, request)
}

type EsmEnablementAccountInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockEsmEnablementAccountInterface instead.
	WithImpl(impl EsmEnablementAccountService) EsmEnablementAccountInterface

	// Impl returns low-level EsmEnablementAccount API implementation
	// Deprecated: use MockEsmEnablementAccountInterface instead.
	Impl() EsmEnablementAccountService

	// Get the enhanced security monitoring setting for new workspaces.
	//
	// Gets the enhanced security monitoring setting for new workspaces.
	Get(ctx context.Context, request GetEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error)

	// Update the enhanced security monitoring setting for new workspaces.
	//
	// Updates the value of the enhanced security monitoring setting for new
	// workspaces.
	Update(ctx context.Context, request UpdateEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error)
}

func NewEsmEnablementAccount(client *client.DatabricksClient) *EsmEnablementAccountAPI {
	return &EsmEnablementAccountAPI{
		impl: &esmEnablementAccountImpl{
			client: client,
		},
	}
}

// The enhanced security monitoring setting at the account level controls
// whether to enable the feature on new workspaces. By default, this
// account-level setting is disabled for new workspaces. After workspace
// creation, account admins can enable enhanced security monitoring individually
// for each workspace.
type EsmEnablementAccountAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(EsmEnablementAccountService)
	impl EsmEnablementAccountService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockEsmEnablementAccountInterface instead.
func (a *EsmEnablementAccountAPI) WithImpl(impl EsmEnablementAccountService) EsmEnablementAccountInterface {
	a.impl = impl
	return a
}

// Impl returns low-level EsmEnablementAccount API implementation
// Deprecated: use MockEsmEnablementAccountInterface instead.
func (a *EsmEnablementAccountAPI) Impl() EsmEnablementAccountService {
	return a.impl
}

// Get the enhanced security monitoring setting for new workspaces.
//
// Gets the enhanced security monitoring setting for new workspaces.
func (a *EsmEnablementAccountAPI) Get(ctx context.Context, request GetEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update the enhanced security monitoring setting for new workspaces.
//
// Updates the value of the enhanced security monitoring setting for new
// workspaces.
func (a *EsmEnablementAccountAPI) Update(ctx context.Context, request UpdateEsmEnablementAccountSettingRequest) (*EsmEnablementAccountSetting, error) {
	return a.impl.Update(ctx, request)
}

type IpAccessListsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockIpAccessListsInterface instead.
	WithImpl(impl IpAccessListsService) IpAccessListsInterface

	// Impl returns low-level IpAccessLists API implementation
	// Deprecated: use MockIpAccessListsInterface instead.
	Impl() IpAccessListsService

	// Create access list.
	//
	// Creates an IP access list for this workspace.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. **Note**: Your new
	// IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteIpAccessListRequest) error

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Get access list.
	//
	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetIpAccessList) (*FetchIpAccessListResponse, error)

	// Get access list.
	//
	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error)

	// Get access lists.
	//
	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Get access lists.
	//
	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replace access list.
	//
	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	// Note that your resulting IP access list has no effect until you enable the
	// feature. See :method:workspaceconf/setStatus.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Update access list.
	//
	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. Note that your
	// resulting IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewIpAccessLists(client *client.DatabricksClient) *IpAccessListsAPI {
	return &IpAccessListsAPI{
		impl: &ipAccessListsImpl{
			client: client,
		},
	}
}

// IP Access List enables admins to configure IP access lists.
//
// IP access lists affect web application access and REST API access to this
// workspace only. If the feature is disabled for a workspace, all access is
// allowed for this workspace. There is support for allow lists (inclusion) and
// block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the workspace, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the workspace, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the workspace supports a
// maximum of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the IP access list feature, it can take a few minutes for
// changes to take effect.
type IpAccessListsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(IpAccessListsService)
	impl IpAccessListsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockIpAccessListsInterface instead.
func (a *IpAccessListsAPI) WithImpl(impl IpAccessListsService) IpAccessListsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level IpAccessLists API implementation
// Deprecated: use MockIpAccessListsInterface instead.
func (a *IpAccessListsAPI) Impl() IpAccessListsService {
	return a.impl
}

// Create access list.
//
// Creates an IP access list for this workspace.
//
// A list can be an allow list or a block list. See the top of this file for a
// description of how the server treats allow lists and block lists at runtime.
//
// When creating or updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the new list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect. **Note**: Your new
// IP access list has no effect until you enable the feature. See
// :method:workspaceconf/setStatus
func (a *IpAccessListsAPI) Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error) {
	return a.impl.Create(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) Delete(ctx context.Context, request DeleteIpAccessListRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.impl.Delete(ctx, DeleteIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access list.
//
// Gets an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) Get(ctx context.Context, request GetIpAccessList) (*FetchIpAccessListResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get access list.
//
// Gets an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error) {
	return a.impl.Get(ctx, GetIpAccessList{
		IpAccessListId: ipAccessListId,
	})
}

// Get access lists.
//
// Gets all IP access lists for the specified workspace.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) List(ctx context.Context) listing.Iterator[IpAccessListInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListIpAccessListResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListIpAccessListResponse) []IpAccessListInfo {
		return resp.IpAccessLists
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// Get access lists.
//
// Gets all IP access lists for the specified workspace.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) ListAll(ctx context.Context) ([]IpAccessListInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[IpAccessListInfo](ctx, iterator)
}

// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Replace access list.
//
// Replaces an IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time. When replacing an IP access list: * For all allow lists and block lists
// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
// counts as a single value. Attempts to exceed that number return error 400
// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
// the calling user's current IP, error 400 is returned with `error_code` value
// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
// Note that your resulting IP access list has no effect until you enable the
// feature. See :method:workspaceconf/setStatus.
func (a *IpAccessListsAPI) Replace(ctx context.Context, request ReplaceIpAccessList) error {
	return a.impl.Replace(ctx, request)
}

// Update access list.
//
// Updates an existing IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time.
//
// When updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the updated list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect. Note that your
// resulting IP access list has no effect until you enable the feature. See
// :method:workspaceconf/setStatus.
func (a *IpAccessListsAPI) Update(ctx context.Context, request UpdateIpAccessList) error {
	return a.impl.Update(ctx, request)
}

type NetworkConnectivityInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockNetworkConnectivityInterface instead.
	WithImpl(impl NetworkConnectivityService) NetworkConnectivityInterface

	// Impl returns low-level NetworkConnectivity API implementation
	// Deprecated: use MockNetworkConnectivityInterface instead.
	Impl() NetworkConnectivityService

	// Create a network connectivity configuration.
	CreateNetworkConnectivityConfiguration(ctx context.Context, request CreateNetworkConnectivityConfigRequest) (*NetworkConnectivityConfiguration, error)

	// Create a private endpoint rule.
	//
	// Create a private endpoint rule for the specified network connectivity config
	// object. Once the object is created, Databricks asynchronously provisions a
	// new Azure private endpoint to your specified Azure resource.
	//
	// **IMPORTANT**: You must use Azure portal or other Azure tools to approve the
	// private endpoint to complete the connection. To get the information of the
	// private endpoint created, make a `GET` request on the new private endpoint
	// rule. See [serverless private link].
	//
	// [serverless private link]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security/serverless-private-link
	CreatePrivateEndpointRule(ctx context.Context, request CreatePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Delete a network connectivity configuration.
	//
	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfiguration(ctx context.Context, request DeleteNetworkConnectivityConfigurationRequest) error

	// Delete a network connectivity configuration.
	//
	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error

	// Delete a private endpoint rule.
	//
	// Initiates deleting a private endpoint rule. If the connection state is
	// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
	// the private endpoint is deactivated and will be deleted after seven days of
	// deactivation. When a private endpoint is deactivated, the `deactivated` field
	// is set to `true` and the private endpoint is not available to your serverless
	// compute resources.
	DeletePrivateEndpointRule(ctx context.Context, request DeletePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Delete a private endpoint rule.
	//
	// Initiates deleting a private endpoint rule. If the connection state is
	// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
	// the private endpoint is deactivated and will be deleted after seven days of
	// deactivation. When a private endpoint is deactivated, the `deactivated` field
	// is set to `true` and the private endpoint is not available to your serverless
	// compute resources.
	DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error)

	// Get a network connectivity configuration.
	//
	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfiguration(ctx context.Context, request GetNetworkConnectivityConfigurationRequest) (*NetworkConnectivityConfiguration, error)

	// Get a network connectivity configuration.
	//
	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error)

	// Get a private endpoint rule.
	//
	// Gets the private endpoint rule.
	GetPrivateEndpointRule(ctx context.Context, request GetPrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Get a private endpoint rule.
	//
	// Gets the private endpoint rule.
	GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error)

	// List network connectivity configurations.
	//
	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurations(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) listing.Iterator[NetworkConnectivityConfiguration]

	// List network connectivity configurations.
	//
	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurationsAll(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) ([]NetworkConnectivityConfiguration, error)

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRules(ctx context.Context, request ListPrivateEndpointRulesRequest) listing.Iterator[NccAzurePrivateEndpointRule]

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRulesAll(ctx context.Context, request ListPrivateEndpointRulesRequest) ([]NccAzurePrivateEndpointRule, error)

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error)
}

func NewNetworkConnectivity(client *client.DatabricksClient) *NetworkConnectivityAPI {
	return &NetworkConnectivityAPI{
		impl: &networkConnectivityImpl{
			client: client,
		},
	}
}

// These APIs provide configurations for the network connectivity of your
// workspaces for serverless compute resources.
type NetworkConnectivityAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(NetworkConnectivityService)
	impl NetworkConnectivityService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockNetworkConnectivityInterface instead.
func (a *NetworkConnectivityAPI) WithImpl(impl NetworkConnectivityService) NetworkConnectivityInterface {
	a.impl = impl
	return a
}

// Impl returns low-level NetworkConnectivity API implementation
// Deprecated: use MockNetworkConnectivityInterface instead.
func (a *NetworkConnectivityAPI) Impl() NetworkConnectivityService {
	return a.impl
}

// Create a network connectivity configuration.
func (a *NetworkConnectivityAPI) CreateNetworkConnectivityConfiguration(ctx context.Context, request CreateNetworkConnectivityConfigRequest) (*NetworkConnectivityConfiguration, error) {
	return a.impl.CreateNetworkConnectivityConfiguration(ctx, request)
}

// Create a private endpoint rule.
//
// Create a private endpoint rule for the specified network connectivity config
// object. Once the object is created, Databricks asynchronously provisions a
// new Azure private endpoint to your specified Azure resource.
//
// **IMPORTANT**: You must use Azure portal or other Azure tools to approve the
// private endpoint to complete the connection. To get the information of the
// private endpoint created, make a `GET` request on the new private endpoint
// rule. See [serverless private link].
//
// [serverless private link]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security/serverless-private-link
func (a *NetworkConnectivityAPI) CreatePrivateEndpointRule(ctx context.Context, request CreatePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.CreatePrivateEndpointRule(ctx, request)
}

// Delete a network connectivity configuration.
//
// Deletes a network connectivity configuration.
func (a *NetworkConnectivityAPI) DeleteNetworkConnectivityConfiguration(ctx context.Context, request DeleteNetworkConnectivityConfigurationRequest) error {
	return a.impl.DeleteNetworkConnectivityConfiguration(ctx, request)
}

// Delete a network connectivity configuration.
//
// Deletes a network connectivity configuration.
func (a *NetworkConnectivityAPI) DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error {
	return a.impl.DeleteNetworkConnectivityConfiguration(ctx, DeleteNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Delete a private endpoint rule.
//
// Initiates deleting a private endpoint rule. If the connection state is
// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
// the private endpoint is deactivated and will be deleted after seven days of
// deactivation. When a private endpoint is deactivated, the `deactivated` field
// is set to `true` and the private endpoint is not available to your serverless
// compute resources.
func (a *NetworkConnectivityAPI) DeletePrivateEndpointRule(ctx context.Context, request DeletePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.DeletePrivateEndpointRule(ctx, request)
}

// Delete a private endpoint rule.
//
// Initiates deleting a private endpoint rule. If the connection state is
// PENDING or EXPIRED, the private endpoint is immediately deleted. Otherwise,
// the private endpoint is deactivated and will be deleted after seven days of
// deactivation. When a private endpoint is deactivated, the `deactivated` field
// is set to `true` and the private endpoint is not available to your serverless
// compute resources.
func (a *NetworkConnectivityAPI) DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.DeletePrivateEndpointRule(ctx, DeletePrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// Get a network connectivity configuration.
//
// Gets a network connectivity configuration.
func (a *NetworkConnectivityAPI) GetNetworkConnectivityConfiguration(ctx context.Context, request GetNetworkConnectivityConfigurationRequest) (*NetworkConnectivityConfiguration, error) {
	return a.impl.GetNetworkConnectivityConfiguration(ctx, request)
}

// Get a network connectivity configuration.
//
// Gets a network connectivity configuration.
func (a *NetworkConnectivityAPI) GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error) {
	return a.impl.GetNetworkConnectivityConfiguration(ctx, GetNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Get a private endpoint rule.
//
// Gets the private endpoint rule.
func (a *NetworkConnectivityAPI) GetPrivateEndpointRule(ctx context.Context, request GetPrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.GetPrivateEndpointRule(ctx, request)
}

// Get a private endpoint rule.
//
// Gets the private endpoint rule.
func (a *NetworkConnectivityAPI) GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.GetPrivateEndpointRule(ctx, GetPrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// List network connectivity configurations.
//
// Gets an array of network connectivity configurations.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListNetworkConnectivityConfigurations(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) listing.Iterator[NetworkConnectivityConfiguration] {

	getNextPage := func(ctx context.Context, req ListNetworkConnectivityConfigurationsRequest) (*ListNetworkConnectivityConfigurationsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.ListNetworkConnectivityConfigurations(ctx, req)
	}
	getItems := func(resp *ListNetworkConnectivityConfigurationsResponse) []NetworkConnectivityConfiguration {
		return resp.Items
	}
	getNextReq := func(resp *ListNetworkConnectivityConfigurationsResponse) *ListNetworkConnectivityConfigurationsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List network connectivity configurations.
//
// Gets an array of network connectivity configurations.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListNetworkConnectivityConfigurationsAll(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) ([]NetworkConnectivityConfiguration, error) {
	iterator := a.ListNetworkConnectivityConfigurations(ctx, request)
	return listing.ToSlice[NetworkConnectivityConfiguration](ctx, iterator)
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRules(ctx context.Context, request ListPrivateEndpointRulesRequest) listing.Iterator[NccAzurePrivateEndpointRule] {

	getNextPage := func(ctx context.Context, req ListPrivateEndpointRulesRequest) (*ListNccAzurePrivateEndpointRulesResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.ListPrivateEndpointRules(ctx, req)
	}
	getItems := func(resp *ListNccAzurePrivateEndpointRulesResponse) []NccAzurePrivateEndpointRule {
		return resp.Items
	}
	getNextReq := func(resp *ListNccAzurePrivateEndpointRulesResponse) *ListPrivateEndpointRulesRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRulesAll(ctx context.Context, request ListPrivateEndpointRulesRequest) ([]NccAzurePrivateEndpointRule, error) {
	iterator := a.ListPrivateEndpointRules(ctx, request)
	return listing.ToSlice[NccAzurePrivateEndpointRule](ctx, iterator)
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error) {
	return a.impl.ListPrivateEndpointRules(ctx, ListPrivateEndpointRulesRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

type PersonalComputeInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockPersonalComputeInterface instead.
	WithImpl(impl PersonalComputeService) PersonalComputeInterface

	// Impl returns low-level PersonalCompute API implementation
	// Deprecated: use MockPersonalComputeInterface instead.
	Impl() PersonalComputeService

	// Delete Personal Compute setting.
	//
	// Reverts back the Personal Compute setting value to default (ON)
	Delete(ctx context.Context, request DeletePersonalComputeSettingRequest) (*DeletePersonalComputeSettingResponse, error)

	// Get Personal Compute setting.
	//
	// Gets the value of the Personal Compute setting.
	Get(ctx context.Context, request GetPersonalComputeSettingRequest) (*PersonalComputeSetting, error)

	// Update Personal Compute setting.
	//
	// Updates the value of the Personal Compute setting.
	Update(ctx context.Context, request UpdatePersonalComputeSettingRequest) (*PersonalComputeSetting, error)
}

func NewPersonalCompute(client *client.DatabricksClient) *PersonalComputeAPI {
	return &PersonalComputeAPI{
		impl: &personalComputeImpl{
			client: client,
		},
	}
}

// The Personal Compute enablement setting lets you control which users can use
// the Personal Compute default policy to create compute resources. By default
// all users in all workspaces have access (ON), but you can change the setting
// to instead let individual workspaces configure access control (DELEGATE).
//
// There is only one instance of this setting per account. Since this setting
// has a default value, this setting is present on all accounts even though it's
// never set on a given account. Deletion reverts the value of the setting back
// to the default value.
type PersonalComputeAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(PersonalComputeService)
	impl PersonalComputeService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockPersonalComputeInterface instead.
func (a *PersonalComputeAPI) WithImpl(impl PersonalComputeService) PersonalComputeInterface {
	a.impl = impl
	return a
}

// Impl returns low-level PersonalCompute API implementation
// Deprecated: use MockPersonalComputeInterface instead.
func (a *PersonalComputeAPI) Impl() PersonalComputeService {
	return a.impl
}

// Delete Personal Compute setting.
//
// Reverts back the Personal Compute setting value to default (ON)
func (a *PersonalComputeAPI) Delete(ctx context.Context, request DeletePersonalComputeSettingRequest) (*DeletePersonalComputeSettingResponse, error) {
	return a.impl.Delete(ctx, request)
}

// Get Personal Compute setting.
//
// Gets the value of the Personal Compute setting.
func (a *PersonalComputeAPI) Get(ctx context.Context, request GetPersonalComputeSettingRequest) (*PersonalComputeSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update Personal Compute setting.
//
// Updates the value of the Personal Compute setting.
func (a *PersonalComputeAPI) Update(ctx context.Context, request UpdatePersonalComputeSettingRequest) (*PersonalComputeSetting, error) {
	return a.impl.Update(ctx, request)
}

type RestrictWorkspaceAdminsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockRestrictWorkspaceAdminsInterface instead.
	WithImpl(impl RestrictWorkspaceAdminsService) RestrictWorkspaceAdminsInterface

	// Impl returns low-level RestrictWorkspaceAdmins API implementation
	// Deprecated: use MockRestrictWorkspaceAdminsInterface instead.
	Impl() RestrictWorkspaceAdminsService

	// Delete the restrict workspace admins setting.
	//
	// Reverts the restrict workspace admins setting status for the workspace. A
	// fresh etag needs to be provided in `DELETE` requests (as a query parameter).
	// The etag can be retrieved by making a `GET` request before the DELETE
	// request. If the setting is updated/deleted concurrently, `DELETE` fails with
	// 409 and the request must be retried by using the fresh etag in the 409
	// response.
	Delete(ctx context.Context, request DeleteRestrictWorkspaceAdminsSettingRequest) (*DeleteRestrictWorkspaceAdminsSettingResponse, error)

	// Get the restrict workspace admins setting.
	//
	// Gets the restrict workspace admins setting.
	Get(ctx context.Context, request GetRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)

	// Update the restrict workspace admins setting.
	//
	// Updates the restrict workspace admins setting for the workspace. A fresh etag
	// needs to be provided in `PATCH` requests (as part of the setting field). The
	// etag can be retrieved by making a GET request before the `PATCH` request. If
	// the setting is updated concurrently, `PATCH` fails with 409 and the request
	// must be retried by using the fresh etag in the 409 response.
	Update(ctx context.Context, request UpdateRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)
}

func NewRestrictWorkspaceAdmins(client *client.DatabricksClient) *RestrictWorkspaceAdminsAPI {
	return &RestrictWorkspaceAdminsAPI{
		impl: &restrictWorkspaceAdminsImpl{
			client: client,
		},
	}
}

// The Restrict Workspace Admins setting lets you control the capabilities of
// workspace admins. With the setting status set to ALLOW_ALL, workspace admins
// can create service principal personal access tokens on behalf of any service
// principal in their workspace. Workspace admins can also change a job owner to
// any user in their workspace. And they can change the job run_as setting to
// any user in their workspace or to a service principal on which they have the
// Service Principal User role. With the setting status set to
// RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins can only create personal
// access tokens on behalf of service principals they have the Service Principal
// User role on. They can also only change a job owner to themselves. And they
// can change the job run_as setting to themselves or to a service principal on
// which they have the Service Principal User role.
type RestrictWorkspaceAdminsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(RestrictWorkspaceAdminsService)
	impl RestrictWorkspaceAdminsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockRestrictWorkspaceAdminsInterface instead.
func (a *RestrictWorkspaceAdminsAPI) WithImpl(impl RestrictWorkspaceAdminsService) RestrictWorkspaceAdminsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level RestrictWorkspaceAdmins API implementation
// Deprecated: use MockRestrictWorkspaceAdminsInterface instead.
func (a *RestrictWorkspaceAdminsAPI) Impl() RestrictWorkspaceAdminsService {
	return a.impl
}

// Delete the restrict workspace admins setting.
//
// Reverts the restrict workspace admins setting status for the workspace. A
// fresh etag needs to be provided in `DELETE` requests (as a query parameter).
// The etag can be retrieved by making a `GET` request before the DELETE
// request. If the setting is updated/deleted concurrently, `DELETE` fails with
// 409 and the request must be retried by using the fresh etag in the 409
// response.
func (a *RestrictWorkspaceAdminsAPI) Delete(ctx context.Context, request DeleteRestrictWorkspaceAdminsSettingRequest) (*DeleteRestrictWorkspaceAdminsSettingResponse, error) {
	return a.impl.Delete(ctx, request)
}

// Get the restrict workspace admins setting.
//
// Gets the restrict workspace admins setting.
func (a *RestrictWorkspaceAdminsAPI) Get(ctx context.Context, request GetRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error) {
	return a.impl.Get(ctx, request)
}

// Update the restrict workspace admins setting.
//
// Updates the restrict workspace admins setting for the workspace. A fresh etag
// needs to be provided in `PATCH` requests (as part of the setting field). The
// etag can be retrieved by making a GET request before the `PATCH` request. If
// the setting is updated concurrently, `PATCH` fails with 409 and the request
// must be retried by using the fresh etag in the 409 response.
func (a *RestrictWorkspaceAdminsAPI) Update(ctx context.Context, request UpdateRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error) {
	return a.impl.Update(ctx, request)
}

type SettingsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockSettingsInterface instead.
	WithImpl(impl SettingsService) SettingsInterface

	// Impl returns low-level Settings API implementation
	// Deprecated: use MockSettingsInterface instead.
	Impl() SettingsService

	// Controls whether automatic cluster update is enabled for the current
	// workspace. By default, it is turned off.
	AutomaticClusterUpdate() AutomaticClusterUpdateInterface

	// Controls whether to enable the compliance security profile for the
	// current workspace. Enabling it on a workspace is permanent. By default,
	// it is turned off.
	//
	// This settings can NOT be disabled once it is enabled.
	CspEnablement() CspEnablementInterface

	// The default namespace setting API allows users to configure the default
	// namespace for a Databricks workspace.
	//
	// Through this API, users can retrieve, set, or modify the default
	// namespace used when queries do not reference a fully qualified
	// three-level name. For example, if you use the API to set 'retail_prod' as
	// the default catalog, then a query 'SELECT * FROM myTable' would reference
	// the object 'retail_prod.default.myTable' (the schema 'default' is always
	// assumed).
	//
	// This setting requires a restart of clusters and SQL warehouses to take
	// effect. Additionally, the default namespace only applies when using Unity
	// Catalog-enabled compute.
	DefaultNamespace() DefaultNamespaceInterface

	// Controls whether enhanced security monitoring is enabled for the current
	// workspace. If the compliance security profile is enabled, this is
	// automatically enabled. By default, it is disabled. However, if the
	// compliance security profile is enabled, this is automatically enabled.
	//
	// If the compliance security profile is disabled, you can enable or disable
	// this setting and it is not permanent.
	EsmEnablement() EsmEnablementInterface

	// The Restrict Workspace Admins setting lets you control the capabilities
	// of workspace admins. With the setting status set to ALLOW_ALL, workspace
	// admins can create service principal personal access tokens on behalf of
	// any service principal in their workspace. Workspace admins can also
	// change a job owner to any user in their workspace. And they can change
	// the job run_as setting to any user in their workspace or to a service
	// principal on which they have the Service Principal User role. With the
	// setting status set to RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins
	// can only create personal access tokens on behalf of service principals
	// they have the Service Principal User role on. They can also only change a
	// job owner to themselves. And they can change the job run_as setting to
	// themselves or to a service principal on which they have the Service
	// Principal User role.
	RestrictWorkspaceAdmins() RestrictWorkspaceAdminsInterface
}

func NewSettings(client *client.DatabricksClient) *SettingsAPI {
	return &SettingsAPI{
		impl: &settingsImpl{
			client: client,
		},

		automaticClusterUpdate: NewAutomaticClusterUpdate(client),

		cspEnablement: NewCspEnablement(client),

		defaultNamespace: NewDefaultNamespace(client),

		esmEnablement: NewEsmEnablement(client),

		restrictWorkspaceAdmins: NewRestrictWorkspaceAdmins(client),
	}
}

// Workspace Settings API allows users to manage settings at the workspace
// level.
type SettingsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(SettingsService)
	impl SettingsService

	// Controls whether automatic cluster update is enabled for the current
	// workspace. By default, it is turned off.
	automaticClusterUpdate AutomaticClusterUpdateInterface

	// Controls whether to enable the compliance security profile for the
	// current workspace. Enabling it on a workspace is permanent. By default,
	// it is turned off.
	//
	// This settings can NOT be disabled once it is enabled.
	cspEnablement CspEnablementInterface

	// The default namespace setting API allows users to configure the default
	// namespace for a Databricks workspace.
	//
	// Through this API, users can retrieve, set, or modify the default
	// namespace used when queries do not reference a fully qualified
	// three-level name. For example, if you use the API to set 'retail_prod' as
	// the default catalog, then a query 'SELECT * FROM myTable' would reference
	// the object 'retail_prod.default.myTable' (the schema 'default' is always
	// assumed).
	//
	// This setting requires a restart of clusters and SQL warehouses to take
	// effect. Additionally, the default namespace only applies when using Unity
	// Catalog-enabled compute.
	defaultNamespace DefaultNamespaceInterface

	// Controls whether enhanced security monitoring is enabled for the current
	// workspace. If the compliance security profile is enabled, this is
	// automatically enabled. By default, it is disabled. However, if the
	// compliance security profile is enabled, this is automatically enabled.
	//
	// If the compliance security profile is disabled, you can enable or disable
	// this setting and it is not permanent.
	esmEnablement EsmEnablementInterface

	// The Restrict Workspace Admins setting lets you control the capabilities
	// of workspace admins. With the setting status set to ALLOW_ALL, workspace
	// admins can create service principal personal access tokens on behalf of
	// any service principal in their workspace. Workspace admins can also
	// change a job owner to any user in their workspace. And they can change
	// the job run_as setting to any user in their workspace or to a service
	// principal on which they have the Service Principal User role. With the
	// setting status set to RESTRICT_TOKENS_AND_JOB_RUN_AS, workspace admins
	// can only create personal access tokens on behalf of service principals
	// they have the Service Principal User role on. They can also only change a
	// job owner to themselves. And they can change the job run_as setting to
	// themselves or to a service principal on which they have the Service
	// Principal User role.
	restrictWorkspaceAdmins RestrictWorkspaceAdminsInterface
}

func (a *SettingsAPI) AutomaticClusterUpdate() AutomaticClusterUpdateInterface {
	return a.automaticClusterUpdate
}

func (a *SettingsAPI) CspEnablement() CspEnablementInterface {
	return a.cspEnablement
}

func (a *SettingsAPI) DefaultNamespace() DefaultNamespaceInterface {
	return a.defaultNamespace
}

func (a *SettingsAPI) EsmEnablement() EsmEnablementInterface {
	return a.esmEnablement
}

func (a *SettingsAPI) RestrictWorkspaceAdmins() RestrictWorkspaceAdminsInterface {
	return a.restrictWorkspaceAdmins
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockSettingsInterface instead.
func (a *SettingsAPI) WithImpl(impl SettingsService) SettingsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Settings API implementation
// Deprecated: use MockSettingsInterface instead.
func (a *SettingsAPI) Impl() SettingsService {
	return a.impl
}

type TokenManagementInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockTokenManagementInterface instead.
	WithImpl(impl TokenManagementService) TokenManagementInterface

	// Impl returns low-level TokenManagement API implementation
	// Deprecated: use MockTokenManagementInterface instead.
	Impl() TokenManagementService

	// Create on-behalf token.
	//
	// Creates a token on behalf of a service principal.
	CreateOboToken(ctx context.Context, request CreateOboTokenRequest) (*CreateOboTokenResponse, error)

	// Delete a token.
	//
	// Deletes a token, specified by its ID.
	Delete(ctx context.Context, request DeleteTokenManagementRequest) error

	// Delete a token.
	//
	// Deletes a token, specified by its ID.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// Get token info.
	//
	// Gets information about a token, specified by its ID.
	Get(ctx context.Context, request GetTokenManagementRequest) (*GetTokenResponse, error)

	// Get token info.
	//
	// Gets information about a token, specified by its ID.
	GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error)

	// Get token permission levels.
	//
	// Gets the permission levels that a user can have on an object.
	GetPermissionLevels(ctx context.Context) (*GetTokenPermissionLevelsResponse, error)

	// Get token permissions.
	//
	// Gets the permissions of all tokens. Tokens can inherit permissions from their
	// root object.
	GetPermissions(ctx context.Context) (*TokenPermissions, error)

	// List all tokens.
	//
	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListTokenManagementRequest) listing.Iterator[TokenInfo]

	// List all tokens.
	//
	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListTokenManagementRequest) ([]TokenInfo, error)

	// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error)

	// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*TokenInfo, error)

	// Set token permissions.
	//
	// Sets permissions on all tokens. Tokens can inherit permissions from their
	// root object.
	SetPermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)

	// Update token permissions.
	//
	// Updates the permissions on all tokens. Tokens can inherit permissions from
	// their root object.
	UpdatePermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)
}

func NewTokenManagement(client *client.DatabricksClient) *TokenManagementAPI {
	return &TokenManagementAPI{
		impl: &tokenManagementImpl{
			client: client,
		},
	}
}

// Enables administrators to get all tokens and delete tokens for other users.
// Admins can either get every token, get a specific token by ID, or get all
// tokens for a particular user.
type TokenManagementAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(TokenManagementService)
	impl TokenManagementService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockTokenManagementInterface instead.
func (a *TokenManagementAPI) WithImpl(impl TokenManagementService) TokenManagementInterface {
	a.impl = impl
	return a
}

// Impl returns low-level TokenManagement API implementation
// Deprecated: use MockTokenManagementInterface instead.
func (a *TokenManagementAPI) Impl() TokenManagementService {
	return a.impl
}

// Create on-behalf token.
//
// Creates a token on behalf of a service principal.
func (a *TokenManagementAPI) CreateOboToken(ctx context.Context, request CreateOboTokenRequest) (*CreateOboTokenResponse, error) {
	return a.impl.CreateOboToken(ctx, request)
}

// Delete a token.
//
// Deletes a token, specified by its ID.
func (a *TokenManagementAPI) Delete(ctx context.Context, request DeleteTokenManagementRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a token.
//
// Deletes a token, specified by its ID.
func (a *TokenManagementAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.impl.Delete(ctx, DeleteTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Get token info.
//
// Gets information about a token, specified by its ID.
func (a *TokenManagementAPI) Get(ctx context.Context, request GetTokenManagementRequest) (*GetTokenResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get token info.
//
// Gets information about a token, specified by its ID.
func (a *TokenManagementAPI) GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error) {
	return a.impl.Get(ctx, GetTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Get token permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *TokenManagementAPI) GetPermissionLevels(ctx context.Context) (*GetTokenPermissionLevelsResponse, error) {
	return a.impl.GetPermissionLevels(ctx)
}

// Get token permissions.
//
// Gets the permissions of all tokens. Tokens can inherit permissions from their
// root object.
func (a *TokenManagementAPI) GetPermissions(ctx context.Context) (*TokenPermissions, error) {
	return a.impl.GetPermissions(ctx)
}

// List all tokens.
//
// Lists all tokens associated with the specified workspace or user.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) List(ctx context.Context, request ListTokenManagementRequest) listing.Iterator[TokenInfo] {

	getNextPage := func(ctx context.Context, req ListTokenManagementRequest) (*ListTokensResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListTokensResponse) []TokenInfo {
		return resp.TokenInfos
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List all tokens.
//
// Lists all tokens associated with the specified workspace or user.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) ListAll(ctx context.Context, request ListTokenManagementRequest) ([]TokenInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSlice[TokenInfo](ctx, iterator)
}

// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) GetByComment(ctx context.Context, name string) (*TokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTokenManagementRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Set token permissions.
//
// Sets permissions on all tokens. Tokens can inherit permissions from their
// root object.
func (a *TokenManagementAPI) SetPermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error) {
	return a.impl.SetPermissions(ctx, request)
}

// Update token permissions.
//
// Updates the permissions on all tokens. Tokens can inherit permissions from
// their root object.
func (a *TokenManagementAPI) UpdatePermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error) {
	return a.impl.UpdatePermissions(ctx, request)
}

type TokensInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockTokensInterface instead.
	WithImpl(impl TokensService) TokensInterface

	// Impl returns low-level Tokens API implementation
	// Deprecated: use MockTokensInterface instead.
	Impl() TokensService

	// Create a user token.
	//
	// Creates and returns a token for a user. If this call is made through token
	// authentication, it creates a token with the same client ID as the
	// authenticated token. If the user's token quota is exceeded, this call returns
	// an error **QUOTA_EXCEEDED**.
	Create(ctx context.Context, request CreateTokenRequest) (*CreateTokenResponse, error)

	// Revoke token.
	//
	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	Delete(ctx context.Context, request RevokeTokenRequest) error

	// Revoke token.
	//
	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// List tokens.
	//
	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[PublicTokenInfo]

	// List tokens.
	//
	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]PublicTokenInfo, error)

	// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error)

	// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error)
}

func NewTokens(client *client.DatabricksClient) *TokensAPI {
	return &TokensAPI{
		impl: &tokensImpl{
			client: client,
		},
	}
}

// The Token API allows you to create, list, and revoke tokens that can be used
// to authenticate and access Databricks REST APIs.
type TokensAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(TokensService)
	impl TokensService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockTokensInterface instead.
func (a *TokensAPI) WithImpl(impl TokensService) TokensInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Tokens API implementation
// Deprecated: use MockTokensInterface instead.
func (a *TokensAPI) Impl() TokensService {
	return a.impl
}

// Create a user token.
//
// Creates and returns a token for a user. If this call is made through token
// authentication, it creates a token with the same client ID as the
// authenticated token. If the user's token quota is exceeded, this call returns
// an error **QUOTA_EXCEEDED**.
func (a *TokensAPI) Create(ctx context.Context, request CreateTokenRequest) (*CreateTokenResponse, error) {
	return a.impl.Create(ctx, request)
}

// Revoke token.
//
// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *TokensAPI) Delete(ctx context.Context, request RevokeTokenRequest) error {
	return a.impl.Delete(ctx, request)
}

// Revoke token.
//
// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *TokensAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.impl.Delete(ctx, RevokeTokenRequest{
		TokenId: tokenId,
	})
}

// List tokens.
//
// Lists all the valid tokens for a user-workspace pair.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) List(ctx context.Context) listing.Iterator[PublicTokenInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListPublicTokensResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListPublicTokensResponse) []PublicTokenInfo {
		return resp.TokenInfos
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List tokens.
//
// Lists all the valid tokens for a user-workspace pair.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) ListAll(ctx context.Context) ([]PublicTokenInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[PublicTokenInfo](ctx, iterator)
}

// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PublicTokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PublicTokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PublicTokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type WorkspaceConfInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockWorkspaceConfInterface instead.
	WithImpl(impl WorkspaceConfService) WorkspaceConfInterface

	// Impl returns low-level WorkspaceConf API implementation
	// Deprecated: use MockWorkspaceConfInterface instead.
	Impl() WorkspaceConfService

	// Check configuration status.
	//
	// Gets the configuration status for a workspace.
	GetStatus(ctx context.Context, request GetStatusRequest) (*map[string]string, error)

	// Enable/disable features.
	//
	// Sets the configuration status for a workspace, including enabling or
	// disabling it.
	SetStatus(ctx context.Context, request WorkspaceConf) error
}

func NewWorkspaceConf(client *client.DatabricksClient) *WorkspaceConfAPI {
	return &WorkspaceConfAPI{
		impl: &workspaceConfImpl{
			client: client,
		},
	}
}

// This API allows updating known workspace settings for advanced users.
type WorkspaceConfAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(WorkspaceConfService)
	impl WorkspaceConfService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockWorkspaceConfInterface instead.
func (a *WorkspaceConfAPI) WithImpl(impl WorkspaceConfService) WorkspaceConfInterface {
	a.impl = impl
	return a
}

// Impl returns low-level WorkspaceConf API implementation
// Deprecated: use MockWorkspaceConfInterface instead.
func (a *WorkspaceConfAPI) Impl() WorkspaceConfService {
	return a.impl
}

// Check configuration status.
//
// Gets the configuration status for a workspace.
func (a *WorkspaceConfAPI) GetStatus(ctx context.Context, request GetStatusRequest) (*map[string]string, error) {
	return a.impl.GetStatus(ctx, request)
}

// Enable/disable features.
//
// Sets the configuration status for a workspace, including enabling or
// disabling it.
func (a *WorkspaceConfAPI) SetStatus(ctx context.Context, request WorkspaceConf) error {
	return a.impl.SetStatus(ctx, request)
}
