// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Ip Access Lists, Account Settings, Credentials Manager, Ip Access Lists, Network Connectivity, Settings, Token Management, Tokens, Workspace Conf, etc.
package settings

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AccountIpAccessListsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAccountIpAccessListsInterface instead.
	WithImpl(impl AccountIpAccessListsService) AccountIpAccessListsInterface

	// Impl returns low-level AccountIpAccessLists API implementation
	// Deprecated: use MockAccountIpAccessListsInterface instead.
	Impl() AccountIpAccessListsService

	// Create access list.
	//
	// Creates an IP access list for the account.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteAccountIpAccessListRequest) error

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Get IP access list.
	//
	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetAccountIpAccessListRequest) (*GetIpAccessListResponse, error)

	// Get IP access list.
	//
	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error)

	// Get access lists.
	//
	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Get access lists.
	//
	// Gets all IP access lists for the specified account.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replace access list.
	//
	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Update access list.
	//
	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewAccountIpAccessLists(client *client.DatabricksClient) *AccountIpAccessListsAPI {
	return &AccountIpAccessListsAPI{
		impl: &accountIpAccessListsImpl{
			client: client,
		},
	}
}

// The Accounts IP Access List API enables account admins to configure IP access
// lists for access to the account console.
//
// Account IP Access Lists affect web application access and REST API access to
// the account console and account APIs. If the feature is disabled for the
// account, all access is allowed for this account. There is support for allow
// lists (inclusion) and block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the account, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the account, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the account supports a maximum
// of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the account-level IP access lists, it can take a few minutes
// for changes to take effect.
type AccountIpAccessListsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AccountIpAccessListsService)
	impl AccountIpAccessListsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAccountIpAccessListsInterface instead.
func (a *AccountIpAccessListsAPI) WithImpl(impl AccountIpAccessListsService) AccountIpAccessListsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AccountIpAccessLists API implementation
// Deprecated: use MockAccountIpAccessListsInterface instead.
func (a *AccountIpAccessListsAPI) Impl() AccountIpAccessListsService {
	return a.impl
}

// Create access list.
//
// Creates an IP access list for the account.
//
// A list can be an allow list or a block list. See the top of this file for a
// description of how the server treats allow lists and block lists at runtime.
//
// When creating or updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the new list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect.
func (a *AccountIpAccessListsAPI) Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error) {
	return a.impl.Create(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) Delete(ctx context.Context, request DeleteAccountIpAccessListRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.impl.Delete(ctx, DeleteAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get IP access list.
//
// Gets an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) Get(ctx context.Context, request GetAccountIpAccessListRequest) (*GetIpAccessListResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get IP access list.
//
// Gets an IP access list, specified by its list ID.
func (a *AccountIpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*GetIpAccessListResponse, error) {
	return a.impl.Get(ctx, GetAccountIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access lists.
//
// Gets all IP access lists for the specified account.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) List(ctx context.Context) listing.Iterator[IpAccessListInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*GetIpAccessListsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *GetIpAccessListsResponse) []IpAccessListInfo {
		return resp.IpAccessLists
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// Get access lists.
//
// Gets all IP access lists for the specified account.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) ListAll(ctx context.Context) ([]IpAccessListInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[IpAccessListInfo](ctx, iterator)
}

// IpAccessListInfoLabelToListIdMap calls [AccountIpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [AccountIpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountIpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Replace access list.
//
// Replaces an IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time. When replacing an IP access list: * For all allow lists and block lists
// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
// counts as a single value. Attempts to exceed that number return error 400
// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
// the calling user's current IP, error 400 is returned with `error_code` value
// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
func (a *AccountIpAccessListsAPI) Replace(ctx context.Context, request ReplaceIpAccessList) error {
	return a.impl.Replace(ctx, request)
}

// Update access list.
//
// Updates an existing IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time.
//
// When updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the updated list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect.
func (a *AccountIpAccessListsAPI) Update(ctx context.Context, request UpdateIpAccessList) error {
	return a.impl.Update(ctx, request)
}

type AccountSettingsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAccountSettingsInterface instead.
	WithImpl(impl AccountSettingsService) AccountSettingsInterface

	// Impl returns low-level AccountSettings API implementation
	// Deprecated: use MockAccountSettingsInterface instead.
	Impl() AccountSettingsService

	// Delete Personal Compute setting.
	//
	// Reverts back the Personal Compute setting value to default (ON)
	DeletePersonalComputeSetting(ctx context.Context, request DeletePersonalComputeSettingRequest) (*DeletePersonalComputeSettingResponse, error)

	// Get Personal Compute setting.
	//
	// Gets the value of the Personal Compute setting.
	GetPersonalComputeSetting(ctx context.Context, request GetPersonalComputeSettingRequest) (*PersonalComputeSetting, error)

	// Update Personal Compute setting.
	//
	// Updates the value of the Personal Compute setting.
	UpdatePersonalComputeSetting(ctx context.Context, request UpdatePersonalComputeSettingRequest) (*PersonalComputeSetting, error)
}

func NewAccountSettings(client *client.DatabricksClient) *AccountSettingsAPI {
	return &AccountSettingsAPI{
		impl: &accountSettingsImpl{
			client: client,
		},
	}
}

// The Personal Compute enablement setting lets you control which users can use
// the Personal Compute default policy to create compute resources. By default
// all users in all workspaces have access (ON), but you can change the setting
// to instead let individual workspaces configure access control (DELEGATE).
//
// There is only one instance of this setting per account. Since this setting
// has a default value, this setting is present on all accounts even though it's
// never set on a given account. Deletion reverts the value of the setting back
// to the default value.
type AccountSettingsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AccountSettingsService)
	impl AccountSettingsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAccountSettingsInterface instead.
func (a *AccountSettingsAPI) WithImpl(impl AccountSettingsService) AccountSettingsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AccountSettings API implementation
// Deprecated: use MockAccountSettingsInterface instead.
func (a *AccountSettingsAPI) Impl() AccountSettingsService {
	return a.impl
}

// Delete Personal Compute setting.
//
// Reverts back the Personal Compute setting value to default (ON)
func (a *AccountSettingsAPI) DeletePersonalComputeSetting(ctx context.Context, request DeletePersonalComputeSettingRequest) (*DeletePersonalComputeSettingResponse, error) {
	return a.impl.DeletePersonalComputeSetting(ctx, request)
}

// Get Personal Compute setting.
//
// Gets the value of the Personal Compute setting.
func (a *AccountSettingsAPI) GetPersonalComputeSetting(ctx context.Context, request GetPersonalComputeSettingRequest) (*PersonalComputeSetting, error) {
	return a.impl.GetPersonalComputeSetting(ctx, request)
}

// Update Personal Compute setting.
//
// Updates the value of the Personal Compute setting.
func (a *AccountSettingsAPI) UpdatePersonalComputeSetting(ctx context.Context, request UpdatePersonalComputeSettingRequest) (*PersonalComputeSetting, error) {
	return a.impl.UpdatePersonalComputeSetting(ctx, request)
}

type CredentialsManagerInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockCredentialsManagerInterface instead.
	WithImpl(impl CredentialsManagerService) CredentialsManagerInterface

	// Impl returns low-level CredentialsManager API implementation
	// Deprecated: use MockCredentialsManagerInterface instead.
	Impl() CredentialsManagerService

	// Exchange token.
	//
	// Exchange tokens with an Identity Provider to get a new access token. It
	// allows specifying scopes to determine token permissions.
	ExchangeToken(ctx context.Context, request ExchangeTokenRequest) (*ExchangeTokenResponse, error)
}

func NewCredentialsManager(client *client.DatabricksClient) *CredentialsManagerAPI {
	return &CredentialsManagerAPI{
		impl: &credentialsManagerImpl{
			client: client,
		},
	}
}

// Credentials manager interacts with with Identity Providers to to perform
// token exchanges using stored credentials and refresh tokens.
type CredentialsManagerAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(CredentialsManagerService)
	impl CredentialsManagerService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockCredentialsManagerInterface instead.
func (a *CredentialsManagerAPI) WithImpl(impl CredentialsManagerService) CredentialsManagerInterface {
	a.impl = impl
	return a
}

// Impl returns low-level CredentialsManager API implementation
// Deprecated: use MockCredentialsManagerInterface instead.
func (a *CredentialsManagerAPI) Impl() CredentialsManagerService {
	return a.impl
}

// Exchange token.
//
// Exchange tokens with an Identity Provider to get a new access token. It
// allows specifying scopes to determine token permissions.
func (a *CredentialsManagerAPI) ExchangeToken(ctx context.Context, request ExchangeTokenRequest) (*ExchangeTokenResponse, error) {
	return a.impl.ExchangeToken(ctx, request)
}

type IpAccessListsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockIpAccessListsInterface instead.
	WithImpl(impl IpAccessListsService) IpAccessListsInterface

	// Impl returns low-level IpAccessLists API implementation
	// Deprecated: use MockIpAccessListsInterface instead.
	Impl() IpAccessListsService

	// Create access list.
	//
	// Creates an IP access list for this workspace.
	//
	// A list can be an allow list or a block list. See the top of this file for a
	// description of how the server treats allow lists and block lists at runtime.
	//
	// When creating or updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the new list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. **Note**: Your new
	// IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus
	Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error)

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	Delete(ctx context.Context, request DeleteIpAccessListRequest) error

	// Delete access list.
	//
	// Deletes an IP access list, specified by its list ID.
	DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error

	// Get access list.
	//
	// Gets an IP access list, specified by its list ID.
	Get(ctx context.Context, request GetIpAccessListRequest) (*FetchIpAccessListResponse, error)

	// Get access list.
	//
	// Gets an IP access list, specified by its list ID.
	GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error)

	// Get access lists.
	//
	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[IpAccessListInfo]

	// Get access lists.
	//
	// Gets all IP access lists for the specified workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]IpAccessListInfo, error)

	// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error)

	// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
	//
	// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
	//
	// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error)

	// Replace access list.
	//
	// Replaces an IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time. When replacing an IP access list: * For all allow lists and block lists
	// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
	// counts as a single value. Attempts to exceed that number return error 400
	// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
	// the calling user's current IP, error 400 is returned with `error_code` value
	// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
	// Note that your resulting IP access list has no effect until you enable the
	// feature. See :method:workspaceconf/setStatus.
	Replace(ctx context.Context, request ReplaceIpAccessList) error

	// Update access list.
	//
	// Updates an existing IP access list, specified by its ID.
	//
	// A list can include allow lists and block lists. See the top of this file for
	// a description of how the server treats allow lists and block lists at run
	// time.
	//
	// When updating an IP access list:
	//
	// * For all allow lists and block lists combined, the API supports a maximum of
	// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
	// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
	// * If the updated list would block the calling user's current IP, error 400 is
	// returned with `error_code` value `INVALID_STATE`.
	//
	// It can take a few minutes for the changes to take effect. Note that your
	// resulting IP access list has no effect until you enable the feature. See
	// :method:workspaceconf/setStatus.
	Update(ctx context.Context, request UpdateIpAccessList) error
}

func NewIpAccessLists(client *client.DatabricksClient) *IpAccessListsAPI {
	return &IpAccessListsAPI{
		impl: &ipAccessListsImpl{
			client: client,
		},
	}
}

// IP Access List enables admins to configure IP access lists.
//
// IP access lists affect web application access and REST API access to this
// workspace only. If the feature is disabled for a workspace, all access is
// allowed for this workspace. There is support for allow lists (inclusion) and
// block lists (exclusion).
//
// When a connection is attempted: 1. **First, all block lists are checked.** If
// the connection IP address matches any block list, the connection is rejected.
// 2. **If the connection was not rejected by block lists**, the IP address is
// compared with the allow lists.
//
// If there is at least one allow list for the workspace, the connection is
// allowed only if the IP address matches an allow list. If there are no allow
// lists for the workspace, all IP addresses are allowed.
//
// For all allow lists and block lists combined, the workspace supports a
// maximum of 1000 IP/CIDR values, where one CIDR counts as a single value.
//
// After changes to the IP access list feature, it can take a few minutes for
// changes to take effect.
type IpAccessListsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(IpAccessListsService)
	impl IpAccessListsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockIpAccessListsInterface instead.
func (a *IpAccessListsAPI) WithImpl(impl IpAccessListsService) IpAccessListsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level IpAccessLists API implementation
// Deprecated: use MockIpAccessListsInterface instead.
func (a *IpAccessListsAPI) Impl() IpAccessListsService {
	return a.impl
}

// Create access list.
//
// Creates an IP access list for this workspace.
//
// A list can be an allow list or a block list. See the top of this file for a
// description of how the server treats allow lists and block lists at runtime.
//
// When creating or updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the new list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect. **Note**: Your new
// IP access list has no effect until you enable the feature. See
// :method:workspaceconf/setStatus
func (a *IpAccessListsAPI) Create(ctx context.Context, request CreateIpAccessList) (*CreateIpAccessListResponse, error) {
	return a.impl.Create(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) Delete(ctx context.Context, request DeleteIpAccessListRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete access list.
//
// Deletes an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) DeleteByIpAccessListId(ctx context.Context, ipAccessListId string) error {
	return a.impl.Delete(ctx, DeleteIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access list.
//
// Gets an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) Get(ctx context.Context, request GetIpAccessListRequest) (*FetchIpAccessListResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get access list.
//
// Gets an IP access list, specified by its list ID.
func (a *IpAccessListsAPI) GetByIpAccessListId(ctx context.Context, ipAccessListId string) (*FetchIpAccessListResponse, error) {
	return a.impl.Get(ctx, GetIpAccessListRequest{
		IpAccessListId: ipAccessListId,
	})
}

// Get access lists.
//
// Gets all IP access lists for the specified workspace.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) List(ctx context.Context) listing.Iterator[IpAccessListInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListIpAccessListResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListIpAccessListResponse) []IpAccessListInfo {
		return resp.IpAccessLists
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// Get access lists.
//
// Gets all IP access lists for the specified workspace.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) ListAll(ctx context.Context) ([]IpAccessListInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[IpAccessListInfo](ctx, iterator)
}

// IpAccessListInfoLabelToListIdMap calls [IpAccessListsAPI.ListAll] and creates a map of results with [IpAccessListInfo].Label as key and [IpAccessListInfo].ListId as value.
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) IpAccessListInfoLabelToListIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Label
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Label: %s", key)
		}
		mapping[key] = v.ListId
	}
	return mapping, nil
}

// GetByLabel calls [IpAccessListsAPI.IpAccessListInfoLabelToListIdMap] and returns a single [IpAccessListInfo].
//
// Returns an error if there's more than one [IpAccessListInfo] with the same .Label.
//
// Note: All [IpAccessListInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *IpAccessListsAPI) GetByLabel(ctx context.Context, name string) (*IpAccessListInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]IpAccessListInfo{}
	for _, v := range result {
		key := v.Label
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("IpAccessListInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of IpAccessListInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Replace access list.
//
// Replaces an IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time. When replacing an IP access list: * For all allow lists and block lists
// combined, the API supports a maximum of 1000 IP/CIDR values, where one CIDR
// counts as a single value. Attempts to exceed that number return error 400
// with `error_code` value `QUOTA_EXCEEDED`. * If the resulting list would block
// the calling user's current IP, error 400 is returned with `error_code` value
// `INVALID_STATE`. It can take a few minutes for the changes to take effect.
// Note that your resulting IP access list has no effect until you enable the
// feature. See :method:workspaceconf/setStatus.
func (a *IpAccessListsAPI) Replace(ctx context.Context, request ReplaceIpAccessList) error {
	return a.impl.Replace(ctx, request)
}

// Update access list.
//
// Updates an existing IP access list, specified by its ID.
//
// A list can include allow lists and block lists. See the top of this file for
// a description of how the server treats allow lists and block lists at run
// time.
//
// When updating an IP access list:
//
// * For all allow lists and block lists combined, the API supports a maximum of
// 1000 IP/CIDR values, where one CIDR counts as a single value. Attempts to
// exceed that number return error 400 with `error_code` value `QUOTA_EXCEEDED`.
// * If the updated list would block the calling user's current IP, error 400 is
// returned with `error_code` value `INVALID_STATE`.
//
// It can take a few minutes for the changes to take effect. Note that your
// resulting IP access list has no effect until you enable the feature. See
// :method:workspaceconf/setStatus.
func (a *IpAccessListsAPI) Update(ctx context.Context, request UpdateIpAccessList) error {
	return a.impl.Update(ctx, request)
}

type NetworkConnectivityInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockNetworkConnectivityInterface instead.
	WithImpl(impl NetworkConnectivityService) NetworkConnectivityInterface

	// Impl returns low-level NetworkConnectivity API implementation
	// Deprecated: use MockNetworkConnectivityInterface instead.
	Impl() NetworkConnectivityService

	// Create a network connectivity configuration.
	//
	// Creates a network connectivity configuration (NCC), which provides stable
	// Azure service subnets when accessing your Azure Storage accounts. You can
	// also use a network connectivity configuration to create Databricks-managed
	// private endpoints so that Databricks serverless compute resources privately
	// access your resources.
	//
	// **IMPORTANT**: After you create the network connectivity configuration, you
	// must assign one or more workspaces to the new network connectivity
	// configuration. You can share one network connectivity configuration with
	// multiple workspaces from the same Azure region within the same Databricks
	// account. See [configure serverless secure connectivity].
	//
	// [configure serverless secure connectivity]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security
	CreateNetworkConnectivityConfiguration(ctx context.Context, request CreateNetworkConnectivityConfigRequest) (*NetworkConnectivityConfiguration, error)

	// Create a private endpoint rule.
	//
	// Create a private endpoint rule for the specified network connectivity config
	// object. Once the object is created, Databricks asynchronously provisions a
	// new Azure private endpoint to your specified Azure resource.
	//
	// **IMPORTANT**: You must use Azure portal or other Azure tools to approve the
	// private endpoint to complete the connection. To get the information of the
	// private endpoint created, make a `GET` request on the new private endpoint
	// rule. See [serverless private link].
	//
	// [serverless private link]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security/serverless-private-link
	CreatePrivateEndpointRule(ctx context.Context, request CreatePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Delete a network connectivity configuration.
	//
	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfiguration(ctx context.Context, request DeleteNetworkConnectivityConfigurationRequest) error

	// Delete a network connectivity configuration.
	//
	// Deletes a network connectivity configuration.
	DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error

	// Delete a private endpoint rule.
	//
	// Initiates deleting a private endpoint rule. The private endpoint will be
	// deactivated and will be purged after seven days of deactivation. When a
	// private endpoint is in deactivated state, `deactivated` field is set to
	// `true` and the private endpoint is not available to your serverless compute
	// resources.
	DeletePrivateEndpointRule(ctx context.Context, request DeletePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Delete a private endpoint rule.
	//
	// Initiates deleting a private endpoint rule. The private endpoint will be
	// deactivated and will be purged after seven days of deactivation. When a
	// private endpoint is in deactivated state, `deactivated` field is set to
	// `true` and the private endpoint is not available to your serverless compute
	// resources.
	DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error)

	// Get a network connectivity configuration.
	//
	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfiguration(ctx context.Context, request GetNetworkConnectivityConfigurationRequest) (*NetworkConnectivityConfiguration, error)

	// Get a network connectivity configuration.
	//
	// Gets a network connectivity configuration.
	GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error)

	// Get a private endpoint rule.
	//
	// Gets the private endpoint rule.
	GetPrivateEndpointRule(ctx context.Context, request GetPrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error)

	// Get a private endpoint rule.
	//
	// Gets the private endpoint rule.
	GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error)

	// List network connectivity configurations.
	//
	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurations(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) listing.Iterator[NetworkConnectivityConfiguration]

	// List network connectivity configurations.
	//
	// Gets an array of network connectivity configurations.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListNetworkConnectivityConfigurationsAll(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) ([]NetworkConnectivityConfiguration, error)

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRules(ctx context.Context, request ListPrivateEndpointRulesRequest) listing.Iterator[NccAzurePrivateEndpointRule]

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPrivateEndpointRulesAll(ctx context.Context, request ListPrivateEndpointRulesRequest) ([]NccAzurePrivateEndpointRule, error)

	// List private endpoint rules.
	//
	// Gets an array of private endpoint rules.
	ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error)
}

func NewNetworkConnectivity(client *client.DatabricksClient) *NetworkConnectivityAPI {
	return &NetworkConnectivityAPI{
		impl: &networkConnectivityImpl{
			client: client,
		},
	}
}

// These APIs provide configurations for the network connectivity of your
// workspaces for serverless compute resources. This API provides stable subnets
// for your workspace so that you can configure your firewalls on your Azure
// Storage accounts to allow access from Databricks. You can also use the API to
// provision private endpoints for Databricks to privately connect serverless
// compute resources to your Azure resources using Azure Private Link. See
// [configure serverless secure connectivity].
//
// [configure serverless secure connectivity]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security
type NetworkConnectivityAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(NetworkConnectivityService)
	impl NetworkConnectivityService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockNetworkConnectivityInterface instead.
func (a *NetworkConnectivityAPI) WithImpl(impl NetworkConnectivityService) NetworkConnectivityInterface {
	a.impl = impl
	return a
}

// Impl returns low-level NetworkConnectivity API implementation
// Deprecated: use MockNetworkConnectivityInterface instead.
func (a *NetworkConnectivityAPI) Impl() NetworkConnectivityService {
	return a.impl
}

// Create a network connectivity configuration.
//
// Creates a network connectivity configuration (NCC), which provides stable
// Azure service subnets when accessing your Azure Storage accounts. You can
// also use a network connectivity configuration to create Databricks-managed
// private endpoints so that Databricks serverless compute resources privately
// access your resources.
//
// **IMPORTANT**: After you create the network connectivity configuration, you
// must assign one or more workspaces to the new network connectivity
// configuration. You can share one network connectivity configuration with
// multiple workspaces from the same Azure region within the same Databricks
// account. See [configure serverless secure connectivity].
//
// [configure serverless secure connectivity]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security
func (a *NetworkConnectivityAPI) CreateNetworkConnectivityConfiguration(ctx context.Context, request CreateNetworkConnectivityConfigRequest) (*NetworkConnectivityConfiguration, error) {
	return a.impl.CreateNetworkConnectivityConfiguration(ctx, request)
}

// Create a private endpoint rule.
//
// Create a private endpoint rule for the specified network connectivity config
// object. Once the object is created, Databricks asynchronously provisions a
// new Azure private endpoint to your specified Azure resource.
//
// **IMPORTANT**: You must use Azure portal or other Azure tools to approve the
// private endpoint to complete the connection. To get the information of the
// private endpoint created, make a `GET` request on the new private endpoint
// rule. See [serverless private link].
//
// [serverless private link]: https://learn.microsoft.com/azure/databricks/security/network/serverless-network-security/serverless-private-link
func (a *NetworkConnectivityAPI) CreatePrivateEndpointRule(ctx context.Context, request CreatePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.CreatePrivateEndpointRule(ctx, request)
}

// Delete a network connectivity configuration.
//
// Deletes a network connectivity configuration.
func (a *NetworkConnectivityAPI) DeleteNetworkConnectivityConfiguration(ctx context.Context, request DeleteNetworkConnectivityConfigurationRequest) error {
	return a.impl.DeleteNetworkConnectivityConfiguration(ctx, request)
}

// Delete a network connectivity configuration.
//
// Deletes a network connectivity configuration.
func (a *NetworkConnectivityAPI) DeleteNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) error {
	return a.impl.DeleteNetworkConnectivityConfiguration(ctx, DeleteNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Delete a private endpoint rule.
//
// Initiates deleting a private endpoint rule. The private endpoint will be
// deactivated and will be purged after seven days of deactivation. When a
// private endpoint is in deactivated state, `deactivated` field is set to
// `true` and the private endpoint is not available to your serverless compute
// resources.
func (a *NetworkConnectivityAPI) DeletePrivateEndpointRule(ctx context.Context, request DeletePrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.DeletePrivateEndpointRule(ctx, request)
}

// Delete a private endpoint rule.
//
// Initiates deleting a private endpoint rule. The private endpoint will be
// deactivated and will be purged after seven days of deactivation. When a
// private endpoint is in deactivated state, `deactivated` field is set to
// `true` and the private endpoint is not available to your serverless compute
// resources.
func (a *NetworkConnectivityAPI) DeletePrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.DeletePrivateEndpointRule(ctx, DeletePrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// Get a network connectivity configuration.
//
// Gets a network connectivity configuration.
func (a *NetworkConnectivityAPI) GetNetworkConnectivityConfiguration(ctx context.Context, request GetNetworkConnectivityConfigurationRequest) (*NetworkConnectivityConfiguration, error) {
	return a.impl.GetNetworkConnectivityConfiguration(ctx, request)
}

// Get a network connectivity configuration.
//
// Gets a network connectivity configuration.
func (a *NetworkConnectivityAPI) GetNetworkConnectivityConfigurationByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*NetworkConnectivityConfiguration, error) {
	return a.impl.GetNetworkConnectivityConfiguration(ctx, GetNetworkConnectivityConfigurationRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

// Get a private endpoint rule.
//
// Gets the private endpoint rule.
func (a *NetworkConnectivityAPI) GetPrivateEndpointRule(ctx context.Context, request GetPrivateEndpointRuleRequest) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.GetPrivateEndpointRule(ctx, request)
}

// Get a private endpoint rule.
//
// Gets the private endpoint rule.
func (a *NetworkConnectivityAPI) GetPrivateEndpointRuleByNetworkConnectivityConfigIdAndPrivateEndpointRuleId(ctx context.Context, networkConnectivityConfigId string, privateEndpointRuleId string) (*NccAzurePrivateEndpointRule, error) {
	return a.impl.GetPrivateEndpointRule(ctx, GetPrivateEndpointRuleRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
		PrivateEndpointRuleId:       privateEndpointRuleId,
	})
}

// List network connectivity configurations.
//
// Gets an array of network connectivity configurations.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListNetworkConnectivityConfigurations(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) listing.Iterator[NetworkConnectivityConfiguration] {

	getNextPage := func(ctx context.Context, req ListNetworkConnectivityConfigurationsRequest) (*ListNetworkConnectivityConfigurationsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.ListNetworkConnectivityConfigurations(ctx, req)
	}
	getItems := func(resp *ListNetworkConnectivityConfigurationsResponse) []NetworkConnectivityConfiguration {
		return resp.Items
	}
	getNextReq := func(resp *ListNetworkConnectivityConfigurationsResponse) *ListNetworkConnectivityConfigurationsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List network connectivity configurations.
//
// Gets an array of network connectivity configurations.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListNetworkConnectivityConfigurationsAll(ctx context.Context, request ListNetworkConnectivityConfigurationsRequest) ([]NetworkConnectivityConfiguration, error) {
	iterator := a.ListNetworkConnectivityConfigurations(ctx, request)
	return listing.ToSlice[NetworkConnectivityConfiguration](ctx, iterator)
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRules(ctx context.Context, request ListPrivateEndpointRulesRequest) listing.Iterator[NccAzurePrivateEndpointRule] {

	getNextPage := func(ctx context.Context, req ListPrivateEndpointRulesRequest) (*ListNccAzurePrivateEndpointRulesResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.ListPrivateEndpointRules(ctx, req)
	}
	getItems := func(resp *ListNccAzurePrivateEndpointRulesResponse) []NccAzurePrivateEndpointRule {
		return resp.Items
	}
	getNextReq := func(resp *ListNccAzurePrivateEndpointRulesResponse) *ListPrivateEndpointRulesRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
//
// This method is generated by Databricks SDK Code Generator.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRulesAll(ctx context.Context, request ListPrivateEndpointRulesRequest) ([]NccAzurePrivateEndpointRule, error) {
	iterator := a.ListPrivateEndpointRules(ctx, request)
	return listing.ToSlice[NccAzurePrivateEndpointRule](ctx, iterator)
}

// List private endpoint rules.
//
// Gets an array of private endpoint rules.
func (a *NetworkConnectivityAPI) ListPrivateEndpointRulesByNetworkConnectivityConfigId(ctx context.Context, networkConnectivityConfigId string) (*ListNccAzurePrivateEndpointRulesResponse, error) {
	return a.impl.ListPrivateEndpointRules(ctx, ListPrivateEndpointRulesRequest{
		NetworkConnectivityConfigId: networkConnectivityConfigId,
	})
}

type SettingsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockSettingsInterface instead.
	WithImpl(impl SettingsService) SettingsInterface

	// Impl returns low-level Settings API implementation
	// Deprecated: use MockSettingsInterface instead.
	Impl() SettingsService

	// Delete the default namespace setting.
	//
	// Deletes the default namespace setting for the workspace. A fresh etag needs
	// to be provided in DELETE requests (as a query parameter). The etag can be
	// retrieved by making a GET request before the DELETE request. If the setting
	// is updated/deleted concurrently, DELETE will fail with 409 and the request
	// will need to be retried by using the fresh etag in the 409 response.
	DeleteDefaultNamespaceSetting(ctx context.Context, request DeleteDefaultNamespaceSettingRequest) (*DeleteDefaultNamespaceSettingResponse, error)

	// Delete the restrict workspace admins setting.
	//
	// Reverts the restrict workspace admins setting status for the workspace. A
	// fresh etag needs to be provided in DELETE requests (as a query parameter).
	// The etag can be retrieved by making a GET request before the DELETE request.
	// If the setting is updated/deleted concurrently, DELETE will fail with 409 and
	// the request will need to be retried by using the fresh etag in the 409
	// response.
	DeleteRestrictWorkspaceAdminsSetting(ctx context.Context, request DeleteRestrictWorkspaceAdminsSettingRequest) (*DeleteRestrictWorkspaceAdminsSettingResponse, error)

	// Get the default namespace setting.
	//
	// Gets the default namespace setting.
	GetDefaultNamespaceSetting(ctx context.Context, request GetDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)

	// Get the restrict workspace admins setting.
	//
	// Gets the restrict workspace admins setting.
	GetRestrictWorkspaceAdminsSetting(ctx context.Context, request GetRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)

	// Update the default namespace setting.
	//
	// Updates the default namespace setting for the workspace. A fresh etag needs
	// to be provided in PATCH requests (as part of the setting field). The etag can
	// be retrieved by making a GET request before the PATCH request. Note that if
	// the setting does not exist, GET will return a NOT_FOUND error and the etag
	// will be present in the error response, which should be set in the PATCH
	// request. If the setting is updated concurrently, PATCH will fail with 409 and
	// the request will need to be retried by using the fresh etag in the 409
	// response.
	UpdateDefaultNamespaceSetting(ctx context.Context, request UpdateDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error)

	// Update the restrict workspace admins setting.
	//
	// Updates the restrict workspace admins setting for the workspace. A fresh etag
	// needs to be provided in PATCH requests (as part of the setting field). The
	// etag can be retrieved by making a GET request before the PATCH request. If
	// the setting is updated concurrently, PATCH will fail with 409 and the request
	// will need to be retried by using the fresh etag in the 409 response.
	UpdateRestrictWorkspaceAdminsSetting(ctx context.Context, request UpdateRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error)
}

func NewSettings(client *client.DatabricksClient) *SettingsAPI {
	return &SettingsAPI{
		impl: &settingsImpl{
			client: client,
		},
	}
}

// The default namespace setting API allows users to configure the default
// namespace for a Databricks workspace.
//
// Through this API, users can retrieve, set, or modify the default namespace
// used when queries do not reference a fully qualified three-level name. For
// example, if you use the API to set 'retail_prod' as the default catalog, then
// a query 'SELECT * FROM myTable' would reference the object
// 'retail_prod.default.myTable' (the schema 'default' is always assumed).
//
// This setting requires a restart of clusters and SQL warehouses to take
// effect. Additionally, the default namespace only applies when using Unity
// Catalog-enabled compute.
type SettingsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(SettingsService)
	impl SettingsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockSettingsInterface instead.
func (a *SettingsAPI) WithImpl(impl SettingsService) SettingsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Settings API implementation
// Deprecated: use MockSettingsInterface instead.
func (a *SettingsAPI) Impl() SettingsService {
	return a.impl
}

// Delete the default namespace setting.
//
// Deletes the default namespace setting for the workspace. A fresh etag needs
// to be provided in DELETE requests (as a query parameter). The etag can be
// retrieved by making a GET request before the DELETE request. If the setting
// is updated/deleted concurrently, DELETE will fail with 409 and the request
// will need to be retried by using the fresh etag in the 409 response.
func (a *SettingsAPI) DeleteDefaultNamespaceSetting(ctx context.Context, request DeleteDefaultNamespaceSettingRequest) (*DeleteDefaultNamespaceSettingResponse, error) {
	return a.impl.DeleteDefaultNamespaceSetting(ctx, request)
}

// Delete the restrict workspace admins setting.
//
// Reverts the restrict workspace admins setting status for the workspace. A
// fresh etag needs to be provided in DELETE requests (as a query parameter).
// The etag can be retrieved by making a GET request before the DELETE request.
// If the setting is updated/deleted concurrently, DELETE will fail with 409 and
// the request will need to be retried by using the fresh etag in the 409
// response.
func (a *SettingsAPI) DeleteRestrictWorkspaceAdminsSetting(ctx context.Context, request DeleteRestrictWorkspaceAdminsSettingRequest) (*DeleteRestrictWorkspaceAdminsSettingResponse, error) {
	return a.impl.DeleteRestrictWorkspaceAdminsSetting(ctx, request)
}

// Get the default namespace setting.
//
// Gets the default namespace setting.
func (a *SettingsAPI) GetDefaultNamespaceSetting(ctx context.Context, request GetDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error) {
	return a.impl.GetDefaultNamespaceSetting(ctx, request)
}

// Get the restrict workspace admins setting.
//
// Gets the restrict workspace admins setting.
func (a *SettingsAPI) GetRestrictWorkspaceAdminsSetting(ctx context.Context, request GetRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error) {
	return a.impl.GetRestrictWorkspaceAdminsSetting(ctx, request)
}

// Update the default namespace setting.
//
// Updates the default namespace setting for the workspace. A fresh etag needs
// to be provided in PATCH requests (as part of the setting field). The etag can
// be retrieved by making a GET request before the PATCH request. Note that if
// the setting does not exist, GET will return a NOT_FOUND error and the etag
// will be present in the error response, which should be set in the PATCH
// request. If the setting is updated concurrently, PATCH will fail with 409 and
// the request will need to be retried by using the fresh etag in the 409
// response.
func (a *SettingsAPI) UpdateDefaultNamespaceSetting(ctx context.Context, request UpdateDefaultNamespaceSettingRequest) (*DefaultNamespaceSetting, error) {
	return a.impl.UpdateDefaultNamespaceSetting(ctx, request)
}

// Update the restrict workspace admins setting.
//
// Updates the restrict workspace admins setting for the workspace. A fresh etag
// needs to be provided in PATCH requests (as part of the setting field). The
// etag can be retrieved by making a GET request before the PATCH request. If
// the setting is updated concurrently, PATCH will fail with 409 and the request
// will need to be retried by using the fresh etag in the 409 response.
func (a *SettingsAPI) UpdateRestrictWorkspaceAdminsSetting(ctx context.Context, request UpdateRestrictWorkspaceAdminsSettingRequest) (*RestrictWorkspaceAdminsSetting, error) {
	return a.impl.UpdateRestrictWorkspaceAdminsSetting(ctx, request)
}

type TokenManagementInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockTokenManagementInterface instead.
	WithImpl(impl TokenManagementService) TokenManagementInterface

	// Impl returns low-level TokenManagement API implementation
	// Deprecated: use MockTokenManagementInterface instead.
	Impl() TokenManagementService

	// Create on-behalf token.
	//
	// Creates a token on behalf of a service principal.
	CreateOboToken(ctx context.Context, request CreateOboTokenRequest) (*CreateOboTokenResponse, error)

	// Delete a token.
	//
	// Deletes a token, specified by its ID.
	Delete(ctx context.Context, request DeleteTokenManagementRequest) error

	// Delete a token.
	//
	// Deletes a token, specified by its ID.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// Get token info.
	//
	// Gets information about a token, specified by its ID.
	Get(ctx context.Context, request GetTokenManagementRequest) (*GetTokenResponse, error)

	// Get token info.
	//
	// Gets information about a token, specified by its ID.
	GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error)

	// Get token permission levels.
	//
	// Gets the permission levels that a user can have on an object.
	GetPermissionLevels(ctx context.Context) (*GetTokenPermissionLevelsResponse, error)

	// Get token permissions.
	//
	// Gets the permissions of all tokens. Tokens can inherit permissions from their
	// root object.
	GetPermissions(ctx context.Context) (*TokenPermissions, error)

	// List all tokens.
	//
	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListTokenManagementRequest) listing.Iterator[TokenInfo]

	// List all tokens.
	//
	// Lists all tokens associated with the specified workspace or user.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListTokenManagementRequest) ([]TokenInfo, error)

	// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error)

	// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
	//
	// Returns an error if there's more than one [TokenInfo] with the same .Comment.
	//
	// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*TokenInfo, error)

	// Set token permissions.
	//
	// Sets permissions on all tokens. Tokens can inherit permissions from their
	// root object.
	SetPermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)

	// Update token permissions.
	//
	// Updates the permissions on all tokens. Tokens can inherit permissions from
	// their root object.
	UpdatePermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error)
}

func NewTokenManagement(client *client.DatabricksClient) *TokenManagementAPI {
	return &TokenManagementAPI{
		impl: &tokenManagementImpl{
			client: client,
		},
	}
}

// Enables administrators to get all tokens and delete tokens for other users.
// Admins can either get every token, get a specific token by ID, or get all
// tokens for a particular user.
type TokenManagementAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(TokenManagementService)
	impl TokenManagementService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockTokenManagementInterface instead.
func (a *TokenManagementAPI) WithImpl(impl TokenManagementService) TokenManagementInterface {
	a.impl = impl
	return a
}

// Impl returns low-level TokenManagement API implementation
// Deprecated: use MockTokenManagementInterface instead.
func (a *TokenManagementAPI) Impl() TokenManagementService {
	return a.impl
}

// Create on-behalf token.
//
// Creates a token on behalf of a service principal.
func (a *TokenManagementAPI) CreateOboToken(ctx context.Context, request CreateOboTokenRequest) (*CreateOboTokenResponse, error) {
	return a.impl.CreateOboToken(ctx, request)
}

// Delete a token.
//
// Deletes a token, specified by its ID.
func (a *TokenManagementAPI) Delete(ctx context.Context, request DeleteTokenManagementRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a token.
//
// Deletes a token, specified by its ID.
func (a *TokenManagementAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.impl.Delete(ctx, DeleteTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Get token info.
//
// Gets information about a token, specified by its ID.
func (a *TokenManagementAPI) Get(ctx context.Context, request GetTokenManagementRequest) (*GetTokenResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get token info.
//
// Gets information about a token, specified by its ID.
func (a *TokenManagementAPI) GetByTokenId(ctx context.Context, tokenId string) (*GetTokenResponse, error) {
	return a.impl.Get(ctx, GetTokenManagementRequest{
		TokenId: tokenId,
	})
}

// Get token permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *TokenManagementAPI) GetPermissionLevels(ctx context.Context) (*GetTokenPermissionLevelsResponse, error) {
	return a.impl.GetPermissionLevels(ctx)
}

// Get token permissions.
//
// Gets the permissions of all tokens. Tokens can inherit permissions from their
// root object.
func (a *TokenManagementAPI) GetPermissions(ctx context.Context) (*TokenPermissions, error) {
	return a.impl.GetPermissions(ctx)
}

// List all tokens.
//
// Lists all tokens associated with the specified workspace or user.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) List(ctx context.Context, request ListTokenManagementRequest) listing.Iterator[TokenInfo] {

	getNextPage := func(ctx context.Context, req ListTokenManagementRequest) (*ListTokensResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListTokensResponse) []TokenInfo {
		return resp.TokenInfos
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List all tokens.
//
// Lists all tokens associated with the specified workspace or user.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) ListAll(ctx context.Context, request ListTokenManagementRequest) ([]TokenInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSlice[TokenInfo](ctx, iterator)
}

// TokenInfoCommentToTokenIdMap calls [TokenManagementAPI.ListAll] and creates a map of results with [TokenInfo].Comment as key and [TokenInfo].TokenId as value.
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) TokenInfoCommentToTokenIdMap(ctx context.Context, request ListTokenManagementRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokenManagementAPI.TokenInfoCommentToTokenIdMap] and returns a single [TokenInfo].
//
// Returns an error if there's more than one [TokenInfo] with the same .Comment.
//
// Note: All [TokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokenManagementAPI) GetByComment(ctx context.Context, name string) (*TokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTokenManagementRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Set token permissions.
//
// Sets permissions on all tokens. Tokens can inherit permissions from their
// root object.
func (a *TokenManagementAPI) SetPermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error) {
	return a.impl.SetPermissions(ctx, request)
}

// Update token permissions.
//
// Updates the permissions on all tokens. Tokens can inherit permissions from
// their root object.
func (a *TokenManagementAPI) UpdatePermissions(ctx context.Context, request TokenPermissionsRequest) (*TokenPermissions, error) {
	return a.impl.UpdatePermissions(ctx, request)
}

type TokensInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockTokensInterface instead.
	WithImpl(impl TokensService) TokensInterface

	// Impl returns low-level Tokens API implementation
	// Deprecated: use MockTokensInterface instead.
	Impl() TokensService

	// Create a user token.
	//
	// Creates and returns a token for a user. If this call is made through token
	// authentication, it creates a token with the same client ID as the
	// authenticated token. If the user's token quota is exceeded, this call returns
	// an error **QUOTA_EXCEEDED**.
	Create(ctx context.Context, request CreateTokenRequest) (*CreateTokenResponse, error)

	// Revoke token.
	//
	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	Delete(ctx context.Context, request RevokeTokenRequest) error

	// Revoke token.
	//
	// Revokes an access token.
	//
	// If a token with the specified ID is not valid, this call returns an error
	// **RESOURCE_DOES_NOT_EXIST**.
	DeleteByTokenId(ctx context.Context, tokenId string) error

	// List tokens.
	//
	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[PublicTokenInfo]

	// List tokens.
	//
	// Lists all the valid tokens for a user-workspace pair.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]PublicTokenInfo, error)

	// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error)

	// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
	//
	// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
	//
	// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error)
}

func NewTokens(client *client.DatabricksClient) *TokensAPI {
	return &TokensAPI{
		impl: &tokensImpl{
			client: client,
		},
	}
}

// The Token API allows you to create, list, and revoke tokens that can be used
// to authenticate and access Databricks REST APIs.
type TokensAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(TokensService)
	impl TokensService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockTokensInterface instead.
func (a *TokensAPI) WithImpl(impl TokensService) TokensInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Tokens API implementation
// Deprecated: use MockTokensInterface instead.
func (a *TokensAPI) Impl() TokensService {
	return a.impl
}

// Create a user token.
//
// Creates and returns a token for a user. If this call is made through token
// authentication, it creates a token with the same client ID as the
// authenticated token. If the user's token quota is exceeded, this call returns
// an error **QUOTA_EXCEEDED**.
func (a *TokensAPI) Create(ctx context.Context, request CreateTokenRequest) (*CreateTokenResponse, error) {
	return a.impl.Create(ctx, request)
}

// Revoke token.
//
// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *TokensAPI) Delete(ctx context.Context, request RevokeTokenRequest) error {
	return a.impl.Delete(ctx, request)
}

// Revoke token.
//
// Revokes an access token.
//
// If a token with the specified ID is not valid, this call returns an error
// **RESOURCE_DOES_NOT_EXIST**.
func (a *TokensAPI) DeleteByTokenId(ctx context.Context, tokenId string) error {
	return a.impl.Delete(ctx, RevokeTokenRequest{
		TokenId: tokenId,
	})
}

// List tokens.
//
// Lists all the valid tokens for a user-workspace pair.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) List(ctx context.Context) listing.Iterator[PublicTokenInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListPublicTokensResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListPublicTokensResponse) []PublicTokenInfo {
		return resp.TokenInfos
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List tokens.
//
// Lists all the valid tokens for a user-workspace pair.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) ListAll(ctx context.Context) ([]PublicTokenInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[PublicTokenInfo](ctx, iterator)
}

// PublicTokenInfoCommentToTokenIdMap calls [TokensAPI.ListAll] and creates a map of results with [PublicTokenInfo].Comment as key and [PublicTokenInfo].TokenId as value.
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) PublicTokenInfoCommentToTokenIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Comment
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Comment: %s", key)
		}
		mapping[key] = v.TokenId
	}
	return mapping, nil
}

// GetByComment calls [TokensAPI.PublicTokenInfoCommentToTokenIdMap] and returns a single [PublicTokenInfo].
//
// Returns an error if there's more than one [PublicTokenInfo] with the same .Comment.
//
// Note: All [PublicTokenInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TokensAPI) GetByComment(ctx context.Context, name string) (*PublicTokenInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]PublicTokenInfo{}
	for _, v := range result {
		key := v.Comment
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("PublicTokenInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of PublicTokenInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type WorkspaceConfInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockWorkspaceConfInterface instead.
	WithImpl(impl WorkspaceConfService) WorkspaceConfInterface

	// Impl returns low-level WorkspaceConf API implementation
	// Deprecated: use MockWorkspaceConfInterface instead.
	Impl() WorkspaceConfService

	// Check configuration status.
	//
	// Gets the configuration status for a workspace.
	GetStatus(ctx context.Context, request GetStatusRequest) (*map[string]string, error)

	// Enable/disable features.
	//
	// Sets the configuration status for a workspace, including enabling or
	// disabling it.
	SetStatus(ctx context.Context, request WorkspaceConf) error
}

func NewWorkspaceConf(client *client.DatabricksClient) *WorkspaceConfAPI {
	return &WorkspaceConfAPI{
		impl: &workspaceConfImpl{
			client: client,
		},
	}
}

// This API allows updating known workspace settings for advanced users.
type WorkspaceConfAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(WorkspaceConfService)
	impl WorkspaceConfService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockWorkspaceConfInterface instead.
func (a *WorkspaceConfAPI) WithImpl(impl WorkspaceConfService) WorkspaceConfInterface {
	a.impl = impl
	return a
}

// Impl returns low-level WorkspaceConf API implementation
// Deprecated: use MockWorkspaceConfInterface instead.
func (a *WorkspaceConfAPI) Impl() WorkspaceConfService {
	return a.impl
}

// Check configuration status.
//
// Gets the configuration status for a workspace.
func (a *WorkspaceConfAPI) GetStatus(ctx context.Context, request GetStatusRequest) (*map[string]string, error) {
	return a.impl.GetStatus(ctx, request)
}

// Enable/disable features.
//
// Sets the configuration status for a workspace, including enabling or
// disabling it.
func (a *WorkspaceConfAPI) SetStatus(ctx context.Context, request WorkspaceConf) error {
	return a.impl.SetStatus(ctx, request)
}
