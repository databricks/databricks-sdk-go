// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Alerts, Alerts Legacy, Alerts V2, Dashboard Widgets, Dashboards, Data Sources, Dbsql Permissions, Queries, Queries Legacy, Query History, Query Visualizations, Query Visualizations Legacy, Redash Config, Statement Execution, Warehouses, etc.
package sql

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AlertsInterface interface {

	// Creates an alert.
	Create(ctx context.Context, request CreateAlertRequest) (*Alert, error)

	// Moves an alert to the trash. Trashed alerts immediately disappear from
	// searches and list views, and can no longer trigger. You can restore a trashed
	// alert through the UI. A trashed alert is permanently deleted after 30 days.
	Delete(ctx context.Context, request TrashAlertRequest) error

	// Moves an alert to the trash. Trashed alerts immediately disappear from
	// searches and list views, and can no longer trigger. You can restore a trashed
	// alert through the UI. A trashed alert is permanently deleted after 30 days.
	DeleteById(ctx context.Context, id string) error

	// Gets an alert.
	Get(ctx context.Context, request GetAlertRequest) (*Alert, error)

	// Gets an alert.
	GetById(ctx context.Context, id string) (*Alert, error)

	// Gets a list of alerts accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAlertsRequest) listing.Iterator[ListAlertsResponseAlert]

	// Gets a list of alerts accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAlertsRequest) ([]ListAlertsResponseAlert, error)

	// ListAlertsResponseAlertDisplayNameToIdMap calls [AlertsAPI.ListAll] and creates a map of results with [ListAlertsResponseAlert].DisplayName as key and [ListAlertsResponseAlert].Id as value.
	//
	// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
	//
	// Note: All [ListAlertsResponseAlert] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAlertsResponseAlertDisplayNameToIdMap(ctx context.Context, request ListAlertsRequest) (map[string]string, error)

	// GetByDisplayName calls [AlertsAPI.ListAlertsResponseAlertDisplayNameToIdMap] and returns a single [ListAlertsResponseAlert].
	//
	// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
	//
	// Note: All [ListAlertsResponseAlert] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByDisplayName(ctx context.Context, name string) (*ListAlertsResponseAlert, error)

	// Updates an alert.
	Update(ctx context.Context, request UpdateAlertRequest) (*Alert, error)
}

func NewAlerts(client *client.DatabricksClient) *AlertsAPI {
	return &AlertsAPI{
		alertsImpl: alertsImpl{
			client: client,
		},
	}
}

// The alerts API can be used to perform CRUD operations on alerts. An alert is
// a Databricks SQL object that periodically runs a query, evaluates a condition
// of its result, and notifies one or more users and/or notification
// destinations if the condition was met. Alerts can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type AlertsAPI struct {
	alertsImpl
}

// Moves an alert to the trash. Trashed alerts immediately disappear from
// searches and list views, and can no longer trigger. You can restore a trashed
// alert through the UI. A trashed alert is permanently deleted after 30 days.
func (a *AlertsAPI) DeleteById(ctx context.Context, id string) error {
	return a.alertsImpl.Delete(ctx, TrashAlertRequest{
		Id: id,
	})
}

// Gets an alert.
func (a *AlertsAPI) GetById(ctx context.Context, id string) (*Alert, error) {
	return a.alertsImpl.Get(ctx, GetAlertRequest{
		Id: id,
	})
}

// ListAlertsResponseAlertDisplayNameToIdMap calls [AlertsAPI.ListAll] and creates a map of results with [ListAlertsResponseAlert].DisplayName as key and [ListAlertsResponseAlert].Id as value.
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) ListAlertsResponseAlertDisplayNameToIdMap(ctx context.Context, request ListAlertsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [AlertsAPI.ListAlertsResponseAlertDisplayNameToIdMap] and returns a single [ListAlertsResponseAlert].
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) GetByDisplayName(ctx context.Context, name string) (*ListAlertsResponseAlert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListAlertsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListAlertsResponseAlert{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListAlertsResponseAlert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListAlertsResponseAlert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type AlertsLegacyInterface interface {

	// Creates an alert. An alert is a Databricks SQL object that periodically runs
	// a query, evaluates a condition of its result, and notifies users or
	// notification destinations if the condition was met.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/create instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Create(ctx context.Context, request CreateAlert) (*LegacyAlert, error)

	// Deletes an alert. Deleted alerts are no longer accessible and cannot be
	// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
	// the trash.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Delete(ctx context.Context, request DeleteAlertsLegacyRequest) error

	// Deletes an alert. Deleted alerts are no longer accessible and cannot be
	// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
	// the trash.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	DeleteByAlertId(ctx context.Context, alertId string) error

	// Gets an alert.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Get(ctx context.Context, request GetAlertsLegacyRequest) (*LegacyAlert, error)

	// Gets an alert.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	GetByAlertId(ctx context.Context, alertId string) (*LegacyAlert, error)

	// Gets a list of alerts.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	List(ctx context.Context) ([]LegacyAlert, error)

	// Updates an alert.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/update instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Update(ctx context.Context, request EditAlert) error
}

func NewAlertsLegacy(client *client.DatabricksClient) *AlertsLegacyAPI {
	return &AlertsLegacyAPI{
		alertsLegacyImpl: alertsLegacyImpl{
			client: client,
		},
	}
}

// The alerts API can be used to perform CRUD operations on alerts. An alert is
// a Databricks SQL object that periodically runs a query, evaluates a condition
// of its result, and notifies one or more users and/or notification
// destinations if the condition was met. Alerts can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type AlertsLegacyAPI struct {
	alertsLegacyImpl
}

// Deletes an alert. Deleted alerts are no longer accessible and cannot be
// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
// the trash.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *AlertsLegacyAPI) DeleteByAlertId(ctx context.Context, alertId string) error {
	return a.alertsLegacyImpl.Delete(ctx, DeleteAlertsLegacyRequest{
		AlertId: alertId,
	})
}

// Gets an alert.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *AlertsLegacyAPI) GetByAlertId(ctx context.Context, alertId string) (*LegacyAlert, error) {
	return a.alertsLegacyImpl.Get(ctx, GetAlertsLegacyRequest{
		AlertId: alertId,
	})
}

type AlertsV2Interface interface {

	// Create Alert
	CreateAlert(ctx context.Context, request CreateAlertV2Request) (*AlertV2, error)

	// Gets an alert.
	GetAlert(ctx context.Context, request GetAlertV2Request) (*AlertV2, error)

	// Gets an alert.
	GetAlertById(ctx context.Context, id string) (*AlertV2, error)

	// Gets a list of alerts accessible to the user, ordered by creation time.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAlerts(ctx context.Context, request ListAlertsV2Request) listing.Iterator[AlertV2]

	// Gets a list of alerts accessible to the user, ordered by creation time.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAlertsAll(ctx context.Context, request ListAlertsV2Request) ([]AlertV2, error)

	// AlertV2DisplayNameToIdMap calls [AlertsV2API.ListAlertsAll] and creates a map of results with [AlertV2].DisplayName as key and [AlertV2].Id as value.
	//
	// Returns an error if there's more than one [AlertV2] with the same .DisplayName.
	//
	// Note: All [AlertV2] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	AlertV2DisplayNameToIdMap(ctx context.Context, request ListAlertsV2Request) (map[string]string, error)

	// GetByDisplayName calls [AlertsV2API.AlertV2DisplayNameToIdMap] and returns a single [AlertV2].
	//
	// Returns an error if there's more than one [AlertV2] with the same .DisplayName.
	//
	// Note: All [AlertV2] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByDisplayName(ctx context.Context, name string) (*AlertV2, error)

	// Moves an alert to the trash. Trashed alerts immediately disappear from list
	// views, and can no longer trigger. You can restore a trashed alert through the
	// UI. A trashed alert is permanently deleted after 30 days.
	TrashAlert(ctx context.Context, request TrashAlertV2Request) error

	// Moves an alert to the trash. Trashed alerts immediately disappear from list
	// views, and can no longer trigger. You can restore a trashed alert through the
	// UI. A trashed alert is permanently deleted after 30 days.
	TrashAlertById(ctx context.Context, id string) error

	// Update alert
	UpdateAlert(ctx context.Context, request UpdateAlertV2Request) (*AlertV2, error)
}

func NewAlertsV2(client *client.DatabricksClient) *AlertsV2API {
	return &AlertsV2API{
		alertsV2Impl: alertsV2Impl{
			client: client,
		},
	}
}

// New version of SQL Alerts
type AlertsV2API struct {
	alertsV2Impl
}

// Gets an alert.
func (a *AlertsV2API) GetAlertById(ctx context.Context, id string) (*AlertV2, error) {
	return a.alertsV2Impl.GetAlert(ctx, GetAlertV2Request{
		Id: id,
	})
}

// AlertV2DisplayNameToIdMap calls [AlertsV2API.ListAlertsAll] and creates a map of results with [AlertV2].DisplayName as key and [AlertV2].Id as value.
//
// Returns an error if there's more than one [AlertV2] with the same .DisplayName.
//
// Note: All [AlertV2] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsV2API) AlertV2DisplayNameToIdMap(ctx context.Context, request ListAlertsV2Request) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAlertsAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [AlertsV2API.AlertV2DisplayNameToIdMap] and returns a single [AlertV2].
//
// Returns an error if there's more than one [AlertV2] with the same .DisplayName.
//
// Note: All [AlertV2] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsV2API) GetByDisplayName(ctx context.Context, name string) (*AlertV2, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAlertsAll(ctx, ListAlertsV2Request{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]AlertV2{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("AlertV2 named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of AlertV2 named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Moves an alert to the trash. Trashed alerts immediately disappear from list
// views, and can no longer trigger. You can restore a trashed alert through the
// UI. A trashed alert is permanently deleted after 30 days.
func (a *AlertsV2API) TrashAlertById(ctx context.Context, id string) error {
	return a.alertsV2Impl.TrashAlert(ctx, TrashAlertV2Request{
		Id: id,
	})
}

type DashboardWidgetsInterface interface {

	// Adds a widget to a dashboard
	Create(ctx context.Context, request CreateWidget) (*Widget, error)

	// Removes a widget from a dashboard
	Delete(ctx context.Context, request DeleteDashboardWidgetRequest) error

	// Removes a widget from a dashboard
	DeleteById(ctx context.Context, id string) error

	// Updates an existing widget
	Update(ctx context.Context, request UpdateWidgetRequest) (*Widget, error)
}

func NewDashboardWidgets(client *client.DatabricksClient) *DashboardWidgetsAPI {
	return &DashboardWidgetsAPI{
		dashboardWidgetsImpl: dashboardWidgetsImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of widgets
// from existing dashboards within the Databricks Workspace. Data structures may
// change over time.
type DashboardWidgetsAPI struct {
	dashboardWidgetsImpl
}

// Removes a widget from a dashboard
func (a *DashboardWidgetsAPI) DeleteById(ctx context.Context, id string) error {
	return a.dashboardWidgetsImpl.Delete(ctx, DeleteDashboardWidgetRequest{
		Id: id,
	})
}

type DashboardsInterface interface {

	// Moves a dashboard to the trash. Trashed dashboards do not appear in list
	// views or searches, and cannot be shared.
	Delete(ctx context.Context, request DeleteDashboardRequest) error

	// Moves a dashboard to the trash. Trashed dashboards do not appear in list
	// views or searches, and cannot be shared.
	DeleteByDashboardId(ctx context.Context, dashboardId string) error

	// Returns a JSON representation of a dashboard object, including its
	// visualization and query objects.
	Get(ctx context.Context, request GetDashboardRequest) (*Dashboard, error)

	// Returns a JSON representation of a dashboard object, including its
	// visualization and query objects.
	GetByDashboardId(ctx context.Context, dashboardId string) (*Dashboard, error)

	// Fetch a paginated list of dashboard objects.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListDashboardsRequest) listing.Iterator[Dashboard]

	// Fetch a paginated list of dashboard objects.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListDashboardsRequest) ([]Dashboard, error)

	// A restored dashboard appears in list views and searches and can be shared.
	Restore(ctx context.Context, request RestoreDashboardRequest) error

	// Modify this dashboard definition. This operation only affects attributes of
	// the dashboard object. It does not add, modify, or remove widgets.
	//
	// **Note**: You cannot undo this operation.
	Update(ctx context.Context, request DashboardEditContent) (*Dashboard, error)
}

func NewDashboards(client *client.DatabricksClient) *DashboardsAPI {
	return &DashboardsAPI{
		dashboardsImpl: dashboardsImpl{
			client: client,
		},
	}
}

// In general, there is little need to modify dashboards using the API. However,
// it can be useful to use dashboard objects to look-up a collection of related
// query IDs. The API can also be used to duplicate multiple dashboards at once
// since you can get a dashboard definition with a GET request and then POST it
// to create a new one. Dashboards can be scheduled using the `sql_task` type of
// the Jobs API, e.g. :method:jobs/create.
type DashboardsAPI struct {
	dashboardsImpl
}

// Moves a dashboard to the trash. Trashed dashboards do not appear in list
// views or searches, and cannot be shared.
func (a *DashboardsAPI) DeleteByDashboardId(ctx context.Context, dashboardId string) error {
	return a.dashboardsImpl.Delete(ctx, DeleteDashboardRequest{
		DashboardId: dashboardId,
	})
}

// Returns a JSON representation of a dashboard object, including its
// visualization and query objects.
func (a *DashboardsAPI) GetByDashboardId(ctx context.Context, dashboardId string) (*Dashboard, error) {
	return a.dashboardsImpl.Get(ctx, GetDashboardRequest{
		DashboardId: dashboardId,
	})
}

type DataSourcesInterface interface {

	// Retrieves a full list of SQL warehouses available in this workspace. All
	// fields that appear in this API response are enumerated for clarity. However,
	// you need only a SQL warehouse's `id` to create new queries against it.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:warehouses/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	List(ctx context.Context) ([]DataSource, error)
}

func NewDataSources(client *client.DatabricksClient) *DataSourcesAPI {
	return &DataSourcesAPI{
		dataSourcesImpl: dataSourcesImpl{
			client: client,
		},
	}
}

// This API is provided to assist you in making new query objects. When creating
// a query object, you may optionally specify a `data_source_id` for the SQL
// warehouse against which it will run. If you don't already know the
// `data_source_id` for your desired SQL warehouse, this API will help you find
// it.
//
// This API does not support searches. It returns the full list of SQL
// warehouses in your workspace. We advise you to use any text editor, REST
// client, or `grep` to search the response from this API for the name of your
// SQL warehouse as it appears in Databricks SQL.
//
// **Note**: A new version of the Databricks SQL API is now available. [Learn
// more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type DataSourcesAPI struct {
	dataSourcesImpl
}

type DbsqlPermissionsInterface interface {

	// Gets a JSON representation of the access control list (ACL) for a specified
	// object.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:workspace/getpermissions instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Get(ctx context.Context, request GetDbsqlPermissionRequest) (*GetResponse, error)

	// Gets a JSON representation of the access control list (ACL) for a specified
	// object.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:workspace/getpermissions instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	GetByObjectTypeAndObjectId(ctx context.Context, objectType ObjectTypePlural, objectId string) (*GetResponse, error)

	// Sets the access control list (ACL) for a specified object. This operation
	// will complete rewrite the ACL.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:workspace/setpermissions instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Set(ctx context.Context, request SetRequest) (*SetResponse, error)

	// Transfers ownership of a dashboard, query, or alert to an active user.
	// Requires an admin API key.
	//
	// **Note**: A new version of the Databricks SQL API is now available. For
	// queries and alerts, please use :method:queries/update and
	// :method:alerts/update respectively instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	TransferOwnership(ctx context.Context, request TransferOwnershipRequest) (*Success, error)
}

func NewDbsqlPermissions(client *client.DatabricksClient) *DbsqlPermissionsAPI {
	return &DbsqlPermissionsAPI{
		dbsqlPermissionsImpl: dbsqlPermissionsImpl{
			client: client,
		},
	}
}

// The SQL Permissions API is similar to the endpoints of the
// :method:permissions/set. However, this exposes only one endpoint, which gets
// the Access Control List for a given object. You cannot modify any permissions
// using this API.
//
// There are three levels of permission:
//
// - `CAN_VIEW`: Allows read-only access
//
// - `CAN_RUN`: Allows read access and run access (superset of `CAN_VIEW`)
//
// - `CAN_MANAGE`: Allows all actions: read, run, edit, delete, modify
// permissions (superset of `CAN_RUN`)
//
// **Note**: A new version of the Databricks SQL API is now available. [Learn
// more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type DbsqlPermissionsAPI struct {
	dbsqlPermissionsImpl
}

// Gets a JSON representation of the access control list (ACL) for a specified
// object.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:workspace/getpermissions instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *DbsqlPermissionsAPI) GetByObjectTypeAndObjectId(ctx context.Context, objectType ObjectTypePlural, objectId string) (*GetResponse, error) {
	return a.dbsqlPermissionsImpl.Get(ctx, GetDbsqlPermissionRequest{
		ObjectType: objectType,
		ObjectId:   objectId,
	})
}

type QueriesInterface interface {

	// Creates a query.
	Create(ctx context.Context, request CreateQueryRequest) (*Query, error)

	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and cannot be used for alerts. You can restore a
	// trashed query through the UI. A trashed query is permanently deleted after 30
	// days.
	Delete(ctx context.Context, request TrashQueryRequest) error

	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and cannot be used for alerts. You can restore a
	// trashed query through the UI. A trashed query is permanently deleted after 30
	// days.
	DeleteById(ctx context.Context, id string) error

	// Gets a query.
	Get(ctx context.Context, request GetQueryRequest) (*Query, error)

	// Gets a query.
	GetById(ctx context.Context, id string) (*Query, error)

	// Gets a list of queries accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListQueriesRequest) listing.Iterator[ListQueryObjectsResponseQuery]

	// Gets a list of queries accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListQueriesRequest) ([]ListQueryObjectsResponseQuery, error)

	// ListQueryObjectsResponseQueryDisplayNameToIdMap calls [QueriesAPI.ListAll] and creates a map of results with [ListQueryObjectsResponseQuery].DisplayName as key and [ListQueryObjectsResponseQuery].Id as value.
	//
	// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
	//
	// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListQueryObjectsResponseQueryDisplayNameToIdMap(ctx context.Context, request ListQueriesRequest) (map[string]string, error)

	// GetByDisplayName calls [QueriesAPI.ListQueryObjectsResponseQueryDisplayNameToIdMap] and returns a single [ListQueryObjectsResponseQuery].
	//
	// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
	//
	// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByDisplayName(ctx context.Context, name string) (*ListQueryObjectsResponseQuery, error)

	// Gets a list of visualizations on a query.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListVisualizations(ctx context.Context, request ListVisualizationsForQueryRequest) listing.Iterator[Visualization]

	// Gets a list of visualizations on a query.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListVisualizationsAll(ctx context.Context, request ListVisualizationsForQueryRequest) ([]Visualization, error)

	// Gets a list of visualizations on a query.
	ListVisualizationsById(ctx context.Context, id string) (*ListVisualizationsForQueryResponse, error)

	// Updates a query.
	Update(ctx context.Context, request UpdateQueryRequest) (*Query, error)
}

func NewQueries(client *client.DatabricksClient) *QueriesAPI {
	return &QueriesAPI{
		queriesImpl: queriesImpl{
			client: client,
		},
	}
}

// The queries API can be used to perform CRUD operations on queries. A query is
// a Databricks SQL object that includes the target SQL warehouse, query text,
// name, description, tags, and parameters. Queries can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type QueriesAPI struct {
	queriesImpl
}

// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and cannot be used for alerts. You can restore a
// trashed query through the UI. A trashed query is permanently deleted after 30
// days.
func (a *QueriesAPI) DeleteById(ctx context.Context, id string) error {
	return a.queriesImpl.Delete(ctx, TrashQueryRequest{
		Id: id,
	})
}

// Gets a query.
func (a *QueriesAPI) GetById(ctx context.Context, id string) (*Query, error) {
	return a.queriesImpl.Get(ctx, GetQueryRequest{
		Id: id,
	})
}

// ListQueryObjectsResponseQueryDisplayNameToIdMap calls [QueriesAPI.ListAll] and creates a map of results with [ListQueryObjectsResponseQuery].DisplayName as key and [ListQueryObjectsResponseQuery].Id as value.
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) ListQueryObjectsResponseQueryDisplayNameToIdMap(ctx context.Context, request ListQueriesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [QueriesAPI.ListQueryObjectsResponseQueryDisplayNameToIdMap] and returns a single [ListQueryObjectsResponseQuery].
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) GetByDisplayName(ctx context.Context, name string) (*ListQueryObjectsResponseQuery, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListQueryObjectsResponseQuery{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListQueryObjectsResponseQuery named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListQueryObjectsResponseQuery named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Gets a list of visualizations on a query.
func (a *QueriesAPI) ListVisualizationsById(ctx context.Context, id string) (*ListVisualizationsForQueryResponse, error) {
	return a.queriesImpl.internalListVisualizations(ctx, ListVisualizationsForQueryRequest{
		Id: id,
	})
}

type QueriesLegacyInterface interface {

	// Creates a new query definition. Queries created with this endpoint belong to
	// the authenticated user making the request.
	//
	// The `data_source_id` field specifies the ID of the SQL warehouse to run this
	// query against. You can use the Data Sources API to see a complete list of
	// available SQL warehouses. Or you can copy the `data_source_id` from an
	// existing query.
	//
	// **Note**: You cannot add a visualization until you create the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/create instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Create(ctx context.Context, request QueryPostContent) (*LegacyQuery, error)

	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and they cannot be used for alerts. The trash is
	// deleted after 30 days.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Delete(ctx context.Context, request DeleteQueriesLegacyRequest) error

	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and they cannot be used for alerts. The trash is
	// deleted after 30 days.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	DeleteByQueryId(ctx context.Context, queryId string) error

	// Retrieve a query object definition along with contextual permissions
	// information about the currently authenticated user.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Get(ctx context.Context, request GetQueriesLegacyRequest) (*LegacyQuery, error)

	// Retrieve a query object definition along with contextual permissions
	// information about the currently authenticated user.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	GetByQueryId(ctx context.Context, queryId string) (*LegacyQuery, error)

	// Gets a list of queries. Optionally, this list can be filtered by a search
	// term.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListQueriesLegacyRequest) listing.Iterator[LegacyQuery]

	// Gets a list of queries. Optionally, this list can be filtered by a search
	// term.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListQueriesLegacyRequest) ([]LegacyQuery, error)

	// Restore a query that has been moved to the trash. A restored query appears in
	// list views and searches. You can use restored queries for alerts.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// see the latest version. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Restore(ctx context.Context, request RestoreQueriesLegacyRequest) error

	// Modify this query definition.
	//
	// **Note**: You cannot undo this operation.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/update instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Update(ctx context.Context, request QueryEditContent) (*LegacyQuery, error)
}

func NewQueriesLegacy(client *client.DatabricksClient) *QueriesLegacyAPI {
	return &QueriesLegacyAPI{
		queriesLegacyImpl: queriesLegacyImpl{
			client: client,
		},
	}
}

// These endpoints are used for CRUD operations on query definitions. Query
// definitions include the target SQL warehouse, query text, name, description,
// tags, parameters, and visualizations. Queries can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type QueriesLegacyAPI struct {
	queriesLegacyImpl
}

// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and they cannot be used for alerts. The trash is
// deleted after 30 days.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueriesLegacyAPI) DeleteByQueryId(ctx context.Context, queryId string) error {
	return a.queriesLegacyImpl.Delete(ctx, DeleteQueriesLegacyRequest{
		QueryId: queryId,
	})
}

// Retrieve a query object definition along with contextual permissions
// information about the currently authenticated user.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueriesLegacyAPI) GetByQueryId(ctx context.Context, queryId string) (*LegacyQuery, error) {
	return a.queriesLegacyImpl.Get(ctx, GetQueriesLegacyRequest{
		QueryId: queryId,
	})
}

type QueryHistoryInterface interface {

	// List the history of queries through SQL warehouses, and serverless compute.
	//
	// You can filter by user ID, warehouse ID, status, and time range. Most
	// recently started queries are returned first (up to max_results in request).
	// The pagination token returned in response can be used to list subsequent
	// query statuses.
	List(ctx context.Context, request ListQueryHistoryRequest) (*ListQueriesResponse, error)
}

func NewQueryHistory(client *client.DatabricksClient) *QueryHistoryAPI {
	return &QueryHistoryAPI{
		queryHistoryImpl: queryHistoryImpl{
			client: client,
		},
	}
}

// A service responsible for storing and retrieving the list of queries run
// against SQL endpoints and serverless compute.
type QueryHistoryAPI struct {
	queryHistoryImpl
}

type QueryVisualizationsInterface interface {

	// Adds a visualization to a query.
	Create(ctx context.Context, request CreateVisualizationRequest) (*Visualization, error)

	// Removes a visualization.
	Delete(ctx context.Context, request DeleteVisualizationRequest) error

	// Removes a visualization.
	DeleteById(ctx context.Context, id string) error

	// Updates a visualization.
	Update(ctx context.Context, request UpdateVisualizationRequest) (*Visualization, error)
}

func NewQueryVisualizations(client *client.DatabricksClient) *QueryVisualizationsAPI {
	return &QueryVisualizationsAPI{
		queryVisualizationsImpl: queryVisualizationsImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of
// visualizations from existing queries in the Databricks Workspace. Data
// structures can change over time.
type QueryVisualizationsAPI struct {
	queryVisualizationsImpl
}

// Removes a visualization.
func (a *QueryVisualizationsAPI) DeleteById(ctx context.Context, id string) error {
	return a.queryVisualizationsImpl.Delete(ctx, DeleteVisualizationRequest{
		Id: id,
	})
}

type QueryVisualizationsLegacyInterface interface {

	// Creates visualization in the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/create instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Create(ctx context.Context, request CreateQueryVisualizationsLegacyRequest) (*LegacyVisualization, error)

	// Removes a visualization from the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Delete(ctx context.Context, request DeleteQueryVisualizationsLegacyRequest) error

	// Removes a visualization from the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	DeleteById(ctx context.Context, id string) error

	// Updates visualization in the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/update instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Update(ctx context.Context, request LegacyVisualization) (*LegacyVisualization, error)
}

func NewQueryVisualizationsLegacy(client *client.DatabricksClient) *QueryVisualizationsLegacyAPI {
	return &QueryVisualizationsLegacyAPI{
		queryVisualizationsLegacyImpl: queryVisualizationsLegacyImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of
// vizualisations from existing queries within the Databricks Workspace. Data
// structures may change over time.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type QueryVisualizationsLegacyAPI struct {
	queryVisualizationsLegacyImpl
}

// Removes a visualization from the query.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queryvisualizations/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueryVisualizationsLegacyAPI) DeleteById(ctx context.Context, id string) error {
	return a.queryVisualizationsLegacyImpl.Delete(ctx, DeleteQueryVisualizationsLegacyRequest{
		Id: id,
	})
}

type RedashConfigInterface interface {

	// Read workspace configuration for Redash-v2.
	GetConfig(ctx context.Context) (*ClientConfig, error)
}

func NewRedashConfig(client *client.DatabricksClient) *RedashConfigAPI {
	return &RedashConfigAPI{
		redashConfigImpl: redashConfigImpl{
			client: client,
		},
	}
}

// Redash V2 service for workspace configurations (internal)
type RedashConfigAPI struct {
	redashConfigImpl
}

type StatementExecutionInterface interface {
	statementExecutionAPIUtilities

	// Requests that an executing statement be canceled. Callers must poll for
	// status to see the terminal state. Cancel response is empty; receiving
	// response indicates successful receipt.
	CancelExecution(ctx context.Context, request CancelExecutionRequest) error

	// Execute a SQL statement and optionally await its results for a specified
	// time.
	//
	// **Use case: small result sets with INLINE + JSON_ARRAY**
	//
	// For flows that generate small and predictable result sets (<= 25 MiB),
	// `INLINE` responses of `JSON_ARRAY` result data are typically the simplest way
	// to execute and fetch result data.
	//
	// **Use case: large result sets with EXTERNAL_LINKS**
	//
	// Using `EXTERNAL_LINKS` to fetch result data allows you to fetch large result
	// sets efficiently. The main differences from using `INLINE` disposition are
	// that the result data is accessed with URLs, and that there are 3 supported
	// formats: `JSON_ARRAY`, `ARROW_STREAM` and `CSV` compared to only `JSON_ARRAY`
	// with `INLINE`.
	//
	// ** URLs**
	//
	// External links point to data stored within your workspace's internal storage,
	// in the form of a URL. The URLs are valid for only a short period, <= 15
	// minutes. Alongside each `external_link` is an expiration field indicating the
	// time at which the URL is no longer valid. In `EXTERNAL_LINKS` mode, chunks
	// can be resolved and fetched multiple times and in parallel.
	//
	// ----
	//
	// ### **Warning: Databricks strongly recommends that you protect the URLs that
	// are returned by the `EXTERNAL_LINKS` disposition.**
	//
	// When you use the `EXTERNAL_LINKS` disposition, a short-lived, URL is
	// generated, which can be used to download the results directly from . As a
	// short-lived is embedded in this URL, you should protect the URL.
	//
	// Because URLs are already generated with embedded temporary s, you must not
	// set an `Authorization` header in the download requests.
	//
	// The `EXTERNAL_LINKS` disposition can be disabled upon request by creating a
	// support case.
	//
	// See also [Security best practices].
	//
	// ----
	//
	// StatementResponse contains `statement_id` and `status`; other fields might be
	// absent or present depending on context. If the SQL warehouse fails to execute
	// the provided statement, a 200 response is returned with `status.state` set to
	// `FAILED` (in contrast to a failure when accepting the request, which results
	// in a non-200 response). Details of the error can be found at `status.error`
	// in case of execution failures.
	//
	// [Security best practices]: https://docs.databricks.com/sql/admin/sql-execution-tutorial.html#security-best-practices
	ExecuteStatement(ctx context.Context, request ExecuteStatementRequest) (*StatementResponse, error)

	// This request can be used to poll for the statement's status.
	// StatementResponse contains `statement_id` and `status`; other fields might be
	// absent or present depending on context. When the `status.state` field is
	// `SUCCEEDED` it will also return the result manifest and the first chunk of
	// the result data. When the statement is in the terminal states `CANCELED`,
	// `CLOSED` or `FAILED`, it returns HTTP 200 with the state set. After at least
	// 12 hours in terminal state, the statement is removed from the warehouse and
	// further calls will receive an HTTP 404 response.
	//
	// **NOTE** This call currently might take up to 5 seconds to get the latest
	// status and result.
	GetStatement(ctx context.Context, request GetStatementRequest) (*StatementResponse, error)

	// This request can be used to poll for the statement's status.
	// StatementResponse contains `statement_id` and `status`; other fields might be
	// absent or present depending on context. When the `status.state` field is
	// `SUCCEEDED` it will also return the result manifest and the first chunk of
	// the result data. When the statement is in the terminal states `CANCELED`,
	// `CLOSED` or `FAILED`, it returns HTTP 200 with the state set. After at least
	// 12 hours in terminal state, the statement is removed from the warehouse and
	// further calls will receive an HTTP 404 response.
	//
	// **NOTE** This call currently might take up to 5 seconds to get the latest
	// status and result.
	GetStatementByStatementId(ctx context.Context, statementId string) (*StatementResponse, error)

	// After the statement execution has `SUCCEEDED`, this request can be used to
	// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
	// typically fetched with :method:statementexecution/executeStatement or
	// :method:statementexecution/getStatement, this request can be used to fetch
	// subsequent chunks. The response structure is identical to the nested `result`
	// element described in the :method:statementexecution/getStatement request, and
	// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
	// fields for simple iteration through the result set. Depending on
	// `disposition`, the response returns chunks of data either inline, or as
	// links.
	GetStatementResultChunkN(ctx context.Context, request GetStatementResultChunkNRequest) (*ResultData, error)

	// After the statement execution has `SUCCEEDED`, this request can be used to
	// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
	// typically fetched with :method:statementexecution/executeStatement or
	// :method:statementexecution/getStatement, this request can be used to fetch
	// subsequent chunks. The response structure is identical to the nested `result`
	// element described in the :method:statementexecution/getStatement request, and
	// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
	// fields for simple iteration through the result set. Depending on
	// `disposition`, the response returns chunks of data either inline, or as
	// links.
	GetStatementResultChunkNByStatementIdAndChunkIndex(ctx context.Context, statementId string, chunkIndex int) (*ResultData, error)
}

func NewStatementExecution(client *client.DatabricksClient) *StatementExecutionAPI {
	return &StatementExecutionAPI{
		statementExecutionImpl: statementExecutionImpl{
			client: client,
		},
	}
}

// The Databricks SQL Statement Execution API can be used to execute SQL
// statements on a SQL warehouse and fetch the result.
//
// **Getting started**
//
// We suggest beginning with the [Databricks SQL Statement Execution API
// tutorial].
//
// **Overview of statement execution and result fetching**
//
// Statement execution begins by issuing a
// :method:statementexecution/executeStatement request with a valid SQL
// statement and warehouse ID, along with optional parameters such as the data
// catalog and output format. If no other parameters are specified, the server
// will wait for up to 10s before returning a response. If the statement has
// completed within this timespan, the response will include the result data as
// a JSON array and metadata. Otherwise, if no result is available after the 10s
// timeout expired, the response will provide the statement ID that can be used
// to poll for results by using a :method:statementexecution/getStatement
// request.
//
// You can specify whether the call should behave synchronously, asynchronously
// or start synchronously with a fallback to asynchronous execution. This is
// controlled with the `wait_timeout` and `on_wait_timeout` settings. If
// `wait_timeout` is set between 5-50 seconds (default: 10s), the call waits for
// results up to the specified timeout; when set to `0s`, the call is
// asynchronous and responds immediately with a statement ID. The
// `on_wait_timeout` setting specifies what should happen when the timeout is
// reached while the statement execution has not yet finished. This can be set
// to either `CONTINUE`, to fallback to asynchronous mode, or it can be set to
// `CANCEL`, which cancels the statement.
//
// In summary: - **Synchronous mode** (`wait_timeout=30s` and
// `on_wait_timeout=CANCEL`): The call waits up to 30 seconds; if the statement
// execution finishes within this time, the result data is returned directly in
// the response. If the execution takes longer than 30 seconds, the execution is
// canceled and the call returns with a `CANCELED` state. - **Asynchronous
// mode** (`wait_timeout=0s` and `on_wait_timeout` is ignored): The call doesn't
// wait for the statement to finish but returns directly with a statement ID.
// The status of the statement execution can be polled by issuing
// :method:statementexecution/getStatement with the statement ID. Once the
// execution has succeeded, this call also returns the result and metadata in
// the response. - **[Default] Hybrid mode** (`wait_timeout=10s` and
// `on_wait_timeout=CONTINUE`): The call waits for up to 10 seconds; if the
// statement execution finishes within this time, the result data is returned
// directly in the response. If the execution takes longer than 10 seconds, a
// statement ID is returned. The statement ID can be used to fetch status and
// results in the same way as in the asynchronous mode.
//
// Depending on the size, the result can be split into multiple chunks. If the
// statement execution is successful, the statement response contains a manifest
// and the first chunk of the result. The manifest contains schema information
// and provides metadata for each chunk in the result. Result chunks can be
// retrieved by index with :method:statementexecution/getStatementResultChunkN
// which may be called in any order and in parallel. For sequential fetching,
// each chunk, apart from the last, also contains a `next_chunk_index` and
// `next_chunk_internal_link` that point to the next chunk.
//
// A statement can be canceled with :method:statementexecution/cancelExecution.
//
// **Fetching result data: format and disposition**
//
// To specify the format of the result data, use the `format` field, which can
// be set to one of the following options: `JSON_ARRAY` (JSON), `ARROW_STREAM`
// ([Apache Arrow Columnar]), or `CSV`.
//
// There are two ways to receive statement results, controlled by the
// `disposition` setting, which can be either `INLINE` or `EXTERNAL_LINKS`:
//
// - `INLINE`: In this mode, the result data is directly included in the
// response. It's best suited for smaller results. This mode can only be used
// with the `JSON_ARRAY` format.
//
// - `EXTERNAL_LINKS`: In this mode, the response provides links that can be
// used to download the result data in chunks separately. This approach is ideal
// for larger results and offers higher throughput. This mode can be used with
// all the formats: `JSON_ARRAY`, `ARROW_STREAM`, and `CSV`.
//
// By default, the API uses `format=JSON_ARRAY` and `disposition=INLINE`.
//
// **Limits and limitations**
//
// Note: The byte limit for INLINE disposition is based on internal storage
// metrics and will not exactly match the byte count of the actual payload.
//
// - Statements with `disposition=INLINE` are limited to 25 MiB and will fail
// when this limit is exceeded. - Statements with `disposition=EXTERNAL_LINKS`
// are limited to 100 GiB. Result sets larger than this limit will be truncated.
// Truncation is indicated by the `truncated` field in the result manifest. -
// The maximum query text size is 16 MiB. - Cancelation might silently fail. A
// successful response from a cancel request indicates that the cancel request
// was successfully received and sent to the processing engine. However, an
// outstanding statement might have already completed execution when the cancel
// request arrives. Polling for status until a terminal state is reached is a
// reliable way to determine the final state. - Wait timeouts are approximate,
// occur server-side, and cannot account for things such as caller delays and
// network latency from caller to service. - To guarantee that the statement is
// kept alive, you must poll at least once every 15 minutes. - The results are
// only available for one hour after success; polling does not extend this. -
// The SQL Execution API must be used for the entire lifecycle of the statement.
// For example, you cannot use the Jobs API to execute the command, and then the
// SQL Execution API to cancel it.
//
// [Apache Arrow Columnar]: https://arrow.apache.org/overview/
// [Databricks SQL Statement Execution API tutorial]: https://docs.databricks.com/sql/api/sql-execution-tutorial.html
type StatementExecutionAPI struct {
	statementExecutionImpl
}

// This request can be used to poll for the statement's status.
// StatementResponse contains `statement_id` and `status`; other fields might be
// absent or present depending on context. When the `status.state` field is
// `SUCCEEDED` it will also return the result manifest and the first chunk of
// the result data. When the statement is in the terminal states `CANCELED`,
// `CLOSED` or `FAILED`, it returns HTTP 200 with the state set. After at least
// 12 hours in terminal state, the statement is removed from the warehouse and
// further calls will receive an HTTP 404 response.
//
// **NOTE** This call currently might take up to 5 seconds to get the latest
// status and result.
func (a *StatementExecutionAPI) GetStatementByStatementId(ctx context.Context, statementId string) (*StatementResponse, error) {
	return a.statementExecutionImpl.GetStatement(ctx, GetStatementRequest{
		StatementId: statementId,
	})
}

// After the statement execution has `SUCCEEDED`, this request can be used to
// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
// typically fetched with :method:statementexecution/executeStatement or
// :method:statementexecution/getStatement, this request can be used to fetch
// subsequent chunks. The response structure is identical to the nested `result`
// element described in the :method:statementexecution/getStatement request, and
// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
// fields for simple iteration through the result set. Depending on
// `disposition`, the response returns chunks of data either inline, or as
// links.
func (a *StatementExecutionAPI) GetStatementResultChunkNByStatementIdAndChunkIndex(ctx context.Context, statementId string, chunkIndex int) (*ResultData, error) {
	return a.statementExecutionImpl.GetStatementResultChunkN(ctx, GetStatementResultChunkNRequest{
		StatementId: statementId,
		ChunkIndex:  chunkIndex,
	})
}

type WarehousesInterface interface {

	// WaitGetWarehouseRunning repeatedly calls [WarehousesAPI.Get] and waits to reach RUNNING state
	WaitGetWarehouseRunning(ctx context.Context, id string,
		timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)

	// WaitGetWarehouseStopped repeatedly calls [WarehousesAPI.Get] and waits to reach STOPPED state
	WaitGetWarehouseStopped(ctx context.Context, id string,
		timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)

	// Creates a new SQL warehouse.
	Create(ctx context.Context, createWarehouseRequest CreateWarehouseRequest) (*WaitGetWarehouseRunning[CreateWarehouseResponse], error)

	// Calls [WarehousesAPIInterface.Create] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Create].Get() or [WarehousesAPIInterface.WaitGetWarehouseRunning]
	CreateAndWait(ctx context.Context, createWarehouseRequest CreateWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Deletes a SQL warehouse.
	Delete(ctx context.Context, request DeleteWarehouseRequest) error

	// Deletes a SQL warehouse.
	DeleteById(ctx context.Context, id string) error

	// Updates the configuration for a SQL warehouse.
	Edit(ctx context.Context, editWarehouseRequest EditWarehouseRequest) (*WaitGetWarehouseRunning[struct{}], error)

	// Calls [WarehousesAPIInterface.Edit] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Edit].Get() or [WarehousesAPIInterface.WaitGetWarehouseRunning]
	EditAndWait(ctx context.Context, editWarehouseRequest EditWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Gets the information for a single SQL warehouse.
	Get(ctx context.Context, request GetWarehouseRequest) (*GetWarehouseResponse, error)

	// Gets the information for a single SQL warehouse.
	GetById(ctx context.Context, id string) (*GetWarehouseResponse, error)

	// Gets the permission levels that a user can have on an object.
	GetPermissionLevels(ctx context.Context, request GetWarehousePermissionLevelsRequest) (*GetWarehousePermissionLevelsResponse, error)

	// Gets the permission levels that a user can have on an object.
	GetPermissionLevelsByWarehouseId(ctx context.Context, warehouseId string) (*GetWarehousePermissionLevelsResponse, error)

	// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
	// permissions from their root object.
	GetPermissions(ctx context.Context, request GetWarehousePermissionsRequest) (*WarehousePermissions, error)

	// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
	// permissions from their root object.
	GetPermissionsByWarehouseId(ctx context.Context, warehouseId string) (*WarehousePermissions, error)

	// Gets the workspace level configuration that is shared by all SQL warehouses
	// in a workspace.
	GetWorkspaceWarehouseConfig(ctx context.Context) (*GetWorkspaceWarehouseConfigResponse, error)

	// Lists all SQL warehouses that a user has access to.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListWarehousesRequest) listing.Iterator[EndpointInfo]

	// Lists all SQL warehouses that a user has access to.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListWarehousesRequest) ([]EndpointInfo, error)

	// EndpointInfoNameToIdMap calls [WarehousesAPI.ListAll] and creates a map of results with [EndpointInfo].Name as key and [EndpointInfo].Id as value.
	//
	// Returns an error if there's more than one [EndpointInfo] with the same .Name.
	//
	// Note: All [EndpointInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	EndpointInfoNameToIdMap(ctx context.Context, request ListWarehousesRequest) (map[string]string, error)

	// GetByName calls [WarehousesAPI.EndpointInfoNameToIdMap] and returns a single [EndpointInfo].
	//
	// Returns an error if there's more than one [EndpointInfo] with the same .Name.
	//
	// Note: All [EndpointInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*EndpointInfo, error)

	// Sets permissions on an object, replacing existing permissions if they exist.
	// Deletes all direct permissions if none are specified. Objects can inherit
	// permissions from their root object.
	SetPermissions(ctx context.Context, request WarehousePermissionsRequest) (*WarehousePermissions, error)

	// Sets the workspace level configuration that is shared by all SQL warehouses
	// in a workspace.
	SetWorkspaceWarehouseConfig(ctx context.Context, request SetWorkspaceWarehouseConfigRequest) error

	// Starts a SQL warehouse.
	Start(ctx context.Context, startRequest StartRequest) (*WaitGetWarehouseRunning[struct{}], error)

	// Calls [WarehousesAPIInterface.Start] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Start].Get() or [WarehousesAPIInterface.WaitGetWarehouseRunning]
	StartAndWait(ctx context.Context, startRequest StartRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Stops a SQL warehouse.
	Stop(ctx context.Context, stopRequest StopRequest) (*WaitGetWarehouseStopped[struct{}], error)

	// Calls [WarehousesAPIInterface.Stop] and waits to reach STOPPED state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Stop].Get() or [WarehousesAPIInterface.WaitGetWarehouseStopped]
	StopAndWait(ctx context.Context, stopRequest StopRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Updates the permissions on a SQL warehouse. SQL warehouses can inherit
	// permissions from their root object.
	UpdatePermissions(ctx context.Context, request WarehousePermissionsRequest) (*WarehousePermissions, error)
}

func NewWarehouses(client *client.DatabricksClient) *WarehousesAPI {
	return &WarehousesAPI{
		warehousesImpl: warehousesImpl{
			client: client,
		},
	}
}

// A SQL warehouse is a compute resource that lets you run SQL commands on data
// objects within Databricks SQL. Compute resources are infrastructure resources
// that provide processing capabilities in the cloud.
type WarehousesAPI struct {
	warehousesImpl
}

// WaitGetWarehouseRunning repeatedly calls [WarehousesAPI.Get] and waits to reach RUNNING state
func (a *WarehousesAPI) WaitGetWarehouseRunning(ctx context.Context, id string,
	timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[GetWarehouseResponse](ctx, timeout, func() (*GetWarehouseResponse, *retries.Err) {
		getWarehouseResponse, err := a.Get(ctx, GetWarehouseRequest{
			Id: id,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(getWarehouseResponse)
		}
		status := getWarehouseResponse.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if getWarehouseResponse.Health != nil {
			statusMessage = getWarehouseResponse.Health.Summary
		}
		switch status {
		case StateRunning: // target state
			return getWarehouseResponse, nil
		case StateStopped, StateDeleted:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				StateRunning, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetWarehouseRunning is a wrapper that calls [WarehousesAPI.WaitGetWarehouseRunning] and waits to reach RUNNING state.
type WaitGetWarehouseRunning[R any] struct {
	Response *R
	Id       string `json:"id"`
	Poll     func(time.Duration, func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)
	callback func(*GetWarehouseResponse)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetWarehouseRunning[R]) OnProgress(callback func(*GetWarehouseResponse)) *WaitGetWarehouseRunning[R] {
	w.callback = callback
	return w
}

// Get the GetWarehouseResponse with the default timeout of 20 minutes.
func (w *WaitGetWarehouseRunning[R]) Get() (*GetWarehouseResponse, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the GetWarehouseResponse with custom timeout.
func (w *WaitGetWarehouseRunning[R]) GetWithTimeout(timeout time.Duration) (*GetWarehouseResponse, error) {
	return w.Poll(timeout, w.callback)
}

// WaitGetWarehouseStopped repeatedly calls [WarehousesAPI.Get] and waits to reach STOPPED state
func (a *WarehousesAPI) WaitGetWarehouseStopped(ctx context.Context, id string,
	timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[GetWarehouseResponse](ctx, timeout, func() (*GetWarehouseResponse, *retries.Err) {
		getWarehouseResponse, err := a.Get(ctx, GetWarehouseRequest{
			Id: id,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(getWarehouseResponse)
		}
		status := getWarehouseResponse.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if getWarehouseResponse.Health != nil {
			statusMessage = getWarehouseResponse.Health.Summary
		}
		switch status {
		case StateStopped: // target state
			return getWarehouseResponse, nil
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetWarehouseStopped is a wrapper that calls [WarehousesAPI.WaitGetWarehouseStopped] and waits to reach STOPPED state.
type WaitGetWarehouseStopped[R any] struct {
	Response *R
	Id       string `json:"id"`
	Poll     func(time.Duration, func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)
	callback func(*GetWarehouseResponse)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetWarehouseStopped[R]) OnProgress(callback func(*GetWarehouseResponse)) *WaitGetWarehouseStopped[R] {
	w.callback = callback
	return w
}

// Get the GetWarehouseResponse with the default timeout of 20 minutes.
func (w *WaitGetWarehouseStopped[R]) Get() (*GetWarehouseResponse, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the GetWarehouseResponse with custom timeout.
func (w *WaitGetWarehouseStopped[R]) GetWithTimeout(timeout time.Duration) (*GetWarehouseResponse, error) {
	return w.Poll(timeout, w.callback)
}

// Creates a new SQL warehouse.
func (a *WarehousesAPI) Create(ctx context.Context, createWarehouseRequest CreateWarehouseRequest) (*WaitGetWarehouseRunning[CreateWarehouseResponse], error) {
	createWarehouseResponse, err := a.warehousesImpl.Create(ctx, createWarehouseRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[CreateWarehouseResponse]{
		Response: createWarehouseResponse,
		Id:       createWarehouseResponse.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, createWarehouseResponse.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Create] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Create].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) CreateAndWait(ctx context.Context, createWarehouseRequest CreateWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Create(ctx, createWarehouseRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Deletes a SQL warehouse.
func (a *WarehousesAPI) DeleteById(ctx context.Context, id string) error {
	return a.warehousesImpl.Delete(ctx, DeleteWarehouseRequest{
		Id: id,
	})
}

// Updates the configuration for a SQL warehouse.
func (a *WarehousesAPI) Edit(ctx context.Context, editWarehouseRequest EditWarehouseRequest) (*WaitGetWarehouseRunning[struct{}], error) {
	err := a.warehousesImpl.Edit(ctx, editWarehouseRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[struct{}]{

		Id: editWarehouseRequest.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, editWarehouseRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Edit] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Edit].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) EditAndWait(ctx context.Context, editWarehouseRequest EditWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Edit(ctx, editWarehouseRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Gets the information for a single SQL warehouse.
func (a *WarehousesAPI) GetById(ctx context.Context, id string) (*GetWarehouseResponse, error) {
	return a.warehousesImpl.Get(ctx, GetWarehouseRequest{
		Id: id,
	})
}

// Gets the permission levels that a user can have on an object.
func (a *WarehousesAPI) GetPermissionLevelsByWarehouseId(ctx context.Context, warehouseId string) (*GetWarehousePermissionLevelsResponse, error) {
	return a.warehousesImpl.GetPermissionLevels(ctx, GetWarehousePermissionLevelsRequest{
		WarehouseId: warehouseId,
	})
}

// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
// permissions from their root object.
func (a *WarehousesAPI) GetPermissionsByWarehouseId(ctx context.Context, warehouseId string) (*WarehousePermissions, error) {
	return a.warehousesImpl.GetPermissions(ctx, GetWarehousePermissionsRequest{
		WarehouseId: warehouseId,
	})
}

// EndpointInfoNameToIdMap calls [WarehousesAPI.ListAll] and creates a map of results with [EndpointInfo].Name as key and [EndpointInfo].Id as value.
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) EndpointInfoNameToIdMap(ctx context.Context, request ListWarehousesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [WarehousesAPI.EndpointInfoNameToIdMap] and returns a single [EndpointInfo].
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) GetByName(ctx context.Context, name string) (*EndpointInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListWarehousesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]EndpointInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("EndpointInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of EndpointInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Starts a SQL warehouse.
func (a *WarehousesAPI) Start(ctx context.Context, startRequest StartRequest) (*WaitGetWarehouseRunning[struct{}], error) {
	err := a.warehousesImpl.Start(ctx, startRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[struct{}]{

		Id: startRequest.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, startRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Start] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Start].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) StartAndWait(ctx context.Context, startRequest StartRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Start(ctx, startRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Stops a SQL warehouse.
func (a *WarehousesAPI) Stop(ctx context.Context, stopRequest StopRequest) (*WaitGetWarehouseStopped[struct{}], error) {
	err := a.warehousesImpl.Stop(ctx, stopRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseStopped[struct{}]{

		Id: stopRequest.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseStopped(ctx, stopRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Stop] and waits to reach STOPPED state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Stop].Get() or [WarehousesAPI.WaitGetWarehouseStopped]
func (a *WarehousesAPI) StopAndWait(ctx context.Context, stopRequest StopRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Stop(ctx, stopRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}
