// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Alerts, Alerts Legacy, Dashboard Widgets, Dashboards, Data Sources, Dbsql Permissions, Queries, Queries Legacy, Query History, Query Visualizations, Query Visualizations Legacy, Redash Config, Statement Execution, Warehouses, etc.
package sql

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AlertsInterface interface {

	// Create an alert.
	//
	// Creates an alert.
	Create(ctx context.Context, request CreateAlertRequest) (*Alert, error)

	// Delete an alert.
	//
	// Moves an alert to the trash. Trashed alerts immediately disappear from
	// searches and list views, and can no longer trigger. You can restore a trashed
	// alert through the UI. A trashed alert is permanently deleted after 30 days.
	Delete(ctx context.Context, request TrashAlertRequest) error

	// Delete an alert.
	//
	// Moves an alert to the trash. Trashed alerts immediately disappear from
	// searches and list views, and can no longer trigger. You can restore a trashed
	// alert through the UI. A trashed alert is permanently deleted after 30 days.
	DeleteById(ctx context.Context, id string) error

	// Get an alert.
	//
	// Gets an alert.
	Get(ctx context.Context, request GetAlertRequest) (*Alert, error)

	// Get an alert.
	//
	// Gets an alert.
	GetById(ctx context.Context, id string) (*Alert, error)

	// List alerts.
	//
	// Gets a list of alerts accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAlertsRequest) listing.Iterator[ListAlertsResponseAlert]

	// List alerts.
	//
	// Gets a list of alerts accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAlertsRequest) ([]ListAlertsResponseAlert, error)

	// ListAlertsResponseAlertDisplayNameToIdMap calls [AlertsAPI.ListAll] and creates a map of results with [ListAlertsResponseAlert].DisplayName as key and [ListAlertsResponseAlert].Id as value.
	//
	// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
	//
	// Note: All [ListAlertsResponseAlert] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAlertsResponseAlertDisplayNameToIdMap(ctx context.Context, request ListAlertsRequest) (map[string]string, error)

	// GetByDisplayName calls [AlertsAPI.ListAlertsResponseAlertDisplayNameToIdMap] and returns a single [ListAlertsResponseAlert].
	//
	// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
	//
	// Note: All [ListAlertsResponseAlert] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByDisplayName(ctx context.Context, name string) (*ListAlertsResponseAlert, error)

	// Update an alert.
	//
	// Updates an alert.
	Update(ctx context.Context, request UpdateAlertRequest) (*Alert, error)
}

func NewAlerts(client *client.DatabricksClient) *AlertsAPI {
	return &AlertsAPI{
		alertsImpl: alertsImpl{
			client: client,
		},
	}
}

// The alerts API can be used to perform CRUD operations on alerts. An alert is
// a Databricks SQL object that periodically runs a query, evaluates a condition
// of its result, and notifies one or more users and/or notification
// destinations if the condition was met. Alerts can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type AlertsAPI struct {
	alertsImpl
}

// Delete an alert.
//
// Moves an alert to the trash. Trashed alerts immediately disappear from
// searches and list views, and can no longer trigger. You can restore a trashed
// alert through the UI. A trashed alert is permanently deleted after 30 days.
func (a *AlertsAPI) DeleteById(ctx context.Context, id string) error {
	return a.alertsImpl.Delete(ctx, TrashAlertRequest{
		Id: id,
	})
}

// Get an alert.
//
// Gets an alert.
func (a *AlertsAPI) GetById(ctx context.Context, id string) (*Alert, error) {
	return a.alertsImpl.Get(ctx, GetAlertRequest{
		Id: id,
	})
}

// ListAlertsResponseAlertDisplayNameToIdMap calls [AlertsAPI.ListAll] and creates a map of results with [ListAlertsResponseAlert].DisplayName as key and [ListAlertsResponseAlert].Id as value.
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) ListAlertsResponseAlertDisplayNameToIdMap(ctx context.Context, request ListAlertsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [AlertsAPI.ListAlertsResponseAlertDisplayNameToIdMap] and returns a single [ListAlertsResponseAlert].
//
// Returns an error if there's more than one [ListAlertsResponseAlert] with the same .DisplayName.
//
// Note: All [ListAlertsResponseAlert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) GetByDisplayName(ctx context.Context, name string) (*ListAlertsResponseAlert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListAlertsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListAlertsResponseAlert{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListAlertsResponseAlert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListAlertsResponseAlert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type AlertsLegacyInterface interface {

	// Create an alert.
	//
	// Creates an alert. An alert is a Databricks SQL object that periodically runs
	// a query, evaluates a condition of its result, and notifies users or
	// notification destinations if the condition was met.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/create instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Create(ctx context.Context, request CreateAlert) (*LegacyAlert, error)

	// Delete an alert.
	//
	// Deletes an alert. Deleted alerts are no longer accessible and cannot be
	// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
	// the trash.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Delete(ctx context.Context, request DeleteAlertsLegacyRequest) error

	// Delete an alert.
	//
	// Deletes an alert. Deleted alerts are no longer accessible and cannot be
	// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
	// the trash.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	DeleteByAlertId(ctx context.Context, alertId string) error

	// Get an alert.
	//
	// Gets an alert.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Get(ctx context.Context, request GetAlertsLegacyRequest) (*LegacyAlert, error)

	// Get an alert.
	//
	// Gets an alert.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	GetByAlertId(ctx context.Context, alertId string) (*LegacyAlert, error)

	// Get alerts.
	//
	// Gets a list of alerts.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	List(ctx context.Context) ([]LegacyAlert, error)

	// LegacyAlertNameToIdMap calls [AlertsLegacyAPI.List] and creates a map of results with [LegacyAlert].Name as key and [LegacyAlert].Id as value.
	//
	// Returns an error if there's more than one [LegacyAlert] with the same .Name.
	//
	// Note: All [LegacyAlert] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	LegacyAlertNameToIdMap(ctx context.Context) (map[string]string, error)

	// GetByName calls [AlertsLegacyAPI.LegacyAlertNameToIdMap] and returns a single [LegacyAlert].
	//
	// Returns an error if there's more than one [LegacyAlert] with the same .Name.
	//
	// Note: All [LegacyAlert] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*LegacyAlert, error)

	// Update an alert.
	//
	// Updates an alert.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:alerts/update instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Update(ctx context.Context, request EditAlert) error
}

func NewAlertsLegacy(client *client.DatabricksClient) *AlertsLegacyAPI {
	return &AlertsLegacyAPI{
		alertsLegacyImpl: alertsLegacyImpl{
			client: client,
		},
	}
}

// The alerts API can be used to perform CRUD operations on alerts. An alert is
// a Databricks SQL object that periodically runs a query, evaluates a condition
// of its result, and notifies one or more users and/or notification
// destinations if the condition was met. Alerts can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type AlertsLegacyAPI struct {
	alertsLegacyImpl
}

// Delete an alert.
//
// Deletes an alert. Deleted alerts are no longer accessible and cannot be
// restored. **Note**: Unlike queries and dashboards, alerts cannot be moved to
// the trash.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *AlertsLegacyAPI) DeleteByAlertId(ctx context.Context, alertId string) error {
	return a.alertsLegacyImpl.Delete(ctx, DeleteAlertsLegacyRequest{
		AlertId: alertId,
	})
}

// Get an alert.
//
// Gets an alert.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:alerts/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *AlertsLegacyAPI) GetByAlertId(ctx context.Context, alertId string) (*LegacyAlert, error) {
	return a.alertsLegacyImpl.Get(ctx, GetAlertsLegacyRequest{
		AlertId: alertId,
	})
}

// LegacyAlertNameToIdMap calls [AlertsLegacyAPI.List] and creates a map of results with [LegacyAlert].Name as key and [LegacyAlert].Id as value.
//
// Returns an error if there's more than one [LegacyAlert] with the same .Name.
//
// Note: All [LegacyAlert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsLegacyAPI) LegacyAlertNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [AlertsLegacyAPI.LegacyAlertNameToIdMap] and returns a single [LegacyAlert].
//
// Returns an error if there's more than one [LegacyAlert] with the same .Name.
//
// Note: All [LegacyAlert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsLegacyAPI) GetByName(ctx context.Context, name string) (*LegacyAlert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]LegacyAlert{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("LegacyAlert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of LegacyAlert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type DashboardWidgetsInterface interface {

	// Add widget to a dashboard.
	Create(ctx context.Context, request CreateWidget) (*Widget, error)

	// Remove widget.
	Delete(ctx context.Context, request DeleteDashboardWidgetRequest) error

	// Remove widget.
	DeleteById(ctx context.Context, id string) error

	// Update existing widget.
	Update(ctx context.Context, request CreateWidget) (*Widget, error)
}

func NewDashboardWidgets(client *client.DatabricksClient) *DashboardWidgetsAPI {
	return &DashboardWidgetsAPI{
		dashboardWidgetsImpl: dashboardWidgetsImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of widgets
// from existing dashboards within the Databricks Workspace. Data structures may
// change over time.
type DashboardWidgetsAPI struct {
	dashboardWidgetsImpl
}

// Remove widget.
func (a *DashboardWidgetsAPI) DeleteById(ctx context.Context, id string) error {
	return a.dashboardWidgetsImpl.Delete(ctx, DeleteDashboardWidgetRequest{
		Id: id,
	})
}

type DashboardsInterface interface {

	// Create a dashboard object.
	Create(ctx context.Context, request DashboardPostContent) (*Dashboard, error)

	// Remove a dashboard.
	//
	// Moves a dashboard to the trash. Trashed dashboards do not appear in list
	// views or searches, and cannot be shared.
	Delete(ctx context.Context, request DeleteDashboardRequest) error

	// Remove a dashboard.
	//
	// Moves a dashboard to the trash. Trashed dashboards do not appear in list
	// views or searches, and cannot be shared.
	DeleteByDashboardId(ctx context.Context, dashboardId string) error

	// Retrieve a definition.
	//
	// Returns a JSON representation of a dashboard object, including its
	// visualization and query objects.
	Get(ctx context.Context, request GetDashboardRequest) (*Dashboard, error)

	// Retrieve a definition.
	//
	// Returns a JSON representation of a dashboard object, including its
	// visualization and query objects.
	GetByDashboardId(ctx context.Context, dashboardId string) (*Dashboard, error)

	// Get dashboard objects.
	//
	// Fetch a paginated list of dashboard objects.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListDashboardsRequest) listing.Iterator[Dashboard]

	// Get dashboard objects.
	//
	// Fetch a paginated list of dashboard objects.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListDashboardsRequest) ([]Dashboard, error)

	// DashboardNameToIdMap calls [DashboardsAPI.ListAll] and creates a map of results with [Dashboard].Name as key and [Dashboard].Id as value.
	//
	// Returns an error if there's more than one [Dashboard] with the same .Name.
	//
	// Note: All [Dashboard] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	DashboardNameToIdMap(ctx context.Context, request ListDashboardsRequest) (map[string]string, error)

	// GetByName calls [DashboardsAPI.DashboardNameToIdMap] and returns a single [Dashboard].
	//
	// Returns an error if there's more than one [Dashboard] with the same .Name.
	//
	// Note: All [Dashboard] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*Dashboard, error)

	// Restore a dashboard.
	//
	// A restored dashboard appears in list views and searches and can be shared.
	Restore(ctx context.Context, request RestoreDashboardRequest) error

	// Change a dashboard definition.
	//
	// Modify this dashboard definition. This operation only affects attributes of
	// the dashboard object. It does not add, modify, or remove widgets.
	//
	// **Note**: You cannot undo this operation.
	Update(ctx context.Context, request DashboardEditContent) (*Dashboard, error)
}

func NewDashboards(client *client.DatabricksClient) *DashboardsAPI {
	return &DashboardsAPI{
		dashboardsImpl: dashboardsImpl{
			client: client,
		},
	}
}

// In general, there is little need to modify dashboards using the API. However,
// it can be useful to use dashboard objects to look-up a collection of related
// query IDs. The API can also be used to duplicate multiple dashboards at once
// since you can get a dashboard definition with a GET request and then POST it
// to create a new one. Dashboards can be scheduled using the `sql_task` type of
// the Jobs API, e.g. :method:jobs/create.
type DashboardsAPI struct {
	dashboardsImpl
}

// Remove a dashboard.
//
// Moves a dashboard to the trash. Trashed dashboards do not appear in list
// views or searches, and cannot be shared.
func (a *DashboardsAPI) DeleteByDashboardId(ctx context.Context, dashboardId string) error {
	return a.dashboardsImpl.Delete(ctx, DeleteDashboardRequest{
		DashboardId: dashboardId,
	})
}

// Retrieve a definition.
//
// Returns a JSON representation of a dashboard object, including its
// visualization and query objects.
func (a *DashboardsAPI) GetByDashboardId(ctx context.Context, dashboardId string) (*Dashboard, error) {
	return a.dashboardsImpl.Get(ctx, GetDashboardRequest{
		DashboardId: dashboardId,
	})
}

// DashboardNameToIdMap calls [DashboardsAPI.ListAll] and creates a map of results with [Dashboard].Name as key and [Dashboard].Id as value.
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DashboardsAPI) DashboardNameToIdMap(ctx context.Context, request ListDashboardsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [DashboardsAPI.DashboardNameToIdMap] and returns a single [Dashboard].
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DashboardsAPI) GetByName(ctx context.Context, name string) (*Dashboard, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListDashboardsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Dashboard{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Dashboard named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Dashboard named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type DataSourcesInterface interface {

	// Get a list of SQL warehouses.
	//
	// Retrieves a full list of SQL warehouses available in this workspace. All
	// fields that appear in this API response are enumerated for clarity. However,
	// you need only a SQL warehouse's `id` to create new queries against it.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:warehouses/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	List(ctx context.Context) ([]DataSource, error)

	// DataSourceNameToIdMap calls [DataSourcesAPI.List] and creates a map of results with [DataSource].Name as key and [DataSource].Id as value.
	//
	// Returns an error if there's more than one [DataSource] with the same .Name.
	//
	// Note: All [DataSource] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	DataSourceNameToIdMap(ctx context.Context) (map[string]string, error)

	// GetByName calls [DataSourcesAPI.DataSourceNameToIdMap] and returns a single [DataSource].
	//
	// Returns an error if there's more than one [DataSource] with the same .Name.
	//
	// Note: All [DataSource] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*DataSource, error)
}

func NewDataSources(client *client.DatabricksClient) *DataSourcesAPI {
	return &DataSourcesAPI{
		dataSourcesImpl: dataSourcesImpl{
			client: client,
		},
	}
}

// This API is provided to assist you in making new query objects. When creating
// a query object, you may optionally specify a `data_source_id` for the SQL
// warehouse against which it will run. If you don't already know the
// `data_source_id` for your desired SQL warehouse, this API will help you find
// it.
//
// This API does not support searches. It returns the full list of SQL
// warehouses in your workspace. We advise you to use any text editor, REST
// client, or `grep` to search the response from this API for the name of your
// SQL warehouse as it appears in Databricks SQL.
//
// **Note**: A new version of the Databricks SQL API is now available. [Learn
// more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type DataSourcesAPI struct {
	dataSourcesImpl
}

// DataSourceNameToIdMap calls [DataSourcesAPI.List] and creates a map of results with [DataSource].Name as key and [DataSource].Id as value.
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DataSourcesAPI) DataSourceNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [DataSourcesAPI.DataSourceNameToIdMap] and returns a single [DataSource].
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DataSourcesAPI) GetByName(ctx context.Context, name string) (*DataSource, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]DataSource{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("DataSource named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of DataSource named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type DbsqlPermissionsInterface interface {

	// Get object ACL.
	//
	// Gets a JSON representation of the access control list (ACL) for a specified
	// object.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:workspace/getpermissions instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Get(ctx context.Context, request GetDbsqlPermissionRequest) (*GetResponse, error)

	// Get object ACL.
	//
	// Gets a JSON representation of the access control list (ACL) for a specified
	// object.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:workspace/getpermissions instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	GetByObjectTypeAndObjectId(ctx context.Context, objectType ObjectTypePlural, objectId string) (*GetResponse, error)

	// Set object ACL.
	//
	// Sets the access control list (ACL) for a specified object. This operation
	// will complete rewrite the ACL.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:workspace/setpermissions instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Set(ctx context.Context, request SetRequest) (*SetResponse, error)

	// Transfer object ownership.
	//
	// Transfers ownership of a dashboard, query, or alert to an active user.
	// Requires an admin API key.
	//
	// **Note**: A new version of the Databricks SQL API is now available. For
	// queries and alerts, please use :method:queries/update and
	// :method:alerts/update respectively instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	TransferOwnership(ctx context.Context, request TransferOwnershipRequest) (*Success, error)
}

func NewDbsqlPermissions(client *client.DatabricksClient) *DbsqlPermissionsAPI {
	return &DbsqlPermissionsAPI{
		dbsqlPermissionsImpl: dbsqlPermissionsImpl{
			client: client,
		},
	}
}

// The SQL Permissions API is similar to the endpoints of the
// :method:permissions/set. However, this exposes only one endpoint, which gets
// the Access Control List for a given object. You cannot modify any permissions
// using this API.
//
// There are three levels of permission:
//
// - `CAN_VIEW`: Allows read-only access
//
// - `CAN_RUN`: Allows read access and run access (superset of `CAN_VIEW`)
//
// - `CAN_MANAGE`: Allows all actions: read, run, edit, delete, modify
// permissions (superset of `CAN_RUN`)
//
// **Note**: A new version of the Databricks SQL API is now available. [Learn
// more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type DbsqlPermissionsAPI struct {
	dbsqlPermissionsImpl
}

// Get object ACL.
//
// Gets a JSON representation of the access control list (ACL) for a specified
// object.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:workspace/getpermissions instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *DbsqlPermissionsAPI) GetByObjectTypeAndObjectId(ctx context.Context, objectType ObjectTypePlural, objectId string) (*GetResponse, error) {
	return a.dbsqlPermissionsImpl.Get(ctx, GetDbsqlPermissionRequest{
		ObjectType: objectType,
		ObjectId:   objectId,
	})
}

type QueriesInterface interface {

	// Create a query.
	//
	// Creates a query.
	Create(ctx context.Context, request CreateQueryRequest) (*Query, error)

	// Delete a query.
	//
	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and cannot be used for alerts. You can restore a
	// trashed query through the UI. A trashed query is permanently deleted after 30
	// days.
	Delete(ctx context.Context, request TrashQueryRequest) error

	// Delete a query.
	//
	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and cannot be used for alerts. You can restore a
	// trashed query through the UI. A trashed query is permanently deleted after 30
	// days.
	DeleteById(ctx context.Context, id string) error

	// Get a query.
	//
	// Gets a query.
	Get(ctx context.Context, request GetQueryRequest) (*Query, error)

	// Get a query.
	//
	// Gets a query.
	GetById(ctx context.Context, id string) (*Query, error)

	// List queries.
	//
	// Gets a list of queries accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListQueriesRequest) listing.Iterator[ListQueryObjectsResponseQuery]

	// List queries.
	//
	// Gets a list of queries accessible to the user, ordered by creation time.
	// **Warning:** Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListQueriesRequest) ([]ListQueryObjectsResponseQuery, error)

	// ListQueryObjectsResponseQueryDisplayNameToIdMap calls [QueriesAPI.ListAll] and creates a map of results with [ListQueryObjectsResponseQuery].DisplayName as key and [ListQueryObjectsResponseQuery].Id as value.
	//
	// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
	//
	// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListQueryObjectsResponseQueryDisplayNameToIdMap(ctx context.Context, request ListQueriesRequest) (map[string]string, error)

	// GetByDisplayName calls [QueriesAPI.ListQueryObjectsResponseQueryDisplayNameToIdMap] and returns a single [ListQueryObjectsResponseQuery].
	//
	// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
	//
	// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByDisplayName(ctx context.Context, name string) (*ListQueryObjectsResponseQuery, error)

	// List visualizations on a query.
	//
	// Gets a list of visualizations on a query.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListVisualizations(ctx context.Context, request ListVisualizationsForQueryRequest) listing.Iterator[Visualization]

	// List visualizations on a query.
	//
	// Gets a list of visualizations on a query.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListVisualizationsAll(ctx context.Context, request ListVisualizationsForQueryRequest) ([]Visualization, error)

	// List visualizations on a query.
	//
	// Gets a list of visualizations on a query.
	ListVisualizationsById(ctx context.Context, id string) (*ListVisualizationsForQueryResponse, error)

	// Update a query.
	//
	// Updates a query.
	Update(ctx context.Context, request UpdateQueryRequest) (*Query, error)
}

func NewQueries(client *client.DatabricksClient) *QueriesAPI {
	return &QueriesAPI{
		queriesImpl: queriesImpl{
			client: client,
		},
	}
}

// The queries API can be used to perform CRUD operations on queries. A query is
// a Databricks SQL object that includes the target SQL warehouse, query text,
// name, description, tags, and parameters. Queries can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type QueriesAPI struct {
	queriesImpl
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and cannot be used for alerts. You can restore a
// trashed query through the UI. A trashed query is permanently deleted after 30
// days.
func (a *QueriesAPI) DeleteById(ctx context.Context, id string) error {
	return a.queriesImpl.Delete(ctx, TrashQueryRequest{
		Id: id,
	})
}

// Get a query.
//
// Gets a query.
func (a *QueriesAPI) GetById(ctx context.Context, id string) (*Query, error) {
	return a.queriesImpl.Get(ctx, GetQueryRequest{
		Id: id,
	})
}

// ListQueryObjectsResponseQueryDisplayNameToIdMap calls [QueriesAPI.ListAll] and creates a map of results with [ListQueryObjectsResponseQuery].DisplayName as key and [ListQueryObjectsResponseQuery].Id as value.
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) ListQueryObjectsResponseQueryDisplayNameToIdMap(ctx context.Context, request ListQueriesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.DisplayName
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .DisplayName: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByDisplayName calls [QueriesAPI.ListQueryObjectsResponseQueryDisplayNameToIdMap] and returns a single [ListQueryObjectsResponseQuery].
//
// Returns an error if there's more than one [ListQueryObjectsResponseQuery] with the same .DisplayName.
//
// Note: All [ListQueryObjectsResponseQuery] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) GetByDisplayName(ctx context.Context, name string) (*ListQueryObjectsResponseQuery, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]ListQueryObjectsResponseQuery{}
	for _, v := range result {
		key := v.DisplayName
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("ListQueryObjectsResponseQuery named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of ListQueryObjectsResponseQuery named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// List visualizations on a query.
//
// Gets a list of visualizations on a query.
func (a *QueriesAPI) ListVisualizationsById(ctx context.Context, id string) (*ListVisualizationsForQueryResponse, error) {
	return a.queriesImpl.internalListVisualizations(ctx, ListVisualizationsForQueryRequest{
		Id: id,
	})
}

type QueriesLegacyInterface interface {

	// Create a new query definition.
	//
	// Creates a new query definition. Queries created with this endpoint belong to
	// the authenticated user making the request.
	//
	// The `data_source_id` field specifies the ID of the SQL warehouse to run this
	// query against. You can use the Data Sources API to see a complete list of
	// available SQL warehouses. Or you can copy the `data_source_id` from an
	// existing query.
	//
	// **Note**: You cannot add a visualization until you create the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/create instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Create(ctx context.Context, request QueryPostContent) (*LegacyQuery, error)

	// Delete a query.
	//
	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and they cannot be used for alerts. The trash is
	// deleted after 30 days.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Delete(ctx context.Context, request DeleteQueriesLegacyRequest) error

	// Delete a query.
	//
	// Moves a query to the trash. Trashed queries immediately disappear from
	// searches and list views, and they cannot be used for alerts. The trash is
	// deleted after 30 days.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	DeleteByQueryId(ctx context.Context, queryId string) error

	// Get a query definition.
	//
	// Retrieve a query object definition along with contextual permissions
	// information about the currently authenticated user.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Get(ctx context.Context, request GetQueriesLegacyRequest) (*LegacyQuery, error)

	// Get a query definition.
	//
	// Retrieve a query object definition along with contextual permissions
	// information about the currently authenticated user.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/get instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	GetByQueryId(ctx context.Context, queryId string) (*LegacyQuery, error)

	// Get a list of queries.
	//
	// Gets a list of queries. Optionally, this list can be filtered by a search
	// term.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListQueriesLegacyRequest) listing.Iterator[LegacyQuery]

	// Get a list of queries.
	//
	// Gets a list of queries. Optionally, this list can be filtered by a search
	// term.
	//
	// **Warning**: Calling this API concurrently 10 or more times could result in
	// throttling, service degradation, or a temporary ban.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/list instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListQueriesLegacyRequest) ([]LegacyQuery, error)

	// LegacyQueryNameToIdMap calls [QueriesLegacyAPI.ListAll] and creates a map of results with [LegacyQuery].Name as key and [LegacyQuery].Id as value.
	//
	// Returns an error if there's more than one [LegacyQuery] with the same .Name.
	//
	// Note: All [LegacyQuery] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	LegacyQueryNameToIdMap(ctx context.Context, request ListQueriesLegacyRequest) (map[string]string, error)

	// GetByName calls [QueriesLegacyAPI.LegacyQueryNameToIdMap] and returns a single [LegacyQuery].
	//
	// Returns an error if there's more than one [LegacyQuery] with the same .Name.
	//
	// Note: All [LegacyQuery] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*LegacyQuery, error)

	// Restore a query.
	//
	// Restore a query that has been moved to the trash. A restored query appears in
	// list views and searches. You can use restored queries for alerts.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// see the latest version. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Restore(ctx context.Context, request RestoreQueriesLegacyRequest) error

	// Change a query definition.
	//
	// Modify this query definition.
	//
	// **Note**: You cannot undo this operation.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queries/update instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Update(ctx context.Context, request QueryEditContent) (*LegacyQuery, error)
}

func NewQueriesLegacy(client *client.DatabricksClient) *QueriesLegacyAPI {
	return &QueriesLegacyAPI{
		queriesLegacyImpl: queriesLegacyImpl{
			client: client,
		},
	}
}

// These endpoints are used for CRUD operations on query definitions. Query
// definitions include the target SQL warehouse, query text, name, description,
// tags, parameters, and visualizations. Queries can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type QueriesLegacyAPI struct {
	queriesLegacyImpl
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and they cannot be used for alerts. The trash is
// deleted after 30 days.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueriesLegacyAPI) DeleteByQueryId(ctx context.Context, queryId string) error {
	return a.queriesLegacyImpl.Delete(ctx, DeleteQueriesLegacyRequest{
		QueryId: queryId,
	})
}

// Get a query definition.
//
// Retrieve a query object definition along with contextual permissions
// information about the currently authenticated user.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queries/get instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueriesLegacyAPI) GetByQueryId(ctx context.Context, queryId string) (*LegacyQuery, error) {
	return a.queriesLegacyImpl.Get(ctx, GetQueriesLegacyRequest{
		QueryId: queryId,
	})
}

// LegacyQueryNameToIdMap calls [QueriesLegacyAPI.ListAll] and creates a map of results with [LegacyQuery].Name as key and [LegacyQuery].Id as value.
//
// Returns an error if there's more than one [LegacyQuery] with the same .Name.
//
// Note: All [LegacyQuery] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesLegacyAPI) LegacyQueryNameToIdMap(ctx context.Context, request ListQueriesLegacyRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [QueriesLegacyAPI.LegacyQueryNameToIdMap] and returns a single [LegacyQuery].
//
// Returns an error if there's more than one [LegacyQuery] with the same .Name.
//
// Note: All [LegacyQuery] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesLegacyAPI) GetByName(ctx context.Context, name string) (*LegacyQuery, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesLegacyRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]LegacyQuery{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("LegacyQuery named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of LegacyQuery named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type QueryHistoryInterface interface {

	// List Queries.
	//
	// List the history of queries through SQL warehouses, and serverless compute.
	//
	// You can filter by user ID, warehouse ID, status, and time range. Most
	// recently started queries are returned first (up to max_results in request).
	// The pagination token returned in response can be used to list subsequent
	// query statuses.
	List(ctx context.Context, request ListQueryHistoryRequest) (*ListQueriesResponse, error)
}

func NewQueryHistory(client *client.DatabricksClient) *QueryHistoryAPI {
	return &QueryHistoryAPI{
		queryHistoryImpl: queryHistoryImpl{
			client: client,
		},
	}
}

// A service responsible for storing and retrieving the list of queries run
// against SQL endpoints and serverless compute.
type QueryHistoryAPI struct {
	queryHistoryImpl
}

type QueryVisualizationsInterface interface {

	// Add a visualization to a query.
	//
	// Adds a visualization to a query.
	Create(ctx context.Context, request CreateVisualizationRequest) (*Visualization, error)

	// Remove a visualization.
	//
	// Removes a visualization.
	Delete(ctx context.Context, request DeleteVisualizationRequest) error

	// Remove a visualization.
	//
	// Removes a visualization.
	DeleteById(ctx context.Context, id string) error

	// Update a visualization.
	//
	// Updates a visualization.
	Update(ctx context.Context, request UpdateVisualizationRequest) (*Visualization, error)
}

func NewQueryVisualizations(client *client.DatabricksClient) *QueryVisualizationsAPI {
	return &QueryVisualizationsAPI{
		queryVisualizationsImpl: queryVisualizationsImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of
// visualizations from existing queries in the Databricks Workspace. Data
// structures can change over time.
type QueryVisualizationsAPI struct {
	queryVisualizationsImpl
}

// Remove a visualization.
//
// Removes a visualization.
func (a *QueryVisualizationsAPI) DeleteById(ctx context.Context, id string) error {
	return a.queryVisualizationsImpl.Delete(ctx, DeleteVisualizationRequest{
		Id: id,
	})
}

type QueryVisualizationsLegacyInterface interface {

	// Add visualization to a query.
	//
	// Creates visualization in the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/create instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Create(ctx context.Context, request CreateQueryVisualizationsLegacyRequest) (*LegacyVisualization, error)

	// Remove visualization.
	//
	// Removes a visualization from the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Delete(ctx context.Context, request DeleteQueryVisualizationsLegacyRequest) error

	// Remove visualization.
	//
	// Removes a visualization from the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/delete instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	DeleteById(ctx context.Context, id string) error

	// Edit existing visualization.
	//
	// Updates visualization in the query.
	//
	// **Note**: A new version of the Databricks SQL API is now available. Please
	// use :method:queryvisualizations/update instead. [Learn more]
	//
	// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
	Update(ctx context.Context, request LegacyVisualization) (*LegacyVisualization, error)
}

func NewQueryVisualizationsLegacy(client *client.DatabricksClient) *QueryVisualizationsLegacyAPI {
	return &QueryVisualizationsLegacyAPI{
		queryVisualizationsLegacyImpl: queryVisualizationsLegacyImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of
// vizualisations from existing queries within the Databricks Workspace. Data
// structures may change over time.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// see the latest version. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
type QueryVisualizationsLegacyAPI struct {
	queryVisualizationsLegacyImpl
}

// Remove visualization.
//
// Removes a visualization from the query.
//
// **Note**: A new version of the Databricks SQL API is now available. Please
// use :method:queryvisualizations/delete instead. [Learn more]
//
// [Learn more]: https://docs.databricks.com/en/sql/dbsql-api-latest.html
func (a *QueryVisualizationsLegacyAPI) DeleteById(ctx context.Context, id string) error {
	return a.queryVisualizationsLegacyImpl.Delete(ctx, DeleteQueryVisualizationsLegacyRequest{
		Id: id,
	})
}

type RedashConfigInterface interface {

	// Read workspace configuration for Redash-v2.
	GetConfig(ctx context.Context) (*ClientConfig, error)
}

func NewRedashConfig(client *client.DatabricksClient) *RedashConfigAPI {
	return &RedashConfigAPI{
		redashConfigImpl: redashConfigImpl{
			client: client,
		},
	}
}

// Redash V2 service for workspace configurations (internal)
type RedashConfigAPI struct {
	redashConfigImpl
}

type StatementExecutionInterface interface {
	statementExecutionAPIUtilities

	// Cancel statement execution.
	//
	// Requests that an executing statement be canceled. Callers must poll for
	// status to see the terminal state.
	CancelExecution(ctx context.Context, request CancelExecutionRequest) error

	// Execute a SQL statement.
	ExecuteStatement(ctx context.Context, request ExecuteStatementRequest) (*StatementResponse, error)

	// Get status, manifest, and result first chunk.
	//
	// This request can be used to poll for the statement's status. When the
	// `status.state` field is `SUCCEEDED` it will also return the result manifest
	// and the first chunk of the result data. When the statement is in the terminal
	// states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200 with the state
	// set. After at least 12 hours in terminal state, the statement is removed from
	// the warehouse and further calls will receive an HTTP 404 response.
	//
	// **NOTE** This call currently might take up to 5 seconds to get the latest
	// status and result.
	GetStatement(ctx context.Context, request GetStatementRequest) (*StatementResponse, error)

	// Get status, manifest, and result first chunk.
	//
	// This request can be used to poll for the statement's status. When the
	// `status.state` field is `SUCCEEDED` it will also return the result manifest
	// and the first chunk of the result data. When the statement is in the terminal
	// states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200 with the state
	// set. After at least 12 hours in terminal state, the statement is removed from
	// the warehouse and further calls will receive an HTTP 404 response.
	//
	// **NOTE** This call currently might take up to 5 seconds to get the latest
	// status and result.
	GetStatementByStatementId(ctx context.Context, statementId string) (*StatementResponse, error)

	// Get result chunk by index.
	//
	// After the statement execution has `SUCCEEDED`, this request can be used to
	// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
	// typically fetched with :method:statementexecution/executeStatement or
	// :method:statementexecution/getStatement, this request can be used to fetch
	// subsequent chunks. The response structure is identical to the nested `result`
	// element described in the :method:statementexecution/getStatement request, and
	// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
	// fields for simple iteration through the result set.
	GetStatementResultChunkN(ctx context.Context, request GetStatementResultChunkNRequest) (*ResultData, error)

	// Get result chunk by index.
	//
	// After the statement execution has `SUCCEEDED`, this request can be used to
	// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
	// typically fetched with :method:statementexecution/executeStatement or
	// :method:statementexecution/getStatement, this request can be used to fetch
	// subsequent chunks. The response structure is identical to the nested `result`
	// element described in the :method:statementexecution/getStatement request, and
	// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
	// fields for simple iteration through the result set.
	GetStatementResultChunkNByStatementIdAndChunkIndex(ctx context.Context, statementId string, chunkIndex int) (*ResultData, error)
}

func NewStatementExecution(client *client.DatabricksClient) *StatementExecutionAPI {
	return &StatementExecutionAPI{
		statementExecutionImpl: statementExecutionImpl{
			client: client,
		},
	}
}

// The Databricks SQL Statement Execution API can be used to execute SQL
// statements on a SQL warehouse and fetch the result.
//
// **Getting started**
//
// We suggest beginning with the [Databricks SQL Statement Execution API
// tutorial].
//
// **Overview of statement execution and result fetching**
//
// Statement execution begins by issuing a
// :method:statementexecution/executeStatement request with a valid SQL
// statement and warehouse ID, along with optional parameters such as the data
// catalog and output format. If no other parameters are specified, the server
// will wait for up to 10s before returning a response. If the statement has
// completed within this timespan, the response will include the result data as
// a JSON array and metadata. Otherwise, if no result is available after the 10s
// timeout expired, the response will provide the statement ID that can be used
// to poll for results by using a :method:statementexecution/getStatement
// request.
//
// You can specify whether the call should behave synchronously, asynchronously
// or start synchronously with a fallback to asynchronous execution. This is
// controlled with the `wait_timeout` and `on_wait_timeout` settings. If
// `wait_timeout` is set between 5-50 seconds (default: 10s), the call waits for
// results up to the specified timeout; when set to `0s`, the call is
// asynchronous and responds immediately with a statement ID. The
// `on_wait_timeout` setting specifies what should happen when the timeout is
// reached while the statement execution has not yet finished. This can be set
// to either `CONTINUE`, to fallback to asynchronous mode, or it can be set to
// `CANCEL`, which cancels the statement.
//
// In summary: - Synchronous mode - `wait_timeout=30s` and
// `on_wait_timeout=CANCEL` - The call waits up to 30 seconds; if the statement
// execution finishes within this time, the result data is returned directly in
// the response. If the execution takes longer than 30 seconds, the execution is
// canceled and the call returns with a `CANCELED` state. - Asynchronous mode -
// `wait_timeout=0s` (`on_wait_timeout` is ignored) - The call doesn't wait for
// the statement to finish but returns directly with a statement ID. The status
// of the statement execution can be polled by issuing
// :method:statementexecution/getStatement with the statement ID. Once the
// execution has succeeded, this call also returns the result and metadata in
// the response. - Hybrid mode (default) - `wait_timeout=10s` and
// `on_wait_timeout=CONTINUE` - The call waits for up to 10 seconds; if the
// statement execution finishes within this time, the result data is returned
// directly in the response. If the execution takes longer than 10 seconds, a
// statement ID is returned. The statement ID can be used to fetch status and
// results in the same way as in the asynchronous mode.
//
// Depending on the size, the result can be split into multiple chunks. If the
// statement execution is successful, the statement response contains a manifest
// and the first chunk of the result. The manifest contains schema information
// and provides metadata for each chunk in the result. Result chunks can be
// retrieved by index with :method:statementexecution/getStatementResultChunkN
// which may be called in any order and in parallel. For sequential fetching,
// each chunk, apart from the last, also contains a `next_chunk_index` and
// `next_chunk_internal_link` that point to the next chunk.
//
// A statement can be canceled with :method:statementexecution/cancelExecution.
//
// **Fetching result data: format and disposition**
//
// To specify the format of the result data, use the `format` field, which can
// be set to one of the following options: `JSON_ARRAY` (JSON), `ARROW_STREAM`
// ([Apache Arrow Columnar]), or `CSV`.
//
// There are two ways to receive statement results, controlled by the
// `disposition` setting, which can be either `INLINE` or `EXTERNAL_LINKS`:
//
// - `INLINE`: In this mode, the result data is directly included in the
// response. It's best suited for smaller results. This mode can only be used
// with the `JSON_ARRAY` format.
//
// - `EXTERNAL_LINKS`: In this mode, the response provides links that can be
// used to download the result data in chunks separately. This approach is ideal
// for larger results and offers higher throughput. This mode can be used with
// all the formats: `JSON_ARRAY`, `ARROW_STREAM`, and `CSV`.
//
// By default, the API uses `format=JSON_ARRAY` and `disposition=INLINE`.
//
// **Limits and limitations**
//
// Note: The byte limit for INLINE disposition is based on internal storage
// metrics and will not exactly match the byte count of the actual payload.
//
// - Statements with `disposition=INLINE` are limited to 25 MiB and will fail
// when this limit is exceeded. - Statements with `disposition=EXTERNAL_LINKS`
// are limited to 100 GiB. Result sets larger than this limit will be truncated.
// Truncation is indicated by the `truncated` field in the result manifest. -
// The maximum query text size is 16 MiB. - Cancelation might silently fail. A
// successful response from a cancel request indicates that the cancel request
// was successfully received and sent to the processing engine. However, an
// outstanding statement might have already completed execution when the cancel
// request arrives. Polling for status until a terminal state is reached is a
// reliable way to determine the final state. - Wait timeouts are approximate,
// occur server-side, and cannot account for things such as caller delays and
// network latency from caller to service. - To guarantee that the statement is
// kept alive, you must poll at least once every 15 minutes. - The results are
// only available for one hour after success; polling does not extend this. -
// The SQL Execution API must be used for the entire lifecycle of the statement.
// For example, you cannot use the Jobs API to execute the command, and then the
// SQL Execution API to cancel it.
//
// [Apache Arrow Columnar]: https://arrow.apache.org/overview/
// [Databricks SQL Statement Execution API tutorial]: https://docs.databricks.com/sql/api/sql-execution-tutorial.html
type StatementExecutionAPI struct {
	statementExecutionImpl
}

// Get status, manifest, and result first chunk.
//
// This request can be used to poll for the statement's status. When the
// `status.state` field is `SUCCEEDED` it will also return the result manifest
// and the first chunk of the result data. When the statement is in the terminal
// states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200 with the state
// set. After at least 12 hours in terminal state, the statement is removed from
// the warehouse and further calls will receive an HTTP 404 response.
//
// **NOTE** This call currently might take up to 5 seconds to get the latest
// status and result.
func (a *StatementExecutionAPI) GetStatementByStatementId(ctx context.Context, statementId string) (*StatementResponse, error) {
	return a.statementExecutionImpl.GetStatement(ctx, GetStatementRequest{
		StatementId: statementId,
	})
}

// Get result chunk by index.
//
// After the statement execution has `SUCCEEDED`, this request can be used to
// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
// typically fetched with :method:statementexecution/executeStatement or
// :method:statementexecution/getStatement, this request can be used to fetch
// subsequent chunks. The response structure is identical to the nested `result`
// element described in the :method:statementexecution/getStatement request, and
// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
// fields for simple iteration through the result set.
func (a *StatementExecutionAPI) GetStatementResultChunkNByStatementIdAndChunkIndex(ctx context.Context, statementId string, chunkIndex int) (*ResultData, error) {
	return a.statementExecutionImpl.GetStatementResultChunkN(ctx, GetStatementResultChunkNRequest{
		StatementId: statementId,
		ChunkIndex:  chunkIndex,
	})
}

type WarehousesInterface interface {

	// WaitGetWarehouseRunning repeatedly calls [WarehousesAPI.Get] and waits to reach RUNNING state
	WaitGetWarehouseRunning(ctx context.Context, id string,
		timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)

	// WaitGetWarehouseStopped repeatedly calls [WarehousesAPI.Get] and waits to reach STOPPED state
	WaitGetWarehouseStopped(ctx context.Context, id string,
		timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)

	// Create a warehouse.
	//
	// Creates a new SQL warehouse.
	Create(ctx context.Context, createWarehouseRequest CreateWarehouseRequest) (*WaitGetWarehouseRunning[CreateWarehouseResponse], error)

	// Calls [WarehousesAPIInterface.Create] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Create].Get() or [WarehousesAPIInterface.WaitGetWarehouseRunning]
	CreateAndWait(ctx context.Context, createWarehouseRequest CreateWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Delete a warehouse.
	//
	// Deletes a SQL warehouse.
	Delete(ctx context.Context, request DeleteWarehouseRequest) error

	// Delete a warehouse.
	//
	// Deletes a SQL warehouse.
	DeleteById(ctx context.Context, id string) error

	// Update a warehouse.
	//
	// Updates the configuration for a SQL warehouse.
	Edit(ctx context.Context, editWarehouseRequest EditWarehouseRequest) (*WaitGetWarehouseRunning[struct{}], error)

	// Calls [WarehousesAPIInterface.Edit] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Edit].Get() or [WarehousesAPIInterface.WaitGetWarehouseRunning]
	EditAndWait(ctx context.Context, editWarehouseRequest EditWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Get warehouse info.
	//
	// Gets the information for a single SQL warehouse.
	Get(ctx context.Context, request GetWarehouseRequest) (*GetWarehouseResponse, error)

	// Get warehouse info.
	//
	// Gets the information for a single SQL warehouse.
	GetById(ctx context.Context, id string) (*GetWarehouseResponse, error)

	// Get SQL warehouse permission levels.
	//
	// Gets the permission levels that a user can have on an object.
	GetPermissionLevels(ctx context.Context, request GetWarehousePermissionLevelsRequest) (*GetWarehousePermissionLevelsResponse, error)

	// Get SQL warehouse permission levels.
	//
	// Gets the permission levels that a user can have on an object.
	GetPermissionLevelsByWarehouseId(ctx context.Context, warehouseId string) (*GetWarehousePermissionLevelsResponse, error)

	// Get SQL warehouse permissions.
	//
	// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
	// permissions from their root object.
	GetPermissions(ctx context.Context, request GetWarehousePermissionsRequest) (*WarehousePermissions, error)

	// Get SQL warehouse permissions.
	//
	// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
	// permissions from their root object.
	GetPermissionsByWarehouseId(ctx context.Context, warehouseId string) (*WarehousePermissions, error)

	// Get the workspace configuration.
	//
	// Gets the workspace level configuration that is shared by all SQL warehouses
	// in a workspace.
	GetWorkspaceWarehouseConfig(ctx context.Context) (*GetWorkspaceWarehouseConfigResponse, error)

	// List warehouses.
	//
	// Lists all SQL warehouses that a user has manager permissions on.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListWarehousesRequest) listing.Iterator[EndpointInfo]

	// List warehouses.
	//
	// Lists all SQL warehouses that a user has manager permissions on.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListWarehousesRequest) ([]EndpointInfo, error)

	// EndpointInfoNameToIdMap calls [WarehousesAPI.ListAll] and creates a map of results with [EndpointInfo].Name as key and [EndpointInfo].Id as value.
	//
	// Returns an error if there's more than one [EndpointInfo] with the same .Name.
	//
	// Note: All [EndpointInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	EndpointInfoNameToIdMap(ctx context.Context, request ListWarehousesRequest) (map[string]string, error)

	// GetByName calls [WarehousesAPI.EndpointInfoNameToIdMap] and returns a single [EndpointInfo].
	//
	// Returns an error if there's more than one [EndpointInfo] with the same .Name.
	//
	// Note: All [EndpointInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*EndpointInfo, error)

	// Set SQL warehouse permissions.
	//
	// Sets permissions on an object, replacing existing permissions if they exist.
	// Deletes all direct permissions if none are specified. Objects can inherit
	// permissions from their root object.
	SetPermissions(ctx context.Context, request WarehousePermissionsRequest) (*WarehousePermissions, error)

	// Set the workspace configuration.
	//
	// Sets the workspace level configuration that is shared by all SQL warehouses
	// in a workspace.
	SetWorkspaceWarehouseConfig(ctx context.Context, request SetWorkspaceWarehouseConfigRequest) error

	// Start a warehouse.
	//
	// Starts a SQL warehouse.
	Start(ctx context.Context, startRequest StartRequest) (*WaitGetWarehouseRunning[struct{}], error)

	// Calls [WarehousesAPIInterface.Start] and waits to reach RUNNING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Start].Get() or [WarehousesAPIInterface.WaitGetWarehouseRunning]
	StartAndWait(ctx context.Context, startRequest StartRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Stop a warehouse.
	//
	// Stops a SQL warehouse.
	Stop(ctx context.Context, stopRequest StopRequest) (*WaitGetWarehouseStopped[struct{}], error)

	// Calls [WarehousesAPIInterface.Stop] and waits to reach STOPPED state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
	//
	// Deprecated: use [WarehousesAPIInterface.Stop].Get() or [WarehousesAPIInterface.WaitGetWarehouseStopped]
	StopAndWait(ctx context.Context, stopRequest StopRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error)

	// Update SQL warehouse permissions.
	//
	// Updates the permissions on a SQL warehouse. SQL warehouses can inherit
	// permissions from their root object.
	UpdatePermissions(ctx context.Context, request WarehousePermissionsRequest) (*WarehousePermissions, error)
}

func NewWarehouses(client *client.DatabricksClient) *WarehousesAPI {
	return &WarehousesAPI{
		warehousesImpl: warehousesImpl{
			client: client,
		},
	}
}

// A SQL warehouse is a compute resource that lets you run SQL commands on data
// objects within Databricks SQL. Compute resources are infrastructure resources
// that provide processing capabilities in the cloud.
type WarehousesAPI struct {
	warehousesImpl
}

// WaitGetWarehouseRunning repeatedly calls [WarehousesAPI.Get] and waits to reach RUNNING state
func (a *WarehousesAPI) WaitGetWarehouseRunning(ctx context.Context, id string,
	timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[GetWarehouseResponse](ctx, timeout, func() (*GetWarehouseResponse, *retries.Err) {
		getWarehouseResponse, err := a.Get(ctx, GetWarehouseRequest{
			Id: id,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(getWarehouseResponse)
		}
		status := getWarehouseResponse.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if getWarehouseResponse.Health != nil {
			statusMessage = getWarehouseResponse.Health.Summary
		}
		switch status {
		case StateRunning: // target state
			return getWarehouseResponse, nil
		case StateStopped, StateDeleted:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				StateRunning, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetWarehouseRunning is a wrapper that calls [WarehousesAPI.WaitGetWarehouseRunning] and waits to reach RUNNING state.
type WaitGetWarehouseRunning[R any] struct {
	Response *R
	Id       string `json:"id"`
	Poll     func(time.Duration, func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)
	callback func(*GetWarehouseResponse)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetWarehouseRunning[R]) OnProgress(callback func(*GetWarehouseResponse)) *WaitGetWarehouseRunning[R] {
	w.callback = callback
	return w
}

// Get the GetWarehouseResponse with the default timeout of 20 minutes.
func (w *WaitGetWarehouseRunning[R]) Get() (*GetWarehouseResponse, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the GetWarehouseResponse with custom timeout.
func (w *WaitGetWarehouseRunning[R]) GetWithTimeout(timeout time.Duration) (*GetWarehouseResponse, error) {
	return w.Poll(timeout, w.callback)
}

// WaitGetWarehouseStopped repeatedly calls [WarehousesAPI.Get] and waits to reach STOPPED state
func (a *WarehousesAPI) WaitGetWarehouseStopped(ctx context.Context, id string,
	timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[GetWarehouseResponse](ctx, timeout, func() (*GetWarehouseResponse, *retries.Err) {
		getWarehouseResponse, err := a.Get(ctx, GetWarehouseRequest{
			Id: id,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(getWarehouseResponse)
		}
		status := getWarehouseResponse.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if getWarehouseResponse.Health != nil {
			statusMessage = getWarehouseResponse.Health.Summary
		}
		switch status {
		case StateStopped: // target state
			return getWarehouseResponse, nil
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetWarehouseStopped is a wrapper that calls [WarehousesAPI.WaitGetWarehouseStopped] and waits to reach STOPPED state.
type WaitGetWarehouseStopped[R any] struct {
	Response *R
	Id       string `json:"id"`
	Poll     func(time.Duration, func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)
	callback func(*GetWarehouseResponse)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetWarehouseStopped[R]) OnProgress(callback func(*GetWarehouseResponse)) *WaitGetWarehouseStopped[R] {
	w.callback = callback
	return w
}

// Get the GetWarehouseResponse with the default timeout of 20 minutes.
func (w *WaitGetWarehouseStopped[R]) Get() (*GetWarehouseResponse, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the GetWarehouseResponse with custom timeout.
func (w *WaitGetWarehouseStopped[R]) GetWithTimeout(timeout time.Duration) (*GetWarehouseResponse, error) {
	return w.Poll(timeout, w.callback)
}

// Create a warehouse.
//
// Creates a new SQL warehouse.
func (a *WarehousesAPI) Create(ctx context.Context, createWarehouseRequest CreateWarehouseRequest) (*WaitGetWarehouseRunning[CreateWarehouseResponse], error) {
	createWarehouseResponse, err := a.warehousesImpl.Create(ctx, createWarehouseRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[CreateWarehouseResponse]{
		Response: createWarehouseResponse,
		Id:       createWarehouseResponse.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, createWarehouseResponse.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Create] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Create].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) CreateAndWait(ctx context.Context, createWarehouseRequest CreateWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Create(ctx, createWarehouseRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Delete a warehouse.
//
// Deletes a SQL warehouse.
func (a *WarehousesAPI) DeleteById(ctx context.Context, id string) error {
	return a.warehousesImpl.Delete(ctx, DeleteWarehouseRequest{
		Id: id,
	})
}

// Update a warehouse.
//
// Updates the configuration for a SQL warehouse.
func (a *WarehousesAPI) Edit(ctx context.Context, editWarehouseRequest EditWarehouseRequest) (*WaitGetWarehouseRunning[struct{}], error) {
	err := a.warehousesImpl.Edit(ctx, editWarehouseRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[struct{}]{

		Id: editWarehouseRequest.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, editWarehouseRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Edit] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Edit].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) EditAndWait(ctx context.Context, editWarehouseRequest EditWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Edit(ctx, editWarehouseRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Get warehouse info.
//
// Gets the information for a single SQL warehouse.
func (a *WarehousesAPI) GetById(ctx context.Context, id string) (*GetWarehouseResponse, error) {
	return a.warehousesImpl.Get(ctx, GetWarehouseRequest{
		Id: id,
	})
}

// Get SQL warehouse permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *WarehousesAPI) GetPermissionLevelsByWarehouseId(ctx context.Context, warehouseId string) (*GetWarehousePermissionLevelsResponse, error) {
	return a.warehousesImpl.GetPermissionLevels(ctx, GetWarehousePermissionLevelsRequest{
		WarehouseId: warehouseId,
	})
}

// Get SQL warehouse permissions.
//
// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
// permissions from their root object.
func (a *WarehousesAPI) GetPermissionsByWarehouseId(ctx context.Context, warehouseId string) (*WarehousePermissions, error) {
	return a.warehousesImpl.GetPermissions(ctx, GetWarehousePermissionsRequest{
		WarehouseId: warehouseId,
	})
}

// EndpointInfoNameToIdMap calls [WarehousesAPI.ListAll] and creates a map of results with [EndpointInfo].Name as key and [EndpointInfo].Id as value.
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) EndpointInfoNameToIdMap(ctx context.Context, request ListWarehousesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [WarehousesAPI.EndpointInfoNameToIdMap] and returns a single [EndpointInfo].
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) GetByName(ctx context.Context, name string) (*EndpointInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListWarehousesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]EndpointInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("EndpointInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of EndpointInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Start a warehouse.
//
// Starts a SQL warehouse.
func (a *WarehousesAPI) Start(ctx context.Context, startRequest StartRequest) (*WaitGetWarehouseRunning[struct{}], error) {
	err := a.warehousesImpl.Start(ctx, startRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[struct{}]{

		Id: startRequest.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, startRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Start] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Start].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) StartAndWait(ctx context.Context, startRequest StartRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Start(ctx, startRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Stop a warehouse.
//
// Stops a SQL warehouse.
func (a *WarehousesAPI) Stop(ctx context.Context, stopRequest StopRequest) (*WaitGetWarehouseStopped[struct{}], error) {
	err := a.warehousesImpl.Stop(ctx, stopRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseStopped[struct{}]{

		Id: stopRequest.Id,
		Poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseStopped(ctx, stopRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Stop] and waits to reach STOPPED state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Stop].Get() or [WarehousesAPI.WaitGetWarehouseStopped]
func (a *WarehousesAPI) StopAndWait(ctx context.Context, stopRequest StopRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Stop(ctx, stopRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}
