// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Alerts, Dashboard Widgets, Dashboards, Data Sources, Dbsql Permissions, Queries, Query History, Query Visualizations, Statement Execution, Warehouses, etc.
package sql

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

func NewAlerts(client *client.DatabricksClient) *AlertsAPI {
	return &AlertsAPI{
		impl: &alertsImpl{
			client: client,
		},
	}
}

// The alerts API can be used to perform CRUD operations on alerts. An alert is
// a Databricks SQL object that periodically runs a query, evaluates a condition
// of its result, and notifies one or more users and/or notification
// destinations if the condition was met. Alerts can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type AlertsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AlertsService)
	impl AlertsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *AlertsAPI) WithImpl(impl AlertsService) *AlertsAPI {
	a.impl = impl
	return a
}

// Impl returns low-level Alerts API implementation
func (a *AlertsAPI) Impl() AlertsService {
	return a.impl
}

// Create an alert.
//
// Creates an alert. An alert is a Databricks SQL object that periodically runs
// a query, evaluates a condition of its result, and notifies users or
// notification destinations if the condition was met.
func (a *AlertsAPI) Create(ctx context.Context, request CreateAlert) (*Alert, error) {
	return a.impl.Create(ctx, request)
}

// Delete an alert.
//
// Deletes an alert. Deleted alerts are no longer accessible and cannot be
// restored. **Note:** Unlike queries and dashboards, alerts cannot be moved to
// the trash.
func (a *AlertsAPI) Delete(ctx context.Context, request DeleteAlertRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete an alert.
//
// Deletes an alert. Deleted alerts are no longer accessible and cannot be
// restored. **Note:** Unlike queries and dashboards, alerts cannot be moved to
// the trash.
func (a *AlertsAPI) DeleteByAlertId(ctx context.Context, alertId string) error {
	return a.impl.Delete(ctx, DeleteAlertRequest{
		AlertId: alertId,
	})
}

// Get an alert.
//
// Gets an alert.
func (a *AlertsAPI) Get(ctx context.Context, request GetAlertRequest) (*Alert, error) {
	return a.impl.Get(ctx, request)
}

// Get an alert.
//
// Gets an alert.
func (a *AlertsAPI) GetByAlertId(ctx context.Context, alertId string) (*Alert, error) {
	return a.impl.Get(ctx, GetAlertRequest{
		AlertId: alertId,
	})
}

// Get alerts.
//
// Gets a list of alerts.
func (a *AlertsAPI) List(ctx context.Context) ([]Alert, error) {
	return a.impl.List(ctx)
}

// AlertNameToIdMap calls [AlertsAPI.List] and creates a map of results with [Alert].Name as key and [Alert].Id as value.
//
// Returns an error if there's more than one [Alert] with the same .Name.
//
// Note: All [Alert] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) AlertNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [AlertsAPI.AlertNameToIdMap] and returns a single [Alert].
//
// Returns an error if there's more than one [Alert] with the same .Name.
//
// Note: All [Alert] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AlertsAPI) GetByName(ctx context.Context, name string) (*Alert, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Alert{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Alert named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Alert named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Update an alert.
//
// Updates an alert.
func (a *AlertsAPI) Update(ctx context.Context, request EditAlert) error {
	return a.impl.Update(ctx, request)
}

func NewDashboardWidgets(client *client.DatabricksClient) *DashboardWidgetsAPI {
	return &DashboardWidgetsAPI{
		impl: &dashboardWidgetsImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of widgets
// from existing dashboards within the Databricks Workspace. Data structures may
// change over time.
type DashboardWidgetsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(DashboardWidgetsService)
	impl DashboardWidgetsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *DashboardWidgetsAPI) WithImpl(impl DashboardWidgetsService) *DashboardWidgetsAPI {
	a.impl = impl
	return a
}

// Impl returns low-level DashboardWidgets API implementation
func (a *DashboardWidgetsAPI) Impl() DashboardWidgetsService {
	return a.impl
}

// Add widget to a dashboard.
func (a *DashboardWidgetsAPI) Create(ctx context.Context, request CreateWidget) (*Widget, error) {
	return a.impl.Create(ctx, request)
}

// Remove widget.
func (a *DashboardWidgetsAPI) Delete(ctx context.Context, request DeleteDashboardWidgetRequest) error {
	return a.impl.Delete(ctx, request)
}

// Remove widget.
func (a *DashboardWidgetsAPI) DeleteById(ctx context.Context, id string) error {
	return a.impl.Delete(ctx, DeleteDashboardWidgetRequest{
		Id: id,
	})
}

// Update existing widget.
func (a *DashboardWidgetsAPI) Update(ctx context.Context, request CreateWidget) (*Widget, error) {
	return a.impl.Update(ctx, request)
}

func NewDashboards(client *client.DatabricksClient) *DashboardsAPI {
	return &DashboardsAPI{
		impl: &dashboardsImpl{
			client: client,
		},
	}
}

// In general, there is little need to modify dashboards using the API. However,
// it can be useful to use dashboard objects to look-up a collection of related
// query IDs. The API can also be used to duplicate multiple dashboards at once
// since you can get a dashboard definition with a GET request and then POST it
// to create a new one. Dashboards can be scheduled using the `sql_task` type of
// the Jobs API, e.g. :method:jobs/create.
type DashboardsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(DashboardsService)
	impl DashboardsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *DashboardsAPI) WithImpl(impl DashboardsService) *DashboardsAPI {
	a.impl = impl
	return a
}

// Impl returns low-level Dashboards API implementation
func (a *DashboardsAPI) Impl() DashboardsService {
	return a.impl
}

// Create a dashboard object.
func (a *DashboardsAPI) Create(ctx context.Context, request CreateDashboardRequest) (*Dashboard, error) {
	return a.impl.Create(ctx, request)
}

// Remove a dashboard.
//
// Moves a dashboard to the trash. Trashed dashboards do not appear in list
// views or searches, and cannot be shared.
func (a *DashboardsAPI) Delete(ctx context.Context, request DeleteDashboardRequest) error {
	return a.impl.Delete(ctx, request)
}

// Remove a dashboard.
//
// Moves a dashboard to the trash. Trashed dashboards do not appear in list
// views or searches, and cannot be shared.
func (a *DashboardsAPI) DeleteByDashboardId(ctx context.Context, dashboardId string) error {
	return a.impl.Delete(ctx, DeleteDashboardRequest{
		DashboardId: dashboardId,
	})
}

// Retrieve a definition.
//
// Returns a JSON representation of a dashboard object, including its
// visualization and query objects.
func (a *DashboardsAPI) Get(ctx context.Context, request GetDashboardRequest) (*Dashboard, error) {
	return a.impl.Get(ctx, request)
}

// Retrieve a definition.
//
// Returns a JSON representation of a dashboard object, including its
// visualization and query objects.
func (a *DashboardsAPI) GetByDashboardId(ctx context.Context, dashboardId string) (*Dashboard, error) {
	return a.impl.Get(ctx, GetDashboardRequest{
		DashboardId: dashboardId,
	})
}

// Get dashboard objects.
//
// Fetch a paginated list of dashboard objects.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DashboardsAPI) List(ctx context.Context, request ListDashboardsRequest) *listing.Iterator[ListDashboardsRequest, *ListResponse, Dashboard] {
	request.Page = 1 // start iterating from the first page

	getNextPage := func(ctx context.Context, req ListDashboardsRequest) (*ListResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListResponse) []Dashboard {
		return resp.Results
	}
	getNextReq := func(resp *ListResponse) (ListDashboardsRequest, listing.ListingStatus) {
		status := listing.ListingStatusCheckResult
		request.Page = resp.Page + 1
		return request, status
	}
	return listing.NewIterator(
		request,
		getNextPage,
		getItems,
		getNextReq)
}

func (a *DashboardsAPI) ListAll(ctx context.Context, request ListDashboardsRequest) ([]Dashboard, error) {
	var results []Dashboard
	var totalCount int = 0
	limit := request.PageSize
	iter := a.List(ctx, request)
	// deduplicate items that may have been added during iteration
	seen := map[string]bool{}
	var err error
	var next Dashboard
	for next, err = iter.Next(ctx); err != nil; next, err = iter.Next(ctx) {
		id := next.Id
		if seen[id] {
			// item was added during iteration
			continue
		}
		seen[id] = true
		results = append(results, next)
		totalCount++
		if limit > 0 && totalCount >= limit {
			break
		}
	}
	if err != listing.ErrNoMoreItems {
		return nil, err
	}
	return results, nil
}

// DashboardNameToIdMap calls [DashboardsAPI.ListAll] and creates a map of results with [Dashboard].Name as key and [Dashboard].Id as value.
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DashboardsAPI) DashboardNameToIdMap(ctx context.Context, request ListDashboardsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [DashboardsAPI.DashboardNameToIdMap] and returns a single [Dashboard].
//
// Returns an error if there's more than one [Dashboard] with the same .Name.
//
// Note: All [Dashboard] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DashboardsAPI) GetByName(ctx context.Context, name string) (*Dashboard, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListDashboardsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Dashboard{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Dashboard named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Dashboard named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Restore a dashboard.
//
// A restored dashboard appears in list views and searches and can be shared.
func (a *DashboardsAPI) Restore(ctx context.Context, request RestoreDashboardRequest) error {
	return a.impl.Restore(ctx, request)
}

func NewDataSources(client *client.DatabricksClient) *DataSourcesAPI {
	return &DataSourcesAPI{
		impl: &dataSourcesImpl{
			client: client,
		},
	}
}

// This API is provided to assist you in making new query objects. When creating
// a query object, you may optionally specify a `data_source_id` for the SQL
// warehouse against which it will run. If you don't already know the
// `data_source_id` for your desired SQL warehouse, this API will help you find
// it.
//
// This API does not support searches. It returns the full list of SQL
// warehouses in your workspace. We advise you to use any text editor, REST
// client, or `grep` to search the response from this API for the name of your
// SQL warehouse as it appears in Databricks SQL.
type DataSourcesAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(DataSourcesService)
	impl DataSourcesService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *DataSourcesAPI) WithImpl(impl DataSourcesService) *DataSourcesAPI {
	a.impl = impl
	return a
}

// Impl returns low-level DataSources API implementation
func (a *DataSourcesAPI) Impl() DataSourcesService {
	return a.impl
}

// Get a list of SQL warehouses.
//
// Retrieves a full list of SQL warehouses available in this workspace. All
// fields that appear in this API response are enumerated for clarity. However,
// you need only a SQL warehouse's `id` to create new queries against it.
func (a *DataSourcesAPI) List(ctx context.Context) ([]DataSource, error) {
	return a.impl.List(ctx)
}

// DataSourceNameToIdMap calls [DataSourcesAPI.List] and creates a map of results with [DataSource].Name as key and [DataSource].Id as value.
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DataSourcesAPI) DataSourceNameToIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [DataSourcesAPI.DataSourceNameToIdMap] and returns a single [DataSource].
//
// Returns an error if there's more than one [DataSource] with the same .Name.
//
// Note: All [DataSource] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *DataSourcesAPI) GetByName(ctx context.Context, name string) (*DataSource, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]DataSource{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("DataSource named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of DataSource named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

func NewDbsqlPermissions(client *client.DatabricksClient) *DbsqlPermissionsAPI {
	return &DbsqlPermissionsAPI{
		impl: &dbsqlPermissionsImpl{
			client: client,
		},
	}
}

// The SQL Permissions API is similar to the endpoints of the
// :method:permissions/set. However, this exposes only one endpoint, which gets
// the Access Control List for a given object. You cannot modify any permissions
// using this API.
//
// There are three levels of permission:
//
// - `CAN_VIEW`: Allows read-only access
//
// - `CAN_RUN`: Allows read access and run access (superset of `CAN_VIEW`)
//
// - `CAN_MANAGE`: Allows all actions: read, run, edit, delete, modify
// permissions (superset of `CAN_RUN`)
type DbsqlPermissionsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(DbsqlPermissionsService)
	impl DbsqlPermissionsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *DbsqlPermissionsAPI) WithImpl(impl DbsqlPermissionsService) *DbsqlPermissionsAPI {
	a.impl = impl
	return a
}

// Impl returns low-level DbsqlPermissions API implementation
func (a *DbsqlPermissionsAPI) Impl() DbsqlPermissionsService {
	return a.impl
}

// Get object ACL.
//
// Gets a JSON representation of the access control list (ACL) for a specified
// object.
func (a *DbsqlPermissionsAPI) Get(ctx context.Context, request GetDbsqlPermissionRequest) (*GetResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get object ACL.
//
// Gets a JSON representation of the access control list (ACL) for a specified
// object.
func (a *DbsqlPermissionsAPI) GetByObjectTypeAndObjectId(ctx context.Context, objectType ObjectTypePlural, objectId string) (*GetResponse, error) {
	return a.impl.Get(ctx, GetDbsqlPermissionRequest{
		ObjectType: objectType,
		ObjectId:   objectId,
	})
}

// Set object ACL.
//
// Sets the access control list (ACL) for a specified object. This operation
// will complete rewrite the ACL.
func (a *DbsqlPermissionsAPI) Set(ctx context.Context, request SetRequest) (*SetResponse, error) {
	return a.impl.Set(ctx, request)
}

// Transfer object ownership.
//
// Transfers ownership of a dashboard, query, or alert to an active user.
// Requires an admin API key.
func (a *DbsqlPermissionsAPI) TransferOwnership(ctx context.Context, request TransferOwnershipRequest) (*Success, error) {
	return a.impl.TransferOwnership(ctx, request)
}

func NewQueries(client *client.DatabricksClient) *QueriesAPI {
	return &QueriesAPI{
		impl: &queriesImpl{
			client: client,
		},
	}
}

// These endpoints are used for CRUD operations on query definitions. Query
// definitions include the target SQL warehouse, query text, name, description,
// tags, parameters, and visualizations. Queries can be scheduled using the
// `sql_task` type of the Jobs API, e.g. :method:jobs/create.
type QueriesAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(QueriesService)
	impl QueriesService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *QueriesAPI) WithImpl(impl QueriesService) *QueriesAPI {
	a.impl = impl
	return a
}

// Impl returns low-level Queries API implementation
func (a *QueriesAPI) Impl() QueriesService {
	return a.impl
}

// Create a new query definition.
//
// Creates a new query definition. Queries created with this endpoint belong to
// the authenticated user making the request.
//
// The `data_source_id` field specifies the ID of the SQL warehouse to run this
// query against. You can use the Data Sources API to see a complete list of
// available SQL warehouses. Or you can copy the `data_source_id` from an
// existing query.
//
// **Note**: You cannot add a visualization until you create the query.
func (a *QueriesAPI) Create(ctx context.Context, request QueryPostContent) (*Query, error) {
	return a.impl.Create(ctx, request)
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and they cannot be used for alerts. The trash is
// deleted after 30 days.
func (a *QueriesAPI) Delete(ctx context.Context, request DeleteQueryRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a query.
//
// Moves a query to the trash. Trashed queries immediately disappear from
// searches and list views, and they cannot be used for alerts. The trash is
// deleted after 30 days.
func (a *QueriesAPI) DeleteByQueryId(ctx context.Context, queryId string) error {
	return a.impl.Delete(ctx, DeleteQueryRequest{
		QueryId: queryId,
	})
}

// Get a query definition.
//
// Retrieve a query object definition along with contextual permissions
// information about the currently authenticated user.
func (a *QueriesAPI) Get(ctx context.Context, request GetQueryRequest) (*Query, error) {
	return a.impl.Get(ctx, request)
}

// Get a query definition.
//
// Retrieve a query object definition along with contextual permissions
// information about the currently authenticated user.
func (a *QueriesAPI) GetByQueryId(ctx context.Context, queryId string) (*Query, error) {
	return a.impl.Get(ctx, GetQueryRequest{
		QueryId: queryId,
	})
}

// Get a list of queries.
//
// Gets a list of queries. Optionally, this list can be filtered by a search
// term.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) List(ctx context.Context, request ListQueriesRequest) *listing.Iterator[ListQueriesRequest, *QueryList, Query] {
	request.Page = 1 // start iterating from the first page

	getNextPage := func(ctx context.Context, req ListQueriesRequest) (*QueryList, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *QueryList) []Query {
		return resp.Results
	}
	getNextReq := func(resp *QueryList) (ListQueriesRequest, listing.ListingStatus) {
		status := listing.ListingStatusCheckResult
		request.Page = resp.Page + 1
		return request, status
	}
	return listing.NewIterator(
		request,
		getNextPage,
		getItems,
		getNextReq)
}

func (a *QueriesAPI) ListAll(ctx context.Context, request ListQueriesRequest) ([]Query, error) {
	var results []Query
	var totalCount int = 0
	limit := request.PageSize
	iter := a.List(ctx, request)
	// deduplicate items that may have been added during iteration
	seen := map[string]bool{}
	var err error
	var next Query
	for next, err = iter.Next(ctx); err != nil; next, err = iter.Next(ctx) {
		id := next.Id
		if seen[id] {
			// item was added during iteration
			continue
		}
		seen[id] = true
		results = append(results, next)
		totalCount++
		if limit > 0 && totalCount >= limit {
			break
		}
	}
	if err != listing.ErrNoMoreItems {
		return nil, err
	}
	return results, nil
}

// QueryNameToIdMap calls [QueriesAPI.ListAll] and creates a map of results with [Query].Name as key and [Query].Id as value.
//
// Returns an error if there's more than one [Query] with the same .Name.
//
// Note: All [Query] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) QueryNameToIdMap(ctx context.Context, request ListQueriesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [QueriesAPI.QueryNameToIdMap] and returns a single [Query].
//
// Returns an error if there's more than one [Query] with the same .Name.
//
// Note: All [Query] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueriesAPI) GetByName(ctx context.Context, name string) (*Query, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListQueriesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]Query{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("Query named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of Query named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Restore a query.
//
// Restore a query that has been moved to the trash. A restored query appears in
// list views and searches. You can use restored queries for alerts.
func (a *QueriesAPI) Restore(ctx context.Context, request RestoreQueryRequest) error {
	return a.impl.Restore(ctx, request)
}

// Change a query definition.
//
// Modify this query definition.
//
// **Note**: You cannot undo this operation.
func (a *QueriesAPI) Update(ctx context.Context, request QueryEditContent) (*Query, error) {
	return a.impl.Update(ctx, request)
}

func NewQueryHistory(client *client.DatabricksClient) *QueryHistoryAPI {
	return &QueryHistoryAPI{
		impl: &queryHistoryImpl{
			client: client,
		},
	}
}

// Access the history of queries through SQL warehouses.
type QueryHistoryAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(QueryHistoryService)
	impl QueryHistoryService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *QueryHistoryAPI) WithImpl(impl QueryHistoryService) *QueryHistoryAPI {
	a.impl = impl
	return a
}

// Impl returns low-level QueryHistory API implementation
func (a *QueryHistoryAPI) Impl() QueryHistoryService {
	return a.impl
}

// List Queries.
//
// List the history of queries through SQL warehouses.
//
// You can filter by user ID, warehouse ID, status, and time range.
//
// This method is generated by Databricks SDK Code Generator.
func (a *QueryHistoryAPI) List(ctx context.Context, request ListQueryHistoryRequest) *listing.Iterator[ListQueryHistoryRequest, *ListQueriesResponse, QueryInfo] {

	getNextPage := func(ctx context.Context, req ListQueryHistoryRequest) (*ListQueriesResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListQueriesResponse) []QueryInfo {
		return resp.Res
	}
	getNextReq := func(resp *ListQueriesResponse) (ListQueryHistoryRequest, listing.ListingStatus) {
		status := listing.ListingStatusCheckResult
		request.PageToken = resp.NextPageToken
		if resp.NextPageToken == "" {
			status = listing.ListingStatusExhausted
		} else {
			status = listing.ListingStatusNotExhausted
		}
		return request, status
	}
	return listing.NewIterator(
		request,
		getNextPage,
		getItems,
		getNextReq)
}

func (a *QueryHistoryAPI) ListAll(ctx context.Context, request ListQueryHistoryRequest) ([]QueryInfo, error) {
	var results []QueryInfo
	var totalCount int = 0
	limit := request.MaxResults
	iter := a.List(ctx, request)
	var err error
	var next QueryInfo
	for next, err = iter.Next(ctx); err != nil; next, err = iter.Next(ctx) {

		results = append(results, next)
		totalCount++
		if limit > 0 && totalCount >= limit {
			break
		}
	}
	if err != listing.ErrNoMoreItems {
		return nil, err
	}
	return results, nil
}

func NewQueryVisualizations(client *client.DatabricksClient) *QueryVisualizationsAPI {
	return &QueryVisualizationsAPI{
		impl: &queryVisualizationsImpl{
			client: client,
		},
	}
}

// This is an evolving API that facilitates the addition and removal of
// vizualisations from existing queries within the Databricks Workspace. Data
// structures may change over time.
type QueryVisualizationsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(QueryVisualizationsService)
	impl QueryVisualizationsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *QueryVisualizationsAPI) WithImpl(impl QueryVisualizationsService) *QueryVisualizationsAPI {
	a.impl = impl
	return a
}

// Impl returns low-level QueryVisualizations API implementation
func (a *QueryVisualizationsAPI) Impl() QueryVisualizationsService {
	return a.impl
}

// Add visualization to a query.
func (a *QueryVisualizationsAPI) Create(ctx context.Context, request CreateQueryVisualizationRequest) (*Visualization, error) {
	return a.impl.Create(ctx, request)
}

// Remove visualization.
func (a *QueryVisualizationsAPI) Delete(ctx context.Context, request DeleteQueryVisualizationRequest) error {
	return a.impl.Delete(ctx, request)
}

// Remove visualization.
func (a *QueryVisualizationsAPI) DeleteById(ctx context.Context, id string) error {
	return a.impl.Delete(ctx, DeleteQueryVisualizationRequest{
		Id: id,
	})
}

// Edit existing visualization.
func (a *QueryVisualizationsAPI) Update(ctx context.Context, request Visualization) (*Visualization, error) {
	return a.impl.Update(ctx, request)
}

func NewStatementExecution(client *client.DatabricksClient) *StatementExecutionAPI {
	return &StatementExecutionAPI{
		impl: &statementExecutionImpl{
			client: client,
		},
	}
}

// The Databricks SQL Statement Execution API can be used to execute SQL
// statements on a SQL warehouse and fetch the result.
//
// **Getting started**
//
// We suggest beginning with the [Databricks SQL Statement Execution API
// tutorial].
//
// **Overview of statement execution and result fetching**
//
// Statement execution begins by issuing a
// :method:statementexecution/executeStatement request with a valid SQL
// statement and warehouse ID, along with optional parameters such as the data
// catalog and output format. If no other parameters are specified, the server
// will wait for up to 10s before returning a response. If the statement has
// completed within this timespan, the response will include the result data as
// a JSON array and metadata. Otherwise, if no result is available after the 10s
// timeout expired, the response will provide the statement ID that can be used
// to poll for results by using a :method:statementexecution/getStatement
// request.
//
// You can specify whether the call should behave synchronously, asynchronously
// or start synchronously with a fallback to asynchronous execution. This is
// controlled with the `wait_timeout` and `on_wait_timeout` settings. If
// `wait_timeout` is set between 5-50 seconds (default: 10s), the call waits for
// results up to the specified timeout; when set to `0s`, the call is
// asynchronous and responds immediately with a statement ID. The
// `on_wait_timeout` setting specifies what should happen when the timeout is
// reached while the statement execution has not yet finished. This can be set
// to either `CONTINUE`, to fallback to asynchronous mode, or it can be set to
// `CANCEL`, which cancels the statement.
//
// In summary: - Synchronous mode - `wait_timeout=30s` and
// `on_wait_timeout=CANCEL` - The call waits up to 30 seconds; if the statement
// execution finishes within this time, the result data is returned directly in
// the response. If the execution takes longer than 30 seconds, the execution is
// canceled and the call returns with a `CANCELED` state. - Asynchronous mode -
// `wait_timeout=0s` (`on_wait_timeout` is ignored) - The call doesn't wait for
// the statement to finish but returns directly with a statement ID. The status
// of the statement execution can be polled by issuing
// :method:statementexecution/getStatement with the statement ID. Once the
// execution has succeeded, this call also returns the result and metadata in
// the response. - Hybrid mode (default) - `wait_timeout=10s` and
// `on_wait_timeout=CONTINUE` - The call waits for up to 10 seconds; if the
// statement execution finishes within this time, the result data is returned
// directly in the response. If the execution takes longer than 10 seconds, a
// statement ID is returned. The statement ID can be used to fetch status and
// results in the same way as in the asynchronous mode.
//
// Depending on the size, the result can be split into multiple chunks. If the
// statement execution is successful, the statement response contains a manifest
// and the first chunk of the result. The manifest contains schema information
// and provides metadata for each chunk in the result. Result chunks can be
// retrieved by index with :method:statementexecution/getStatementResultChunkN
// which may be called in any order and in parallel. For sequential fetching,
// each chunk, apart from the last, also contains a `next_chunk_index` and
// `next_chunk_internal_link` that point to the next chunk.
//
// A statement can be canceled with :method:statementexecution/cancelExecution.
//
// **Fetching result data: format and disposition**
//
// To specify the format of the result data, use the `format` field, which can
// be set to one of the following options: `JSON_ARRAY` (JSON), `ARROW_STREAM`
// ([Apache Arrow Columnar]), or `CSV`.
//
// There are two ways to receive statement results, controlled by the
// `disposition` setting, which can be either `INLINE` or `EXTERNAL_LINKS`:
//
// - `INLINE`: In this mode, the result data is directly included in the
// response. It's best suited for smaller results. This mode can only be used
// with the `JSON_ARRAY` format.
//
// - `EXTERNAL_LINKS`: In this mode, the response provides links that can be
// used to download the result data in chunks separately. This approach is ideal
// for larger results and offers higher throughput. This mode can be used with
// all the formats: `JSON_ARRAY`, `ARROW_STREAM`, and `CSV`.
//
// By default, the API uses `format=JSON_ARRAY` and `disposition=INLINE`.
//
// **Limits and limitations**
//
// Note: The byte limit for INLINE disposition is based on internal storage
// metrics and will not exactly match the byte count of the actual payload.
//
// - Statements with `disposition=INLINE` are limited to 25 MiB and will fail
// when this limit is exceeded. - Statements with `disposition=EXTERNAL_LINKS`
// are limited to 100 GiB. Result sets larger than this limit will be truncated.
// Truncation is indicated by the `truncated` field in the result manifest. -
// The maximum query text size is 16 MiB. - Cancelation might silently fail. A
// successful response from a cancel request indicates that the cancel request
// was successfully received and sent to the processing engine. However, an
// outstanding statement might have already completed execution when the cancel
// request arrives. Polling for status until a terminal state is reached is a
// reliable way to determine the final state. - Wait timeouts are approximate,
// occur server-side, and cannot account for things such as caller delays and
// network latency from caller to service. - The system will auto-close a
// statement after one hour if the client stops polling and thus you must poll
// at least once an hour. - The results are only available for one hour after
// success; polling does not extend this.
//
// [Apache Arrow Columnar]: https://arrow.apache.org/overview/
// [Databricks SQL Statement Execution API tutorial]: https://docs.databricks.com/sql/api/sql-execution-tutorial.html
type StatementExecutionAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(StatementExecutionService)
	impl StatementExecutionService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *StatementExecutionAPI) WithImpl(impl StatementExecutionService) *StatementExecutionAPI {
	a.impl = impl
	return a
}

// Impl returns low-level StatementExecution API implementation
func (a *StatementExecutionAPI) Impl() StatementExecutionService {
	return a.impl
}

// Cancel statement execution.
//
// Requests that an executing statement be canceled. Callers must poll for
// status to see the terminal state.
func (a *StatementExecutionAPI) CancelExecution(ctx context.Context, request CancelExecutionRequest) error {
	return a.impl.CancelExecution(ctx, request)
}

// Execute a SQL statement.
func (a *StatementExecutionAPI) ExecuteStatement(ctx context.Context, request ExecuteStatementRequest) (*ExecuteStatementResponse, error) {
	return a.impl.ExecuteStatement(ctx, request)
}

// Get status, manifest, and result first chunk.
//
// This request can be used to poll for the statement's status. When the
// `status.state` field is `SUCCEEDED` it will also return the result manifest
// and the first chunk of the result data. When the statement is in the terminal
// states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200 with the state
// set. After at least 12 hours in terminal state, the statement is removed from
// the warehouse and further calls will receive an HTTP 404 response.
//
// **NOTE** This call currently might take up to 5 seconds to get the latest
// status and result.
func (a *StatementExecutionAPI) GetStatement(ctx context.Context, request GetStatementRequest) (*GetStatementResponse, error) {
	return a.impl.GetStatement(ctx, request)
}

// Get status, manifest, and result first chunk.
//
// This request can be used to poll for the statement's status. When the
// `status.state` field is `SUCCEEDED` it will also return the result manifest
// and the first chunk of the result data. When the statement is in the terminal
// states `CANCELED`, `CLOSED` or `FAILED`, it returns HTTP 200 with the state
// set. After at least 12 hours in terminal state, the statement is removed from
// the warehouse and further calls will receive an HTTP 404 response.
//
// **NOTE** This call currently might take up to 5 seconds to get the latest
// status and result.
func (a *StatementExecutionAPI) GetStatementByStatementId(ctx context.Context, statementId string) (*GetStatementResponse, error) {
	return a.impl.GetStatement(ctx, GetStatementRequest{
		StatementId: statementId,
	})
}

// Get result chunk by index.
//
// After the statement execution has `SUCCEEDED`, this request can be used to
// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
// typically fetched with :method:statementexecution/executeStatement or
// :method:statementexecution/getStatement, this request can be used to fetch
// subsequent chunks. The response structure is identical to the nested `result`
// element described in the :method:statementexecution/getStatement request, and
// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
// fields for simple iteration through the result set.
func (a *StatementExecutionAPI) GetStatementResultChunkN(ctx context.Context, request GetStatementResultChunkNRequest) (*ResultData, error) {
	return a.impl.GetStatementResultChunkN(ctx, request)
}

// Get result chunk by index.
//
// After the statement execution has `SUCCEEDED`, this request can be used to
// fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is
// typically fetched with :method:statementexecution/executeStatement or
// :method:statementexecution/getStatement, this request can be used to fetch
// subsequent chunks. The response structure is identical to the nested `result`
// element described in the :method:statementexecution/getStatement request, and
// similarly includes the `next_chunk_index` and `next_chunk_internal_link`
// fields for simple iteration through the result set.
func (a *StatementExecutionAPI) GetStatementResultChunkNByStatementIdAndChunkIndex(ctx context.Context, statementId string, chunkIndex int) (*ResultData, error) {
	return a.impl.GetStatementResultChunkN(ctx, GetStatementResultChunkNRequest{
		StatementId: statementId,
		ChunkIndex:  chunkIndex,
	})
}

func NewWarehouses(client *client.DatabricksClient) *WarehousesAPI {
	return &WarehousesAPI{
		impl: &warehousesImpl{
			client: client,
		},
	}
}

// A SQL warehouse is a compute resource that lets you run SQL commands on data
// objects within Databricks SQL. Compute resources are infrastructure resources
// that provide processing capabilities in the cloud.
type WarehousesAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(WarehousesService)
	impl WarehousesService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
func (a *WarehousesAPI) WithImpl(impl WarehousesService) *WarehousesAPI {
	a.impl = impl
	return a
}

// Impl returns low-level Warehouses API implementation
func (a *WarehousesAPI) Impl() WarehousesService {
	return a.impl
}

// WaitGetWarehouseRunning repeatedly calls [WarehousesAPI.Get] and waits to reach RUNNING state
func (a *WarehousesAPI) WaitGetWarehouseRunning(ctx context.Context, id string,
	timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[GetWarehouseResponse](ctx, timeout, func() (*GetWarehouseResponse, *retries.Err) {
		getWarehouseResponse, err := a.Get(ctx, GetWarehouseRequest{
			Id: id,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(getWarehouseResponse)
		}
		status := getWarehouseResponse.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if getWarehouseResponse.Health != nil {
			statusMessage = getWarehouseResponse.Health.Summary
		}
		switch status {
		case StateRunning: // target state
			return getWarehouseResponse, nil
		case StateStopped, StateDeleted:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				StateRunning, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetWarehouseRunning is a wrapper that calls [WarehousesAPI.WaitGetWarehouseRunning] and waits to reach RUNNING state.
type WaitGetWarehouseRunning[R any] struct {
	Response *R
	Id       string `json:"id"`
	poll     func(time.Duration, func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)
	callback func(*GetWarehouseResponse)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetWarehouseRunning[R]) OnProgress(callback func(*GetWarehouseResponse)) *WaitGetWarehouseRunning[R] {
	w.callback = callback
	return w
}

// Get the GetWarehouseResponse with the default timeout of 20 minutes.
func (w *WaitGetWarehouseRunning[R]) Get() (*GetWarehouseResponse, error) {
	return w.poll(w.timeout, w.callback)
}

// Get the GetWarehouseResponse with custom timeout.
func (w *WaitGetWarehouseRunning[R]) GetWithTimeout(timeout time.Duration) (*GetWarehouseResponse, error) {
	return w.poll(timeout, w.callback)
}

// WaitGetWarehouseStopped repeatedly calls [WarehousesAPI.Get] and waits to reach STOPPED state
func (a *WarehousesAPI) WaitGetWarehouseStopped(ctx context.Context, id string,
	timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[GetWarehouseResponse](ctx, timeout, func() (*GetWarehouseResponse, *retries.Err) {
		getWarehouseResponse, err := a.Get(ctx, GetWarehouseRequest{
			Id: id,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(getWarehouseResponse)
		}
		status := getWarehouseResponse.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if getWarehouseResponse.Health != nil {
			statusMessage = getWarehouseResponse.Health.Summary
		}
		switch status {
		case StateStopped: // target state
			return getWarehouseResponse, nil
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetWarehouseStopped is a wrapper that calls [WarehousesAPI.WaitGetWarehouseStopped] and waits to reach STOPPED state.
type WaitGetWarehouseStopped[R any] struct {
	Response *R
	Id       string `json:"id"`
	poll     func(time.Duration, func(*GetWarehouseResponse)) (*GetWarehouseResponse, error)
	callback func(*GetWarehouseResponse)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetWarehouseStopped[R]) OnProgress(callback func(*GetWarehouseResponse)) *WaitGetWarehouseStopped[R] {
	w.callback = callback
	return w
}

// Get the GetWarehouseResponse with the default timeout of 20 minutes.
func (w *WaitGetWarehouseStopped[R]) Get() (*GetWarehouseResponse, error) {
	return w.poll(w.timeout, w.callback)
}

// Get the GetWarehouseResponse with custom timeout.
func (w *WaitGetWarehouseStopped[R]) GetWithTimeout(timeout time.Duration) (*GetWarehouseResponse, error) {
	return w.poll(timeout, w.callback)
}

// Create a warehouse.
//
// Creates a new SQL warehouse.
func (a *WarehousesAPI) Create(ctx context.Context, createWarehouseRequest CreateWarehouseRequest) (*WaitGetWarehouseRunning[CreateWarehouseResponse], error) {
	createWarehouseResponse, err := a.impl.Create(ctx, createWarehouseRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[CreateWarehouseResponse]{
		Response: createWarehouseResponse,
		Id:       createWarehouseResponse.Id,
		poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, createWarehouseResponse.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Create] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Create].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) CreateAndWait(ctx context.Context, createWarehouseRequest CreateWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Create(ctx, createWarehouseRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Delete a warehouse.
//
// Deletes a SQL warehouse.
func (a *WarehousesAPI) Delete(ctx context.Context, request DeleteWarehouseRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a warehouse.
//
// Deletes a SQL warehouse.
func (a *WarehousesAPI) DeleteById(ctx context.Context, id string) error {
	return a.impl.Delete(ctx, DeleteWarehouseRequest{
		Id: id,
	})
}

// Update a warehouse.
//
// Updates the configuration for a SQL warehouse.
func (a *WarehousesAPI) Edit(ctx context.Context, editWarehouseRequest EditWarehouseRequest) (*WaitGetWarehouseRunning[any], error) {
	err := a.impl.Edit(ctx, editWarehouseRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[any]{

		Id: editWarehouseRequest.Id,
		poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, editWarehouseRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Edit] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Edit].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) EditAndWait(ctx context.Context, editWarehouseRequest EditWarehouseRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Edit(ctx, editWarehouseRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Get warehouse info.
//
// Gets the information for a single SQL warehouse.
func (a *WarehousesAPI) Get(ctx context.Context, request GetWarehouseRequest) (*GetWarehouseResponse, error) {
	return a.impl.Get(ctx, request)
}

// Get warehouse info.
//
// Gets the information for a single SQL warehouse.
func (a *WarehousesAPI) GetById(ctx context.Context, id string) (*GetWarehouseResponse, error) {
	return a.impl.Get(ctx, GetWarehouseRequest{
		Id: id,
	})
}

// Get SQL warehouse permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *WarehousesAPI) GetPermissionLevels(ctx context.Context, request GetWarehousePermissionLevelsRequest) (*GetWarehousePermissionLevelsResponse, error) {
	return a.impl.GetPermissionLevels(ctx, request)
}

// Get SQL warehouse permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *WarehousesAPI) GetPermissionLevelsByWarehouseId(ctx context.Context, warehouseId string) (*GetWarehousePermissionLevelsResponse, error) {
	return a.impl.GetPermissionLevels(ctx, GetWarehousePermissionLevelsRequest{
		WarehouseId: warehouseId,
	})
}

// Get SQL warehouse permissions.
//
// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
// permissions from their root object.
func (a *WarehousesAPI) GetPermissions(ctx context.Context, request GetWarehousePermissionsRequest) (*WarehousePermissions, error) {
	return a.impl.GetPermissions(ctx, request)
}

// Get SQL warehouse permissions.
//
// Gets the permissions of a SQL warehouse. SQL warehouses can inherit
// permissions from their root object.
func (a *WarehousesAPI) GetPermissionsByWarehouseId(ctx context.Context, warehouseId string) (*WarehousePermissions, error) {
	return a.impl.GetPermissions(ctx, GetWarehousePermissionsRequest{
		WarehouseId: warehouseId,
	})
}

// Get the workspace configuration.
//
// Gets the workspace level configuration that is shared by all SQL warehouses
// in a workspace.
func (a *WarehousesAPI) GetWorkspaceWarehouseConfig(ctx context.Context) (*GetWorkspaceWarehouseConfigResponse, error) {
	return a.impl.GetWorkspaceWarehouseConfig(ctx)
}

// List warehouses.
//
// Lists all SQL warehouses that a user has manager permissions on.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) List(ctx context.Context, request ListWarehousesRequest) *listing.Iterator[ListWarehousesRequest, *ListWarehousesResponse, EndpointInfo] {

	getNextPage := func(ctx context.Context, req ListWarehousesRequest) (*ListWarehousesResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListWarehousesResponse) []EndpointInfo {
		return resp.Warehouses
	}

	return listing.NewIterator(
		request,
		getNextPage,
		getItems,
		nil)
}

func (a *WarehousesAPI) ListAll(ctx context.Context, request ListWarehousesRequest) ([]EndpointInfo, error) {
	var results []EndpointInfo
	iter := a.List(ctx, request)
	var err error
	var next EndpointInfo
	for next, err = iter.Next(ctx); err != nil; next, err = iter.Next(ctx) {

		results = append(results, next)
	}
	if err != listing.ErrNoMoreItems {
		return nil, err
	}
	return results, nil
}

// EndpointInfoNameToIdMap calls [WarehousesAPI.ListAll] and creates a map of results with [EndpointInfo].Name as key and [EndpointInfo].Id as value.
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) EndpointInfoNameToIdMap(ctx context.Context, request ListWarehousesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [WarehousesAPI.EndpointInfoNameToIdMap] and returns a single [EndpointInfo].
//
// Returns an error if there's more than one [EndpointInfo] with the same .Name.
//
// Note: All [EndpointInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *WarehousesAPI) GetByName(ctx context.Context, name string) (*EndpointInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListWarehousesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]EndpointInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("EndpointInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of EndpointInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Set SQL warehouse permissions.
//
// Sets permissions on a SQL warehouse. SQL warehouses can inherit permissions
// from their root object.
func (a *WarehousesAPI) SetPermissions(ctx context.Context, request WarehousePermissionsRequest) (*WarehousePermissions, error) {
	return a.impl.SetPermissions(ctx, request)
}

// Set the workspace configuration.
//
// Sets the workspace level configuration that is shared by all SQL warehouses
// in a workspace.
func (a *WarehousesAPI) SetWorkspaceWarehouseConfig(ctx context.Context, request SetWorkspaceWarehouseConfigRequest) error {
	return a.impl.SetWorkspaceWarehouseConfig(ctx, request)
}

// Start a warehouse.
//
// Starts a SQL warehouse.
func (a *WarehousesAPI) Start(ctx context.Context, startRequest StartRequest) (*WaitGetWarehouseRunning[any], error) {
	err := a.impl.Start(ctx, startRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseRunning[any]{

		Id: startRequest.Id,
		poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseRunning(ctx, startRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Start] and waits to reach RUNNING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Start].Get() or [WarehousesAPI.WaitGetWarehouseRunning]
func (a *WarehousesAPI) StartAndWait(ctx context.Context, startRequest StartRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Start(ctx, startRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Stop a warehouse.
//
// Stops a SQL warehouse.
func (a *WarehousesAPI) Stop(ctx context.Context, stopRequest StopRequest) (*WaitGetWarehouseStopped[any], error) {
	err := a.impl.Stop(ctx, stopRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetWarehouseStopped[any]{

		Id: stopRequest.Id,
		poll: func(timeout time.Duration, callback func(*GetWarehouseResponse)) (*GetWarehouseResponse, error) {
			return a.WaitGetWarehouseStopped(ctx, stopRequest.Id, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [WarehousesAPI.Stop] and waits to reach STOPPED state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[GetWarehouseResponse](60*time.Minute) functional option.
//
// Deprecated: use [WarehousesAPI.Stop].Get() or [WarehousesAPI.WaitGetWarehouseStopped]
func (a *WarehousesAPI) StopAndWait(ctx context.Context, stopRequest StopRequest, options ...retries.Option[GetWarehouseResponse]) (*GetWarehouseResponse, error) {
	wait, err := a.Stop(ctx, stopRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[GetWarehouseResponse]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *GetWarehouseResponse) {
		for _, o := range options {
			o(&retries.Info[GetWarehouseResponse]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Update SQL warehouse permissions.
//
// Updates the permissions on a SQL warehouse. SQL warehouses can inherit
// permissions from their root object.
func (a *WarehousesAPI) UpdatePermissions(ctx context.Context, request WarehousePermissionsRequest) (*WarehousePermissions, error) {
	return a.impl.UpdatePermissions(ctx, request)
}
