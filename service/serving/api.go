// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Apps, Serving Endpoints, etc.
package serving

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AppsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAppsInterface instead.
	WithImpl(impl AppsService) AppsInterface

	// Impl returns low-level Apps API implementation
	// Deprecated: use MockAppsInterface instead.
	Impl() AppsService

	// WaitGetAppIdle repeatedly calls [AppsAPI.Get] and waits to reach IDLE state
	WaitGetAppIdle(ctx context.Context, name string,
		timeout time.Duration, callback func(*App)) (*App, error)

	// WaitGetDeploymentAppSucceeded repeatedly calls [AppsAPI.GetDeployment] and waits to reach SUCCEEDED state
	WaitGetDeploymentAppSucceeded(ctx context.Context, appName string, deploymentId string,
		timeout time.Duration, callback func(*AppDeployment)) (*AppDeployment, error)

	// Create an App.
	//
	// Creates a new app.
	Create(ctx context.Context, createAppRequest CreateAppRequest) (*WaitGetAppIdle[App], error)

	// Calls [AppsAPIInterface.Create] and waits to reach IDLE state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[App](60*time.Minute) functional option.
	//
	// Deprecated: use [AppsAPIInterface.Create].Get() or [AppsAPIInterface.WaitGetAppIdle]
	CreateAndWait(ctx context.Context, createAppRequest CreateAppRequest, options ...retries.Option[App]) (*App, error)

	// Create an App Deployment.
	//
	// Creates an app deployment for the app with the supplied name.
	CreateDeployment(ctx context.Context, createAppDeploymentRequest CreateAppDeploymentRequest) (*WaitGetDeploymentAppSucceeded[AppDeployment], error)

	// Calls [AppsAPIInterface.CreateDeployment] and waits to reach SUCCEEDED state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[AppDeployment](60*time.Minute) functional option.
	//
	// Deprecated: use [AppsAPIInterface.CreateDeployment].Get() or [AppsAPIInterface.WaitGetDeploymentAppSucceeded]
	CreateDeploymentAndWait(ctx context.Context, createAppDeploymentRequest CreateAppDeploymentRequest, options ...retries.Option[AppDeployment]) (*AppDeployment, error)

	// Delete an App.
	//
	// Deletes an app.
	Delete(ctx context.Context, request DeleteAppRequest) error

	// Delete an App.
	//
	// Deletes an app.
	DeleteByName(ctx context.Context, name string) error

	// Get an App.
	//
	// Retrieves information for the app with the supplied name.
	Get(ctx context.Context, request GetAppRequest) (*App, error)

	// Get an App.
	//
	// Retrieves information for the app with the supplied name.
	GetByName(ctx context.Context, name string) (*App, error)

	// Get an App Deployment.
	//
	// Retrieves information for the app deployment with the supplied name and
	// deployment id.
	GetDeployment(ctx context.Context, request GetAppDeploymentRequest) (*AppDeployment, error)

	// Get an App Deployment.
	//
	// Retrieves information for the app deployment with the supplied name and
	// deployment id.
	GetDeploymentByAppNameAndDeploymentId(ctx context.Context, appName string, deploymentId string) (*AppDeployment, error)

	// Get App Environment.
	//
	// Retrieves app environment.
	GetEnvironment(ctx context.Context, request GetAppEnvironmentRequest) (*AppEnvironment, error)

	// Get App Environment.
	//
	// Retrieves app environment.
	GetEnvironmentByName(ctx context.Context, name string) (*AppEnvironment, error)

	// List Apps.
	//
	// Lists all apps in the workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAppsRequest) listing.Iterator[App]

	// List Apps.
	//
	// Lists all apps in the workspace.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAppsRequest) ([]App, error)

	// List App Deployments.
	//
	// Lists all app deployments for the app with the supplied name.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDeployments(ctx context.Context, request ListAppDeploymentsRequest) listing.Iterator[AppDeployment]

	// List App Deployments.
	//
	// Lists all app deployments for the app with the supplied name.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListDeploymentsAll(ctx context.Context, request ListAppDeploymentsRequest) ([]AppDeployment, error)

	// List App Deployments.
	//
	// Lists all app deployments for the app with the supplied name.
	ListDeploymentsByAppName(ctx context.Context, appName string) (*ListAppDeploymentsResponse, error)

	// Stop an App.
	//
	// Stops the active deployment of the app in the workspace.
	Stop(ctx context.Context, request StopAppRequest) error

	// Update an App.
	//
	// Updates the app with the supplied name.
	Update(ctx context.Context, request UpdateAppRequest) (*App, error)
}

func NewApps(client *client.DatabricksClient) *AppsAPI {
	return &AppsAPI{
		impl: &appsImpl{
			client: client,
		},
	}
}

// Apps run directly on a customerâ€™s Databricks instance, integrate with their
// data, use and extend Databricks services, and enable users to interact
// through single sign-on.
type AppsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AppsService)
	impl AppsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAppsInterface instead.
func (a *AppsAPI) WithImpl(impl AppsService) AppsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Apps API implementation
// Deprecated: use MockAppsInterface instead.
func (a *AppsAPI) Impl() AppsService {
	return a.impl
}

// WaitGetAppIdle repeatedly calls [AppsAPI.Get] and waits to reach IDLE state
func (a *AppsAPI) WaitGetAppIdle(ctx context.Context, name string,
	timeout time.Duration, callback func(*App)) (*App, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[App](ctx, timeout, func() (*App, *retries.Err) {
		app, err := a.Get(ctx, GetAppRequest{
			Name: name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(app)
		}
		status := app.Status.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if app.Status != nil {
			statusMessage = app.Status.Message
		}
		switch status {
		case AppStateIdle: // target state
			return app, nil
		case AppStateError:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				AppStateIdle, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetAppIdle is a wrapper that calls [AppsAPI.WaitGetAppIdle] and waits to reach IDLE state.
type WaitGetAppIdle[R any] struct {
	Response *R
	Name     string `json:"name"`
	Poll     func(time.Duration, func(*App)) (*App, error)
	callback func(*App)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetAppIdle[R]) OnProgress(callback func(*App)) *WaitGetAppIdle[R] {
	w.callback = callback
	return w
}

// Get the App with the default timeout of 20 minutes.
func (w *WaitGetAppIdle[R]) Get() (*App, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the App with custom timeout.
func (w *WaitGetAppIdle[R]) GetWithTimeout(timeout time.Duration) (*App, error) {
	return w.Poll(timeout, w.callback)
}

// WaitGetDeploymentAppSucceeded repeatedly calls [AppsAPI.GetDeployment] and waits to reach SUCCEEDED state
func (a *AppsAPI) WaitGetDeploymentAppSucceeded(ctx context.Context, appName string, deploymentId string,
	timeout time.Duration, callback func(*AppDeployment)) (*AppDeployment, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[AppDeployment](ctx, timeout, func() (*AppDeployment, *retries.Err) {
		appDeployment, err := a.GetDeployment(ctx, GetAppDeploymentRequest{
			AppName:      appName,
			DeploymentId: deploymentId,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(appDeployment)
		}
		status := appDeployment.Status.State
		statusMessage := fmt.Sprintf("current status: %s", status)
		if appDeployment.Status != nil {
			statusMessage = appDeployment.Status.Message
		}
		switch status {
		case AppDeploymentStateSucceeded: // target state
			return appDeployment, nil
		case AppDeploymentStateFailed:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				AppDeploymentStateSucceeded, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetDeploymentAppSucceeded is a wrapper that calls [AppsAPI.WaitGetDeploymentAppSucceeded] and waits to reach SUCCEEDED state.
type WaitGetDeploymentAppSucceeded[R any] struct {
	Response     *R
	AppName      string `json:"app_name"`
	DeploymentId string `json:"deployment_id"`
	Poll         func(time.Duration, func(*AppDeployment)) (*AppDeployment, error)
	callback     func(*AppDeployment)
	timeout      time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetDeploymentAppSucceeded[R]) OnProgress(callback func(*AppDeployment)) *WaitGetDeploymentAppSucceeded[R] {
	w.callback = callback
	return w
}

// Get the AppDeployment with the default timeout of 20 minutes.
func (w *WaitGetDeploymentAppSucceeded[R]) Get() (*AppDeployment, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the AppDeployment with custom timeout.
func (w *WaitGetDeploymentAppSucceeded[R]) GetWithTimeout(timeout time.Duration) (*AppDeployment, error) {
	return w.Poll(timeout, w.callback)
}

// Create an App.
//
// Creates a new app.
func (a *AppsAPI) Create(ctx context.Context, createAppRequest CreateAppRequest) (*WaitGetAppIdle[App], error) {
	app, err := a.impl.Create(ctx, createAppRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetAppIdle[App]{
		Response: app,
		Name:     app.Name,
		Poll: func(timeout time.Duration, callback func(*App)) (*App, error) {
			return a.WaitGetAppIdle(ctx, app.Name, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [AppsAPI.Create] and waits to reach IDLE state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[App](60*time.Minute) functional option.
//
// Deprecated: use [AppsAPI.Create].Get() or [AppsAPI.WaitGetAppIdle]
func (a *AppsAPI) CreateAndWait(ctx context.Context, createAppRequest CreateAppRequest, options ...retries.Option[App]) (*App, error) {
	wait, err := a.Create(ctx, createAppRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[App]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *App) {
		for _, o := range options {
			o(&retries.Info[App]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Create an App Deployment.
//
// Creates an app deployment for the app with the supplied name.
func (a *AppsAPI) CreateDeployment(ctx context.Context, createAppDeploymentRequest CreateAppDeploymentRequest) (*WaitGetDeploymentAppSucceeded[AppDeployment], error) {
	appDeployment, err := a.impl.CreateDeployment(ctx, createAppDeploymentRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetDeploymentAppSucceeded[AppDeployment]{
		Response:     appDeployment,
		AppName:      createAppDeploymentRequest.AppName,
		DeploymentId: appDeployment.DeploymentId,
		Poll: func(timeout time.Duration, callback func(*AppDeployment)) (*AppDeployment, error) {
			return a.WaitGetDeploymentAppSucceeded(ctx, createAppDeploymentRequest.AppName, appDeployment.DeploymentId, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [AppsAPI.CreateDeployment] and waits to reach SUCCEEDED state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[AppDeployment](60*time.Minute) functional option.
//
// Deprecated: use [AppsAPI.CreateDeployment].Get() or [AppsAPI.WaitGetDeploymentAppSucceeded]
func (a *AppsAPI) CreateDeploymentAndWait(ctx context.Context, createAppDeploymentRequest CreateAppDeploymentRequest, options ...retries.Option[AppDeployment]) (*AppDeployment, error) {
	wait, err := a.CreateDeployment(ctx, createAppDeploymentRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[AppDeployment]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *AppDeployment) {
		for _, o := range options {
			o(&retries.Info[AppDeployment]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Delete an App.
//
// Deletes an app.
func (a *AppsAPI) Delete(ctx context.Context, request DeleteAppRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete an App.
//
// Deletes an app.
func (a *AppsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteAppRequest{
		Name: name,
	})
}

// Get an App.
//
// Retrieves information for the app with the supplied name.
func (a *AppsAPI) Get(ctx context.Context, request GetAppRequest) (*App, error) {
	return a.impl.Get(ctx, request)
}

// Get an App.
//
// Retrieves information for the app with the supplied name.
func (a *AppsAPI) GetByName(ctx context.Context, name string) (*App, error) {
	return a.impl.Get(ctx, GetAppRequest{
		Name: name,
	})
}

// Get an App Deployment.
//
// Retrieves information for the app deployment with the supplied name and
// deployment id.
func (a *AppsAPI) GetDeployment(ctx context.Context, request GetAppDeploymentRequest) (*AppDeployment, error) {
	return a.impl.GetDeployment(ctx, request)
}

// Get an App Deployment.
//
// Retrieves information for the app deployment with the supplied name and
// deployment id.
func (a *AppsAPI) GetDeploymentByAppNameAndDeploymentId(ctx context.Context, appName string, deploymentId string) (*AppDeployment, error) {
	return a.impl.GetDeployment(ctx, GetAppDeploymentRequest{
		AppName:      appName,
		DeploymentId: deploymentId,
	})
}

// Get App Environment.
//
// Retrieves app environment.
func (a *AppsAPI) GetEnvironment(ctx context.Context, request GetAppEnvironmentRequest) (*AppEnvironment, error) {
	return a.impl.GetEnvironment(ctx, request)
}

// Get App Environment.
//
// Retrieves app environment.
func (a *AppsAPI) GetEnvironmentByName(ctx context.Context, name string) (*AppEnvironment, error) {
	return a.impl.GetEnvironment(ctx, GetAppEnvironmentRequest{
		Name: name,
	})
}

// List Apps.
//
// Lists all apps in the workspace.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AppsAPI) List(ctx context.Context, request ListAppsRequest) listing.Iterator[App] {

	getNextPage := func(ctx context.Context, req ListAppsRequest) (*ListAppsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListAppsResponse) []App {
		return resp.Apps
	}
	getNextReq := func(resp *ListAppsResponse) *ListAppsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List Apps.
//
// Lists all apps in the workspace.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AppsAPI) ListAll(ctx context.Context, request ListAppsRequest) ([]App, error) {
	iterator := a.List(ctx, request)
	return listing.ToSlice[App](ctx, iterator)
}

// List App Deployments.
//
// Lists all app deployments for the app with the supplied name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AppsAPI) ListDeployments(ctx context.Context, request ListAppDeploymentsRequest) listing.Iterator[AppDeployment] {

	getNextPage := func(ctx context.Context, req ListAppDeploymentsRequest) (*ListAppDeploymentsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.ListDeployments(ctx, req)
	}
	getItems := func(resp *ListAppDeploymentsResponse) []AppDeployment {
		return resp.AppDeployments
	}
	getNextReq := func(resp *ListAppDeploymentsResponse) *ListAppDeploymentsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List App Deployments.
//
// Lists all app deployments for the app with the supplied name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AppsAPI) ListDeploymentsAll(ctx context.Context, request ListAppDeploymentsRequest) ([]AppDeployment, error) {
	iterator := a.ListDeployments(ctx, request)
	return listing.ToSlice[AppDeployment](ctx, iterator)
}

// List App Deployments.
//
// Lists all app deployments for the app with the supplied name.
func (a *AppsAPI) ListDeploymentsByAppName(ctx context.Context, appName string) (*ListAppDeploymentsResponse, error) {
	return a.impl.ListDeployments(ctx, ListAppDeploymentsRequest{
		AppName: appName,
	})
}

// Stop an App.
//
// Stops the active deployment of the app in the workspace.
func (a *AppsAPI) Stop(ctx context.Context, request StopAppRequest) error {
	return a.impl.Stop(ctx, request)
}

// Update an App.
//
// Updates the app with the supplied name.
func (a *AppsAPI) Update(ctx context.Context, request UpdateAppRequest) (*App, error) {
	return a.impl.Update(ctx, request)
}

type ServingEndpointsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockServingEndpointsInterface instead.
	WithImpl(impl ServingEndpointsService) ServingEndpointsInterface

	// Impl returns low-level ServingEndpoints API implementation
	// Deprecated: use MockServingEndpointsInterface instead.
	Impl() ServingEndpointsService

	// WaitGetServingEndpointNotUpdating repeatedly calls [ServingEndpointsAPI.Get] and waits to reach NOT_UPDATING state
	WaitGetServingEndpointNotUpdating(ctx context.Context, name string,
		timeout time.Duration, callback func(*ServingEndpointDetailed)) (*ServingEndpointDetailed, error)

	// Get build logs for a served model.
	//
	// Retrieves the build logs associated with the provided served model.
	BuildLogs(ctx context.Context, request BuildLogsRequest) (*BuildLogsResponse, error)

	// Get build logs for a served model.
	//
	// Retrieves the build logs associated with the provided served model.
	BuildLogsByNameAndServedModelName(ctx context.Context, name string, servedModelName string) (*BuildLogsResponse, error)

	// Create a new serving endpoint.
	Create(ctx context.Context, createServingEndpoint CreateServingEndpoint) (*WaitGetServingEndpointNotUpdating[ServingEndpointDetailed], error)

	// Calls [ServingEndpointsAPIInterface.Create] and waits to reach NOT_UPDATING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[ServingEndpointDetailed](60*time.Minute) functional option.
	//
	// Deprecated: use [ServingEndpointsAPIInterface.Create].Get() or [ServingEndpointsAPIInterface.WaitGetServingEndpointNotUpdating]
	CreateAndWait(ctx context.Context, createServingEndpoint CreateServingEndpoint, options ...retries.Option[ServingEndpointDetailed]) (*ServingEndpointDetailed, error)

	// Delete a serving endpoint.
	Delete(ctx context.Context, request DeleteServingEndpointRequest) error

	// Delete a serving endpoint.
	DeleteByName(ctx context.Context, name string) error

	// Get metrics of a serving endpoint.
	//
	// Retrieves the metrics associated with the provided serving endpoint in either
	// Prometheus or OpenMetrics exposition format.
	ExportMetrics(ctx context.Context, request ExportMetricsRequest) error

	// Get metrics of a serving endpoint.
	//
	// Retrieves the metrics associated with the provided serving endpoint in either
	// Prometheus or OpenMetrics exposition format.
	ExportMetricsByName(ctx context.Context, name string) error

	// Get a single serving endpoint.
	//
	// Retrieves the details for a single serving endpoint.
	Get(ctx context.Context, request GetServingEndpointRequest) (*ServingEndpointDetailed, error)

	// Get a single serving endpoint.
	//
	// Retrieves the details for a single serving endpoint.
	GetByName(ctx context.Context, name string) (*ServingEndpointDetailed, error)

	// Get the schema for a serving endpoint.
	//
	// Get the query schema of the serving endpoint in OpenAPI format. The schema
	// contains information for the supported paths, input and output format and
	// datatypes.
	GetOpenApi(ctx context.Context, request GetOpenApiRequest) error

	// Get the schema for a serving endpoint.
	//
	// Get the query schema of the serving endpoint in OpenAPI format. The schema
	// contains information for the supported paths, input and output format and
	// datatypes.
	GetOpenApiByName(ctx context.Context, name string) error

	// Get serving endpoint permission levels.
	//
	// Gets the permission levels that a user can have on an object.
	GetPermissionLevels(ctx context.Context, request GetServingEndpointPermissionLevelsRequest) (*GetServingEndpointPermissionLevelsResponse, error)

	// Get serving endpoint permission levels.
	//
	// Gets the permission levels that a user can have on an object.
	GetPermissionLevelsByServingEndpointId(ctx context.Context, servingEndpointId string) (*GetServingEndpointPermissionLevelsResponse, error)

	// Get serving endpoint permissions.
	//
	// Gets the permissions of a serving endpoint. Serving endpoints can inherit
	// permissions from their root object.
	GetPermissions(ctx context.Context, request GetServingEndpointPermissionsRequest) (*ServingEndpointPermissions, error)

	// Get serving endpoint permissions.
	//
	// Gets the permissions of a serving endpoint. Serving endpoints can inherit
	// permissions from their root object.
	GetPermissionsByServingEndpointId(ctx context.Context, servingEndpointId string) (*ServingEndpointPermissions, error)

	// Get all serving endpoints.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[ServingEndpoint]

	// Get all serving endpoints.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]ServingEndpoint, error)

	// Get the latest logs for a served model.
	//
	// Retrieves the service logs associated with the provided served model.
	Logs(ctx context.Context, request LogsRequest) (*ServerLogsResponse, error)

	// Get the latest logs for a served model.
	//
	// Retrieves the service logs associated with the provided served model.
	LogsByNameAndServedModelName(ctx context.Context, name string, servedModelName string) (*ServerLogsResponse, error)

	// Update tags of a serving endpoint.
	//
	// Used to batch add and delete tags from a serving endpoint with a single API
	// call.
	Patch(ctx context.Context, request PatchServingEndpointTags) ([]EndpointTag, error)

	// Update rate limits of a serving endpoint.
	//
	// Used to update the rate limits of a serving endpoint. NOTE: only external and
	// foundation model endpoints are supported as of now.
	Put(ctx context.Context, request PutRequest) (*PutResponse, error)

	// Query a serving endpoint.
	Query(ctx context.Context, request QueryEndpointInput) (*QueryEndpointResponse, error)

	// Set serving endpoint permissions.
	//
	// Sets permissions on a serving endpoint. Serving endpoints can inherit
	// permissions from their root object.
	SetPermissions(ctx context.Context, request ServingEndpointPermissionsRequest) (*ServingEndpointPermissions, error)

	// Update config of a serving endpoint.
	//
	// Updates any combination of the serving endpoint's served entities, the
	// compute configuration of those served entities, and the endpoint's traffic
	// config. An endpoint that already has an update in progress can not be updated
	// until the current update completes or fails.
	UpdateConfig(ctx context.Context, endpointCoreConfigInput EndpointCoreConfigInput) (*WaitGetServingEndpointNotUpdating[ServingEndpointDetailed], error)

	// Calls [ServingEndpointsAPIInterface.UpdateConfig] and waits to reach NOT_UPDATING state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[ServingEndpointDetailed](60*time.Minute) functional option.
	//
	// Deprecated: use [ServingEndpointsAPIInterface.UpdateConfig].Get() or [ServingEndpointsAPIInterface.WaitGetServingEndpointNotUpdating]
	UpdateConfigAndWait(ctx context.Context, endpointCoreConfigInput EndpointCoreConfigInput, options ...retries.Option[ServingEndpointDetailed]) (*ServingEndpointDetailed, error)

	// Update serving endpoint permissions.
	//
	// Updates the permissions on a serving endpoint. Serving endpoints can inherit
	// permissions from their root object.
	UpdatePermissions(ctx context.Context, request ServingEndpointPermissionsRequest) (*ServingEndpointPermissions, error)
}

func NewServingEndpoints(client *client.DatabricksClient) *ServingEndpointsAPI {
	return &ServingEndpointsAPI{
		impl: &servingEndpointsImpl{
			client: client,
		},
	}
}

// The Serving Endpoints API allows you to create, update, and delete model
// serving endpoints.
//
// You can use a serving endpoint to serve models from the Databricks Model
// Registry or from Unity Catalog. Endpoints expose the underlying models as
// scalable REST API endpoints using serverless compute. This means the
// endpoints and associated compute resources are fully managed by Databricks
// and will not appear in your cloud account. A serving endpoint can consist of
// one or more MLflow models from the Databricks Model Registry, called served
// entities. A serving endpoint can have at most ten served entities. You can
// configure traffic settings to define how requests should be routed to your
// served entities behind an endpoint. Additionally, you can configure the scale
// of resources that should be applied to each served entity.
type ServingEndpointsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(ServingEndpointsService)
	impl ServingEndpointsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockServingEndpointsInterface instead.
func (a *ServingEndpointsAPI) WithImpl(impl ServingEndpointsService) ServingEndpointsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level ServingEndpoints API implementation
// Deprecated: use MockServingEndpointsInterface instead.
func (a *ServingEndpointsAPI) Impl() ServingEndpointsService {
	return a.impl
}

// WaitGetServingEndpointNotUpdating repeatedly calls [ServingEndpointsAPI.Get] and waits to reach NOT_UPDATING state
func (a *ServingEndpointsAPI) WaitGetServingEndpointNotUpdating(ctx context.Context, name string,
	timeout time.Duration, callback func(*ServingEndpointDetailed)) (*ServingEndpointDetailed, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[ServingEndpointDetailed](ctx, timeout, func() (*ServingEndpointDetailed, *retries.Err) {
		servingEndpointDetailed, err := a.Get(ctx, GetServingEndpointRequest{
			Name: name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(servingEndpointDetailed)
		}
		status := servingEndpointDetailed.State.ConfigUpdate
		statusMessage := fmt.Sprintf("current status: %s", status)
		switch status {
		case EndpointStateConfigUpdateNotUpdating: // target state
			return servingEndpointDetailed, nil
		case EndpointStateConfigUpdateUpdateFailed:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				EndpointStateConfigUpdateNotUpdating, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetServingEndpointNotUpdating is a wrapper that calls [ServingEndpointsAPI.WaitGetServingEndpointNotUpdating] and waits to reach NOT_UPDATING state.
type WaitGetServingEndpointNotUpdating[R any] struct {
	Response *R
	Name     string `json:"name"`
	Poll     func(time.Duration, func(*ServingEndpointDetailed)) (*ServingEndpointDetailed, error)
	callback func(*ServingEndpointDetailed)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetServingEndpointNotUpdating[R]) OnProgress(callback func(*ServingEndpointDetailed)) *WaitGetServingEndpointNotUpdating[R] {
	w.callback = callback
	return w
}

// Get the ServingEndpointDetailed with the default timeout of 20 minutes.
func (w *WaitGetServingEndpointNotUpdating[R]) Get() (*ServingEndpointDetailed, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the ServingEndpointDetailed with custom timeout.
func (w *WaitGetServingEndpointNotUpdating[R]) GetWithTimeout(timeout time.Duration) (*ServingEndpointDetailed, error) {
	return w.Poll(timeout, w.callback)
}

// Get build logs for a served model.
//
// Retrieves the build logs associated with the provided served model.
func (a *ServingEndpointsAPI) BuildLogs(ctx context.Context, request BuildLogsRequest) (*BuildLogsResponse, error) {
	return a.impl.BuildLogs(ctx, request)
}

// Get build logs for a served model.
//
// Retrieves the build logs associated with the provided served model.
func (a *ServingEndpointsAPI) BuildLogsByNameAndServedModelName(ctx context.Context, name string, servedModelName string) (*BuildLogsResponse, error) {
	return a.impl.BuildLogs(ctx, BuildLogsRequest{
		Name:            name,
		ServedModelName: servedModelName,
	})
}

// Create a new serving endpoint.
func (a *ServingEndpointsAPI) Create(ctx context.Context, createServingEndpoint CreateServingEndpoint) (*WaitGetServingEndpointNotUpdating[ServingEndpointDetailed], error) {
	servingEndpointDetailed, err := a.impl.Create(ctx, createServingEndpoint)
	if err != nil {
		return nil, err
	}
	return &WaitGetServingEndpointNotUpdating[ServingEndpointDetailed]{
		Response: servingEndpointDetailed,
		Name:     servingEndpointDetailed.Name,
		Poll: func(timeout time.Duration, callback func(*ServingEndpointDetailed)) (*ServingEndpointDetailed, error) {
			return a.WaitGetServingEndpointNotUpdating(ctx, servingEndpointDetailed.Name, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [ServingEndpointsAPI.Create] and waits to reach NOT_UPDATING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[ServingEndpointDetailed](60*time.Minute) functional option.
//
// Deprecated: use [ServingEndpointsAPI.Create].Get() or [ServingEndpointsAPI.WaitGetServingEndpointNotUpdating]
func (a *ServingEndpointsAPI) CreateAndWait(ctx context.Context, createServingEndpoint CreateServingEndpoint, options ...retries.Option[ServingEndpointDetailed]) (*ServingEndpointDetailed, error) {
	wait, err := a.Create(ctx, createServingEndpoint)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[ServingEndpointDetailed]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *ServingEndpointDetailed) {
		for _, o := range options {
			o(&retries.Info[ServingEndpointDetailed]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Delete a serving endpoint.
func (a *ServingEndpointsAPI) Delete(ctx context.Context, request DeleteServingEndpointRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a serving endpoint.
func (a *ServingEndpointsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteServingEndpointRequest{
		Name: name,
	})
}

// Get metrics of a serving endpoint.
//
// Retrieves the metrics associated with the provided serving endpoint in either
// Prometheus or OpenMetrics exposition format.
func (a *ServingEndpointsAPI) ExportMetrics(ctx context.Context, request ExportMetricsRequest) error {
	return a.impl.ExportMetrics(ctx, request)
}

// Get metrics of a serving endpoint.
//
// Retrieves the metrics associated with the provided serving endpoint in either
// Prometheus or OpenMetrics exposition format.
func (a *ServingEndpointsAPI) ExportMetricsByName(ctx context.Context, name string) error {
	return a.impl.ExportMetrics(ctx, ExportMetricsRequest{
		Name: name,
	})
}

// Get a single serving endpoint.
//
// Retrieves the details for a single serving endpoint.
func (a *ServingEndpointsAPI) Get(ctx context.Context, request GetServingEndpointRequest) (*ServingEndpointDetailed, error) {
	return a.impl.Get(ctx, request)
}

// Get a single serving endpoint.
//
// Retrieves the details for a single serving endpoint.
func (a *ServingEndpointsAPI) GetByName(ctx context.Context, name string) (*ServingEndpointDetailed, error) {
	return a.impl.Get(ctx, GetServingEndpointRequest{
		Name: name,
	})
}

// Get the schema for a serving endpoint.
//
// Get the query schema of the serving endpoint in OpenAPI format. The schema
// contains information for the supported paths, input and output format and
// datatypes.
func (a *ServingEndpointsAPI) GetOpenApi(ctx context.Context, request GetOpenApiRequest) error {
	return a.impl.GetOpenApi(ctx, request)
}

// Get the schema for a serving endpoint.
//
// Get the query schema of the serving endpoint in OpenAPI format. The schema
// contains information for the supported paths, input and output format and
// datatypes.
func (a *ServingEndpointsAPI) GetOpenApiByName(ctx context.Context, name string) error {
	return a.impl.GetOpenApi(ctx, GetOpenApiRequest{
		Name: name,
	})
}

// Get serving endpoint permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *ServingEndpointsAPI) GetPermissionLevels(ctx context.Context, request GetServingEndpointPermissionLevelsRequest) (*GetServingEndpointPermissionLevelsResponse, error) {
	return a.impl.GetPermissionLevels(ctx, request)
}

// Get serving endpoint permission levels.
//
// Gets the permission levels that a user can have on an object.
func (a *ServingEndpointsAPI) GetPermissionLevelsByServingEndpointId(ctx context.Context, servingEndpointId string) (*GetServingEndpointPermissionLevelsResponse, error) {
	return a.impl.GetPermissionLevels(ctx, GetServingEndpointPermissionLevelsRequest{
		ServingEndpointId: servingEndpointId,
	})
}

// Get serving endpoint permissions.
//
// Gets the permissions of a serving endpoint. Serving endpoints can inherit
// permissions from their root object.
func (a *ServingEndpointsAPI) GetPermissions(ctx context.Context, request GetServingEndpointPermissionsRequest) (*ServingEndpointPermissions, error) {
	return a.impl.GetPermissions(ctx, request)
}

// Get serving endpoint permissions.
//
// Gets the permissions of a serving endpoint. Serving endpoints can inherit
// permissions from their root object.
func (a *ServingEndpointsAPI) GetPermissionsByServingEndpointId(ctx context.Context, servingEndpointId string) (*ServingEndpointPermissions, error) {
	return a.impl.GetPermissions(ctx, GetServingEndpointPermissionsRequest{
		ServingEndpointId: servingEndpointId,
	})
}

// Get all serving endpoints.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ServingEndpointsAPI) List(ctx context.Context) listing.Iterator[ServingEndpoint] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListEndpointsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListEndpointsResponse) []ServingEndpoint {
		return resp.Endpoints
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// Get all serving endpoints.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ServingEndpointsAPI) ListAll(ctx context.Context) ([]ServingEndpoint, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[ServingEndpoint](ctx, iterator)
}

// Get the latest logs for a served model.
//
// Retrieves the service logs associated with the provided served model.
func (a *ServingEndpointsAPI) Logs(ctx context.Context, request LogsRequest) (*ServerLogsResponse, error) {
	return a.impl.Logs(ctx, request)
}

// Get the latest logs for a served model.
//
// Retrieves the service logs associated with the provided served model.
func (a *ServingEndpointsAPI) LogsByNameAndServedModelName(ctx context.Context, name string, servedModelName string) (*ServerLogsResponse, error) {
	return a.impl.Logs(ctx, LogsRequest{
		Name:            name,
		ServedModelName: servedModelName,
	})
}

// Update tags of a serving endpoint.
//
// Used to batch add and delete tags from a serving endpoint with a single API
// call.
func (a *ServingEndpointsAPI) Patch(ctx context.Context, request PatchServingEndpointTags) ([]EndpointTag, error) {
	return a.impl.Patch(ctx, request)
}

// Update rate limits of a serving endpoint.
//
// Used to update the rate limits of a serving endpoint. NOTE: only external and
// foundation model endpoints are supported as of now.
func (a *ServingEndpointsAPI) Put(ctx context.Context, request PutRequest) (*PutResponse, error) {
	return a.impl.Put(ctx, request)
}

// Query a serving endpoint.
func (a *ServingEndpointsAPI) Query(ctx context.Context, request QueryEndpointInput) (*QueryEndpointResponse, error) {
	return a.impl.Query(ctx, request)
}

// Set serving endpoint permissions.
//
// Sets permissions on a serving endpoint. Serving endpoints can inherit
// permissions from their root object.
func (a *ServingEndpointsAPI) SetPermissions(ctx context.Context, request ServingEndpointPermissionsRequest) (*ServingEndpointPermissions, error) {
	return a.impl.SetPermissions(ctx, request)
}

// Update config of a serving endpoint.
//
// Updates any combination of the serving endpoint's served entities, the
// compute configuration of those served entities, and the endpoint's traffic
// config. An endpoint that already has an update in progress can not be updated
// until the current update completes or fails.
func (a *ServingEndpointsAPI) UpdateConfig(ctx context.Context, endpointCoreConfigInput EndpointCoreConfigInput) (*WaitGetServingEndpointNotUpdating[ServingEndpointDetailed], error) {
	servingEndpointDetailed, err := a.impl.UpdateConfig(ctx, endpointCoreConfigInput)
	if err != nil {
		return nil, err
	}
	return &WaitGetServingEndpointNotUpdating[ServingEndpointDetailed]{
		Response: servingEndpointDetailed,
		Name:     servingEndpointDetailed.Name,
		Poll: func(timeout time.Duration, callback func(*ServingEndpointDetailed)) (*ServingEndpointDetailed, error) {
			return a.WaitGetServingEndpointNotUpdating(ctx, servingEndpointDetailed.Name, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [ServingEndpointsAPI.UpdateConfig] and waits to reach NOT_UPDATING state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[ServingEndpointDetailed](60*time.Minute) functional option.
//
// Deprecated: use [ServingEndpointsAPI.UpdateConfig].Get() or [ServingEndpointsAPI.WaitGetServingEndpointNotUpdating]
func (a *ServingEndpointsAPI) UpdateConfigAndWait(ctx context.Context, endpointCoreConfigInput EndpointCoreConfigInput, options ...retries.Option[ServingEndpointDetailed]) (*ServingEndpointDetailed, error) {
	wait, err := a.UpdateConfig(ctx, endpointCoreConfigInput)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[ServingEndpointDetailed]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *ServingEndpointDetailed) {
		for _, o := range options {
			o(&retries.Info[ServingEndpointDetailed]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Update serving endpoint permissions.
//
// Updates the permissions on a serving endpoint. Serving endpoints can inherit
// permissions from their root object.
func (a *ServingEndpointsAPI) UpdatePermissions(ctx context.Context, request ServingEndpointPermissionsRequest) (*ServingEndpointPermissions, error) {
	return a.impl.UpdatePermissions(ctx, request)
}
