// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Metastore Assignments, Account Metastores, Account Storage Credentials, Artifact Allowlists, Catalogs, Connections, Credentials, External Locations, Functions, Grants, Metastores, Model Versions, Online Tables, Quality Monitors, Registered Models, Resource Quotas, Schemas, Storage Credentials, System Schemas, Table Constraints, Tables, Temporary Table Credentials, Volumes, Workspace Bindings, etc.
package catalog

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AccountMetastoreAssignmentsInterface interface {

	// Assigns a workspace to a metastore.
	//
	// Creates an assignment to a metastore for a workspace
	Create(ctx context.Context, request AccountsCreateMetastoreAssignment) error

	// Delete a metastore assignment.
	//
	// Deletes a metastore assignment to a workspace, leaving the workspace with no
	// metastore.
	Delete(ctx context.Context, request DeleteAccountMetastoreAssignmentRequest) error

	// Delete a metastore assignment.
	//
	// Deletes a metastore assignment to a workspace, leaving the workspace with no
	// metastore.
	DeleteByWorkspaceIdAndMetastoreId(ctx context.Context, workspaceId int64, metastoreId string) error

	// Gets the metastore assignment for a workspace.
	//
	// Gets the metastore assignment, if any, for the workspace specified by ID. If
	// the workspace is assigned a metastore, the mappig will be returned. If no
	// metastore is assigned to the workspace, the assignment will not be found and
	// a 404 returned.
	Get(ctx context.Context, request GetAccountMetastoreAssignmentRequest) (*AccountsMetastoreAssignment, error)

	// Gets the metastore assignment for a workspace.
	//
	// Gets the metastore assignment, if any, for the workspace specified by ID. If
	// the workspace is assigned a metastore, the mappig will be returned. If no
	// metastore is assigned to the workspace, the assignment will not be found and
	// a 404 returned.
	GetByWorkspaceId(ctx context.Context, workspaceId int64) (*AccountsMetastoreAssignment, error)

	// Get all workspaces assigned to a metastore.
	//
	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) listing.Iterator[int64]

	// Get all workspaces assigned to a metastore.
	//
	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) ([]int64, error)

	// Get all workspaces assigned to a metastore.
	//
	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountMetastoreAssignmentsResponse, error)

	// Updates a metastore assignment to a workspaces.
	//
	// Updates an assignment to a metastore for a workspace. Currently, only the
	// default catalog may be updated.
	Update(ctx context.Context, request AccountsUpdateMetastoreAssignment) error
}

func NewAccountMetastoreAssignments(client *client.DatabricksClient) *AccountMetastoreAssignmentsAPI {
	return &AccountMetastoreAssignmentsAPI{
		accountMetastoreAssignmentsImpl: accountMetastoreAssignmentsImpl{
			client: client,
		},
	}
}

// These APIs manage metastore assignments to a workspace.
type AccountMetastoreAssignmentsAPI struct {
	accountMetastoreAssignmentsImpl
}

// Delete a metastore assignment.
//
// Deletes a metastore assignment to a workspace, leaving the workspace with no
// metastore.
func (a *AccountMetastoreAssignmentsAPI) DeleteByWorkspaceIdAndMetastoreId(ctx context.Context, workspaceId int64, metastoreId string) error {
	return a.accountMetastoreAssignmentsImpl.Delete(ctx, DeleteAccountMetastoreAssignmentRequest{
		WorkspaceId: workspaceId,
		MetastoreId: metastoreId,
	})
}

// Gets the metastore assignment for a workspace.
//
// Gets the metastore assignment, if any, for the workspace specified by ID. If
// the workspace is assigned a metastore, the mappig will be returned. If no
// metastore is assigned to the workspace, the assignment will not be found and
// a 404 returned.
func (a *AccountMetastoreAssignmentsAPI) GetByWorkspaceId(ctx context.Context, workspaceId int64) (*AccountsMetastoreAssignment, error) {
	return a.accountMetastoreAssignmentsImpl.Get(ctx, GetAccountMetastoreAssignmentRequest{
		WorkspaceId: workspaceId,
	})
}

// Get all workspaces assigned to a metastore.
//
// Gets a list of all Databricks workspace IDs that have been assigned to given
// metastore.
func (a *AccountMetastoreAssignmentsAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountMetastoreAssignmentsResponse, error) {
	return a.accountMetastoreAssignmentsImpl.internalList(ctx, ListAccountMetastoreAssignmentsRequest{
		MetastoreId: metastoreId,
	})
}

type AccountMetastoresInterface interface {

	// Create metastore.
	//
	// Creates a Unity Catalog metastore.
	Create(ctx context.Context, request AccountsCreateMetastore) (*AccountsMetastoreInfo, error)

	// Delete a metastore.
	//
	// Deletes a Unity Catalog metastore for an account, both specified by ID.
	Delete(ctx context.Context, request DeleteAccountMetastoreRequest) error

	// Delete a metastore.
	//
	// Deletes a Unity Catalog metastore for an account, both specified by ID.
	DeleteByMetastoreId(ctx context.Context, metastoreId string) error

	// Get a metastore.
	//
	// Gets a Unity Catalog metastore from an account, both specified by ID.
	Get(ctx context.Context, request GetAccountMetastoreRequest) (*AccountsMetastoreInfo, error)

	// Get a metastore.
	//
	// Gets a Unity Catalog metastore from an account, both specified by ID.
	GetByMetastoreId(ctx context.Context, metastoreId string) (*AccountsMetastoreInfo, error)

	// Get all metastores associated with an account.
	//
	// Gets all Unity Catalog metastores associated with an account specified by ID.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[MetastoreInfo]

	// Get all metastores associated with an account.
	//
	// Gets all Unity Catalog metastores associated with an account specified by ID.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]MetastoreInfo, error)

	// Update a metastore.
	//
	// Updates an existing Unity Catalog metastore.
	Update(ctx context.Context, request AccountsUpdateMetastore) (*AccountsMetastoreInfo, error)
}

func NewAccountMetastores(client *client.DatabricksClient) *AccountMetastoresAPI {
	return &AccountMetastoresAPI{
		accountMetastoresImpl: accountMetastoresImpl{
			client: client,
		},
	}
}

// These APIs manage Unity Catalog metastores for an account. A metastore
// contains catalogs that can be associated with workspaces
type AccountMetastoresAPI struct {
	accountMetastoresImpl
}

// Delete a metastore.
//
// Deletes a Unity Catalog metastore for an account, both specified by ID.
func (a *AccountMetastoresAPI) DeleteByMetastoreId(ctx context.Context, metastoreId string) error {
	return a.accountMetastoresImpl.Delete(ctx, DeleteAccountMetastoreRequest{
		MetastoreId: metastoreId,
	})
}

// Get a metastore.
//
// Gets a Unity Catalog metastore from an account, both specified by ID.
func (a *AccountMetastoresAPI) GetByMetastoreId(ctx context.Context, metastoreId string) (*AccountsMetastoreInfo, error) {
	return a.accountMetastoresImpl.Get(ctx, GetAccountMetastoreRequest{
		MetastoreId: metastoreId,
	})
}

type AccountStorageCredentialsInterface interface {

	// Create a storage credential.
	//
	// Creates a new storage credential. The request object is specific to the
	// cloud:
	//
	// * **AwsIamRole** for AWS credentials * **AzureServicePrincipal** for Azure
	// credentials * **GcpServiceAcountKey** for GCP credentials.
	//
	// The caller must be a metastore admin and have the
	// **CREATE_STORAGE_CREDENTIAL** privilege on the metastore.
	Create(ctx context.Context, request AccountsCreateStorageCredential) (*AccountsStorageCredentialInfo, error)

	// Delete a storage credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	Delete(ctx context.Context, request DeleteAccountStorageCredentialRequest) error

	// Delete a storage credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	DeleteByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) error

	// Gets the named storage credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have a level of privilege on
	// the storage credential.
	Get(ctx context.Context, request GetAccountStorageCredentialRequest) (*AccountsStorageCredentialInfo, error)

	// Gets the named storage credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have a level of privilege on
	// the storage credential.
	GetByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsStorageCredentialInfo, error)

	// Get all storage credentials assigned to a metastore.
	//
	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAccountStorageCredentialsRequest) listing.Iterator[StorageCredentialInfo]

	// Get all storage credentials assigned to a metastore.
	//
	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAccountStorageCredentialsRequest) ([]StorageCredentialInfo, error)

	// Get all storage credentials assigned to a metastore.
	//
	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountStorageCredentialsResponse, error)

	// Updates a storage credential.
	//
	// Updates a storage credential on the metastore. The caller must be the owner
	// of the storage credential. If the caller is a metastore admin, only the
	// __owner__ credential can be changed.
	Update(ctx context.Context, request AccountsUpdateStorageCredential) (*AccountsStorageCredentialInfo, error)
}

func NewAccountStorageCredentials(client *client.DatabricksClient) *AccountStorageCredentialsAPI {
	return &AccountStorageCredentialsAPI{
		accountStorageCredentialsImpl: accountStorageCredentialsImpl{
			client: client,
		},
	}
}

// These APIs manage storage credentials for a particular metastore.
type AccountStorageCredentialsAPI struct {
	accountStorageCredentialsImpl
}

// Delete a storage credential.
//
// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *AccountStorageCredentialsAPI) DeleteByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) error {
	return a.accountStorageCredentialsImpl.Delete(ctx, DeleteAccountStorageCredentialRequest{
		MetastoreId:           metastoreId,
		StorageCredentialName: storageCredentialName,
	})
}

// Gets the named storage credential.
//
// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have a level of privilege on
// the storage credential.
func (a *AccountStorageCredentialsAPI) GetByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsStorageCredentialInfo, error) {
	return a.accountStorageCredentialsImpl.Get(ctx, GetAccountStorageCredentialRequest{
		MetastoreId:           metastoreId,
		StorageCredentialName: storageCredentialName,
	})
}

// Get all storage credentials assigned to a metastore.
//
// Gets a list of all storage credentials that have been assigned to given
// metastore.
func (a *AccountStorageCredentialsAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountStorageCredentialsResponse, error) {
	return a.accountStorageCredentialsImpl.internalList(ctx, ListAccountStorageCredentialsRequest{
		MetastoreId: metastoreId,
	})
}

type ArtifactAllowlistsInterface interface {

	// Get an artifact allowlist.
	//
	// Get the artifact allowlist of a certain artifact type. The caller must be a
	// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	Get(ctx context.Context, request GetArtifactAllowlistRequest) (*ArtifactAllowlistInfo, error)

	// Get an artifact allowlist.
	//
	// Get the artifact allowlist of a certain artifact type. The caller must be a
	// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	GetByArtifactType(ctx context.Context, artifactType ArtifactType) (*ArtifactAllowlistInfo, error)

	// Set an artifact allowlist.
	//
	// Set the artifact allowlist of a certain artifact type. The whole artifact
	// allowlist is replaced with the new allowlist. The caller must be a metastore
	// admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	Update(ctx context.Context, request SetArtifactAllowlist) (*ArtifactAllowlistInfo, error)
}

func NewArtifactAllowlists(client *client.DatabricksClient) *ArtifactAllowlistsAPI {
	return &ArtifactAllowlistsAPI{
		artifactAllowlistsImpl: artifactAllowlistsImpl{
			client: client,
		},
	}
}

// In Databricks Runtime 13.3 and above, you can add libraries and init scripts
// to the `allowlist` in UC so that users can leverage these artifacts on
// compute configured with shared access mode.
type ArtifactAllowlistsAPI struct {
	artifactAllowlistsImpl
}

// Get an artifact allowlist.
//
// Get the artifact allowlist of a certain artifact type. The caller must be a
// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
func (a *ArtifactAllowlistsAPI) GetByArtifactType(ctx context.Context, artifactType ArtifactType) (*ArtifactAllowlistInfo, error) {
	return a.artifactAllowlistsImpl.Get(ctx, GetArtifactAllowlistRequest{
		ArtifactType: artifactType,
	})
}

type CatalogsInterface interface {

	// Create a catalog.
	//
	// Creates a new catalog instance in the parent metastore if the caller is a
	// metastore admin or has the **CREATE_CATALOG** privilege.
	Create(ctx context.Context, request CreateCatalog) (*CatalogInfo, error)

	// Delete a catalog.
	//
	// Deletes the catalog that matches the supplied name. The caller must be a
	// metastore admin or the owner of the catalog.
	Delete(ctx context.Context, request DeleteCatalogRequest) error

	// Delete a catalog.
	//
	// Deletes the catalog that matches the supplied name. The caller must be a
	// metastore admin or the owner of the catalog.
	DeleteByName(ctx context.Context, name string) error

	// Get a catalog.
	//
	// Gets the specified catalog in a metastore. The caller must be a metastore
	// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
	// privilege set for their account.
	Get(ctx context.Context, request GetCatalogRequest) (*CatalogInfo, error)

	// Get a catalog.
	//
	// Gets the specified catalog in a metastore. The caller must be a metastore
	// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
	// privilege set for their account.
	GetByName(ctx context.Context, name string) (*CatalogInfo, error)

	// List catalogs.
	//
	// Gets an array of catalogs in the metastore. If the caller is the metastore
	// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
	// caller (or for which the caller has the **USE_CATALOG** privilege) will be
	// retrieved. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListCatalogsRequest) listing.Iterator[CatalogInfo]

	// List catalogs.
	//
	// Gets an array of catalogs in the metastore. If the caller is the metastore
	// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
	// caller (or for which the caller has the **USE_CATALOG** privilege) will be
	// retrieved. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListCatalogsRequest) ([]CatalogInfo, error)

	// Update a catalog.
	//
	// Updates the catalog that matches the supplied name. The caller must be either
	// the owner of the catalog, or a metastore admin (when changing the owner field
	// of the catalog).
	Update(ctx context.Context, request UpdateCatalog) (*CatalogInfo, error)
}

func NewCatalogs(client *client.DatabricksClient) *CatalogsAPI {
	return &CatalogsAPI{
		catalogsImpl: catalogsImpl{
			client: client,
		},
	}
}

// A catalog is the first layer of Unity Catalog’s three-level namespace.
// It’s used to organize your data assets. Users can see all catalogs on which
// they have been assigned the USE_CATALOG data permission.
//
// In Unity Catalog, admins and data stewards manage users and their access to
// data centrally across all of the workspaces in a Databricks account. Users in
// different workspaces can share access to the same data, depending on
// privileges granted centrally in Unity Catalog.
type CatalogsAPI struct {
	catalogsImpl
}

// Delete a catalog.
//
// Deletes the catalog that matches the supplied name. The caller must be a
// metastore admin or the owner of the catalog.
func (a *CatalogsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.catalogsImpl.Delete(ctx, DeleteCatalogRequest{
		Name: name,
	})
}

// Get a catalog.
//
// Gets the specified catalog in a metastore. The caller must be a metastore
// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
// privilege set for their account.
func (a *CatalogsAPI) GetByName(ctx context.Context, name string) (*CatalogInfo, error) {
	return a.catalogsImpl.Get(ctx, GetCatalogRequest{
		Name: name,
	})
}

type ConnectionsInterface interface {

	// Create a connection.
	//
	// Creates a new connection
	//
	// Creates a new connection to an external data source. It allows users to
	// specify connection details and configurations for interaction with the
	// external server.
	Create(ctx context.Context, request CreateConnection) (*ConnectionInfo, error)

	// Delete a connection.
	//
	// Deletes the connection that matches the supplied name.
	Delete(ctx context.Context, request DeleteConnectionRequest) error

	// Delete a connection.
	//
	// Deletes the connection that matches the supplied name.
	DeleteByName(ctx context.Context, name string) error

	// Get a connection.
	//
	// Gets a connection from it's name.
	Get(ctx context.Context, request GetConnectionRequest) (*ConnectionInfo, error)

	// Get a connection.
	//
	// Gets a connection from it's name.
	GetByName(ctx context.Context, name string) (*ConnectionInfo, error)

	// List connections.
	//
	// List all connections.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListConnectionsRequest) listing.Iterator[ConnectionInfo]

	// List connections.
	//
	// List all connections.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListConnectionsRequest) ([]ConnectionInfo, error)

	// ConnectionInfoNameToFullNameMap calls [ConnectionsAPI.ListAll] and creates a map of results with [ConnectionInfo].Name as key and [ConnectionInfo].FullName as value.
	//
	// Returns an error if there's more than one [ConnectionInfo] with the same .Name.
	//
	// Note: All [ConnectionInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	ConnectionInfoNameToFullNameMap(ctx context.Context, request ListConnectionsRequest) (map[string]string, error)

	// Update a connection.
	//
	// Updates the connection that matches the supplied name.
	Update(ctx context.Context, request UpdateConnection) (*ConnectionInfo, error)
}

func NewConnections(client *client.DatabricksClient) *ConnectionsAPI {
	return &ConnectionsAPI{
		connectionsImpl: connectionsImpl{
			client: client,
		},
	}
}

// Connections allow for creating a connection to an external data source.
//
// A connection is an abstraction of an external data source that can be
// connected from Databricks Compute. Creating a connection object is the first
// step to managing external data sources within Unity Catalog, with the second
// step being creating a data object (catalog, schema, or table) using the
// connection. Data objects derived from a connection can be written to or read
// from similar to other Unity Catalog data objects based on cloud storage.
// Users may create different types of connections with each connection having a
// unique set of configuration options to support credential management and
// other settings.
type ConnectionsAPI struct {
	connectionsImpl
}

// Delete a connection.
//
// Deletes the connection that matches the supplied name.
func (a *ConnectionsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.connectionsImpl.Delete(ctx, DeleteConnectionRequest{
		Name: name,
	})
}

// Get a connection.
//
// Gets a connection from it's name.
func (a *ConnectionsAPI) GetByName(ctx context.Context, name string) (*ConnectionInfo, error) {
	return a.connectionsImpl.Get(ctx, GetConnectionRequest{
		Name: name,
	})
}

// ConnectionInfoNameToFullNameMap calls [ConnectionsAPI.ListAll] and creates a map of results with [ConnectionInfo].Name as key and [ConnectionInfo].FullName as value.
//
// Returns an error if there's more than one [ConnectionInfo] with the same .Name.
//
// Note: All [ConnectionInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConnectionsAPI) ConnectionInfoNameToFullNameMap(ctx context.Context, request ListConnectionsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

type CredentialsInterface interface {

	// Create a credential.
	//
	// Creates a new credential. The type of credential to be created is determined
	// by the **purpose** field, which should be either **SERVICE** or **STORAGE**.
	//
	// The caller must be a metastore admin or have the metastore privilege
	// **CREATE_STORAGE_CREDENTIAL** for storage credentials, or
	// **CREATE_SERVICE_CREDENTIAL** for service credentials.
	CreateCredential(ctx context.Context, request CreateCredentialRequest) (*CredentialInfo, error)

	// Delete a credential.
	//
	// Deletes a service or storage credential from the metastore. The caller must
	// be an owner of the credential.
	DeleteCredential(ctx context.Context, request DeleteCredentialRequest) error

	// Delete a credential.
	//
	// Deletes a service or storage credential from the metastore. The caller must
	// be an owner of the credential.
	DeleteCredentialByNameArg(ctx context.Context, nameArg string) error

	// Generate a temporary service credential.
	//
	// Returns a set of temporary credentials generated using the specified service
	// credential. The caller must be a metastore admin or have the metastore
	// privilege **ACCESS** on the service credential.
	GenerateTemporaryServiceCredential(ctx context.Context, request GenerateTemporaryServiceCredentialRequest) (*TemporaryCredentials, error)

	// Get a credential.
	//
	// Gets a service or storage credential from the metastore. The caller must be a
	// metastore admin, the owner of the credential, or have any permission on the
	// credential.
	GetCredential(ctx context.Context, request GetCredentialRequest) (*CredentialInfo, error)

	// Get a credential.
	//
	// Gets a service or storage credential from the metastore. The caller must be a
	// metastore admin, the owner of the credential, or have any permission on the
	// credential.
	GetCredentialByNameArg(ctx context.Context, nameArg string) (*CredentialInfo, error)

	// List credentials.
	//
	// Gets an array of credentials (as __CredentialInfo__ objects).
	//
	// The array is limited to only the credentials that the caller has permission
	// to access. If the caller is a metastore admin, retrieval of credentials is
	// unrestricted. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListCredentials(ctx context.Context, request ListCredentialsRequest) listing.Iterator[CredentialInfo]

	// List credentials.
	//
	// Gets an array of credentials (as __CredentialInfo__ objects).
	//
	// The array is limited to only the credentials that the caller has permission
	// to access. If the caller is a metastore admin, retrieval of credentials is
	// unrestricted. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListCredentialsAll(ctx context.Context, request ListCredentialsRequest) ([]CredentialInfo, error)

	// Update a credential.
	//
	// Updates a service or storage credential on the metastore.
	//
	// The caller must be the owner of the credential or a metastore admin or have
	// the `MANAGE` permission. If the caller is a metastore admin, only the
	// __owner__ field can be changed.
	UpdateCredential(ctx context.Context, request UpdateCredentialRequest) (*CredentialInfo, error)

	// Validate a credential.
	//
	// Validates a credential.
	//
	// For service credentials (purpose is **SERVICE**), either the
	// __credential_name__ or the cloud-specific credential must be provided.
	//
	// For storage credentials (purpose is **STORAGE**), at least one of
	// __external_location_name__ and __url__ need to be provided. If only one of
	// them is provided, it will be used for validation. And if both are provided,
	// the __url__ will be used for validation, and __external_location_name__ will
	// be ignored when checking overlapping urls. Either the __credential_name__ or
	// the cloud-specific credential must be provided.
	//
	// The caller must be a metastore admin or the credential owner or have the
	// required permission on the metastore and the credential (e.g.,
	// **CREATE_EXTERNAL_LOCATION** when purpose is **STORAGE**).
	ValidateCredential(ctx context.Context, request ValidateCredentialRequest) (*ValidateCredentialResponse, error)
}

func NewCredentials(client *client.DatabricksClient) *CredentialsAPI {
	return &CredentialsAPI{
		credentialsImpl: credentialsImpl{
			client: client,
		},
	}
}

// A credential represents an authentication and authorization mechanism for
// accessing services on your cloud tenant. Each credential is subject to Unity
// Catalog access-control policies that control which users and groups can
// access the credential.
//
// To create credentials, you must be a Databricks account admin or have the
// `CREATE SERVICE CREDENTIAL` privilege. The user who creates the credential
// can delegate ownership to another user or group to manage permissions on it.
type CredentialsAPI struct {
	credentialsImpl
}

// Delete a credential.
//
// Deletes a service or storage credential from the metastore. The caller must
// be an owner of the credential.
func (a *CredentialsAPI) DeleteCredentialByNameArg(ctx context.Context, nameArg string) error {
	return a.credentialsImpl.DeleteCredential(ctx, DeleteCredentialRequest{
		NameArg: nameArg,
	})
}

// Get a credential.
//
// Gets a service or storage credential from the metastore. The caller must be a
// metastore admin, the owner of the credential, or have any permission on the
// credential.
func (a *CredentialsAPI) GetCredentialByNameArg(ctx context.Context, nameArg string) (*CredentialInfo, error) {
	return a.credentialsImpl.GetCredential(ctx, GetCredentialRequest{
		NameArg: nameArg,
	})
}

type ExternalLocationsInterface interface {

	// Create an external location.
	//
	// Creates a new external location entry in the metastore. The caller must be a
	// metastore admin or have the **CREATE_EXTERNAL_LOCATION** privilege on both
	// the metastore and the associated storage credential.
	Create(ctx context.Context, request CreateExternalLocation) (*ExternalLocationInfo, error)

	// Delete an external location.
	//
	// Deletes the specified external location from the metastore. The caller must
	// be the owner of the external location.
	Delete(ctx context.Context, request DeleteExternalLocationRequest) error

	// Delete an external location.
	//
	// Deletes the specified external location from the metastore. The caller must
	// be the owner of the external location.
	DeleteByName(ctx context.Context, name string) error

	// Get an external location.
	//
	// Gets an external location from the metastore. The caller must be either a
	// metastore admin, the owner of the external location, or a user that has some
	// privilege on the external location.
	Get(ctx context.Context, request GetExternalLocationRequest) (*ExternalLocationInfo, error)

	// Get an external location.
	//
	// Gets an external location from the metastore. The caller must be either a
	// metastore admin, the owner of the external location, or a user that has some
	// privilege on the external location.
	GetByName(ctx context.Context, name string) (*ExternalLocationInfo, error)

	// List external locations.
	//
	// Gets an array of external locations (__ExternalLocationInfo__ objects) from
	// the metastore. The caller must be a metastore admin, the owner of the
	// external location, or a user that has some privilege on the external
	// location. There is no guarantee of a specific ordering of the elements in the
	// array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListExternalLocationsRequest) listing.Iterator[ExternalLocationInfo]

	// List external locations.
	//
	// Gets an array of external locations (__ExternalLocationInfo__ objects) from
	// the metastore. The caller must be a metastore admin, the owner of the
	// external location, or a user that has some privilege on the external
	// location. There is no guarantee of a specific ordering of the elements in the
	// array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListExternalLocationsRequest) ([]ExternalLocationInfo, error)

	// Update an external location.
	//
	// Updates an external location in the metastore. The caller must be the owner
	// of the external location, or be a metastore admin. In the second case, the
	// admin can only update the name of the external location.
	Update(ctx context.Context, request UpdateExternalLocation) (*ExternalLocationInfo, error)
}

func NewExternalLocations(client *client.DatabricksClient) *ExternalLocationsAPI {
	return &ExternalLocationsAPI{
		externalLocationsImpl: externalLocationsImpl{
			client: client,
		},
	}
}

// An external location is an object that combines a cloud storage path with a
// storage credential that authorizes access to the cloud storage path. Each
// external location is subject to Unity Catalog access-control policies that
// control which users and groups can access the credential. If a user does not
// have access to an external location in Unity Catalog, the request fails and
// Unity Catalog does not attempt to authenticate to your cloud tenant on the
// user’s behalf.
//
// Databricks recommends using external locations rather than using storage
// credentials directly.
//
// To create external locations, you must be a metastore admin or a user with
// the **CREATE_EXTERNAL_LOCATION** privilege.
type ExternalLocationsAPI struct {
	externalLocationsImpl
}

// Delete an external location.
//
// Deletes the specified external location from the metastore. The caller must
// be the owner of the external location.
func (a *ExternalLocationsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.externalLocationsImpl.Delete(ctx, DeleteExternalLocationRequest{
		Name: name,
	})
}

// Get an external location.
//
// Gets an external location from the metastore. The caller must be either a
// metastore admin, the owner of the external location, or a user that has some
// privilege on the external location.
func (a *ExternalLocationsAPI) GetByName(ctx context.Context, name string) (*ExternalLocationInfo, error) {
	return a.externalLocationsImpl.Get(ctx, GetExternalLocationRequest{
		Name: name,
	})
}

type FunctionsInterface interface {

	// Create a function.
	//
	// **WARNING: This API is experimental and will change in future versions**
	//
	// Creates a new function
	//
	// The user must have the following permissions in order for the function to be
	// created: - **USE_CATALOG** on the function's parent catalog - **USE_SCHEMA**
	// and **CREATE_FUNCTION** on the function's parent schema
	Create(ctx context.Context, request CreateFunctionRequest) (*FunctionInfo, error)

	// Delete a function.
	//
	// Deletes the function that matches the supplied name. For the deletion to
	// succeed, the user must satisfy one of the following conditions: - Is the
	// owner of the function's parent catalog - Is the owner of the function's
	// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
	// Is the owner of the function itself and have both the **USE_CATALOG**
	// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
	// parent schema
	Delete(ctx context.Context, request DeleteFunctionRequest) error

	// Delete a function.
	//
	// Deletes the function that matches the supplied name. For the deletion to
	// succeed, the user must satisfy one of the following conditions: - Is the
	// owner of the function's parent catalog - Is the owner of the function's
	// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
	// Is the owner of the function itself and have both the **USE_CATALOG**
	// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
	// parent schema
	DeleteByName(ctx context.Context, name string) error

	// Get a function.
	//
	// Gets a function from within a parent catalog and schema. For the fetch to
	// succeed, the user must satisfy one of the following requirements: - Is a
	// metastore admin - Is an owner of the function's parent catalog - Have the
	// **USE_CATALOG** privilege on the function's parent catalog and be the owner
	// of the function - Have the **USE_CATALOG** privilege on the function's parent
	// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
	// the **EXECUTE** privilege on the function itself
	Get(ctx context.Context, request GetFunctionRequest) (*FunctionInfo, error)

	// Get a function.
	//
	// Gets a function from within a parent catalog and schema. For the fetch to
	// succeed, the user must satisfy one of the following requirements: - Is a
	// metastore admin - Is an owner of the function's parent catalog - Have the
	// **USE_CATALOG** privilege on the function's parent catalog and be the owner
	// of the function - Have the **USE_CATALOG** privilege on the function's parent
	// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
	// the **EXECUTE** privilege on the function itself
	GetByName(ctx context.Context, name string) (*FunctionInfo, error)

	// List functions.
	//
	// List functions within the specified parent catalog and schema. If the user is
	// a metastore admin, all functions are returned in the output list. Otherwise,
	// the user must have the **USE_CATALOG** privilege on the catalog and the
	// **USE_SCHEMA** privilege on the schema, and the output list contains only
	// functions for which either the user has the **EXECUTE** privilege or the user
	// is the owner. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListFunctionsRequest) listing.Iterator[FunctionInfo]

	// List functions.
	//
	// List functions within the specified parent catalog and schema. If the user is
	// a metastore admin, all functions are returned in the output list. Otherwise,
	// the user must have the **USE_CATALOG** privilege on the catalog and the
	// **USE_SCHEMA** privilege on the schema, and the output list contains only
	// functions for which either the user has the **EXECUTE** privilege or the user
	// is the owner. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListFunctionsRequest) ([]FunctionInfo, error)

	// FunctionInfoNameToFullNameMap calls [FunctionsAPI.ListAll] and creates a map of results with [FunctionInfo].Name as key and [FunctionInfo].FullName as value.
	//
	// Returns an error if there's more than one [FunctionInfo] with the same .Name.
	//
	// Note: All [FunctionInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	FunctionInfoNameToFullNameMap(ctx context.Context, request ListFunctionsRequest) (map[string]string, error)

	// Update a function.
	//
	// Updates the function that matches the supplied name. Only the owner of the
	// function can be updated. If the user is not a metastore admin, the user must
	// be a member of the group that is the new function owner. - Is a metastore
	// admin - Is the owner of the function's parent catalog - Is the owner of the
	// function's parent schema and has the **USE_CATALOG** privilege on its parent
	// catalog - Is the owner of the function itself and has the **USE_CATALOG**
	// privilege on its parent catalog as well as the **USE_SCHEMA** privilege on
	// the function's parent schema.
	Update(ctx context.Context, request UpdateFunction) (*FunctionInfo, error)
}

func NewFunctions(client *client.DatabricksClient) *FunctionsAPI {
	return &FunctionsAPI{
		functionsImpl: functionsImpl{
			client: client,
		},
	}
}

// Functions implement User-Defined Functions (UDFs) in Unity Catalog.
//
// The function implementation can be any SQL expression or Query, and it can be
// invoked wherever a table reference is allowed in a query. In Unity Catalog, a
// function resides at the same level as a table, so it can be referenced with
// the form __catalog_name__.__schema_name__.__function_name__.
type FunctionsAPI struct {
	functionsImpl
}

// Delete a function.
//
// Deletes the function that matches the supplied name. For the deletion to
// succeed, the user must satisfy one of the following conditions: - Is the
// owner of the function's parent catalog - Is the owner of the function's
// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
// Is the owner of the function itself and have both the **USE_CATALOG**
// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
// parent schema
func (a *FunctionsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.functionsImpl.Delete(ctx, DeleteFunctionRequest{
		Name: name,
	})
}

// Get a function.
//
// Gets a function from within a parent catalog and schema. For the fetch to
// succeed, the user must satisfy one of the following requirements: - Is a
// metastore admin - Is an owner of the function's parent catalog - Have the
// **USE_CATALOG** privilege on the function's parent catalog and be the owner
// of the function - Have the **USE_CATALOG** privilege on the function's parent
// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
// the **EXECUTE** privilege on the function itself
func (a *FunctionsAPI) GetByName(ctx context.Context, name string) (*FunctionInfo, error) {
	return a.functionsImpl.Get(ctx, GetFunctionRequest{
		Name: name,
	})
}

// FunctionInfoNameToFullNameMap calls [FunctionsAPI.ListAll] and creates a map of results with [FunctionInfo].Name as key and [FunctionInfo].FullName as value.
//
// Returns an error if there's more than one [FunctionInfo] with the same .Name.
//
// Note: All [FunctionInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *FunctionsAPI) FunctionInfoNameToFullNameMap(ctx context.Context, request ListFunctionsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

type GrantsInterface interface {

	// Get permissions.
	//
	// Gets the permissions for a securable.
	Get(ctx context.Context, request GetGrantRequest) (*PermissionsList, error)

	// Get permissions.
	//
	// Gets the permissions for a securable.
	GetBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*PermissionsList, error)

	// Get effective permissions.
	//
	// Gets the effective permissions for a securable.
	GetEffective(ctx context.Context, request GetEffectiveRequest) (*EffectivePermissionsList, error)

	// Get effective permissions.
	//
	// Gets the effective permissions for a securable.
	GetEffectiveBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*EffectivePermissionsList, error)

	// Update permissions.
	//
	// Updates the permissions for a securable.
	Update(ctx context.Context, request UpdatePermissions) (*PermissionsList, error)
}

func NewGrants(client *client.DatabricksClient) *GrantsAPI {
	return &GrantsAPI{
		grantsImpl: grantsImpl{
			client: client,
		},
	}
}

// In Unity Catalog, data is secure by default. Initially, users have no access
// to data in a metastore. Access can be granted by either a metastore admin,
// the owner of an object, or the owner of the catalog or schema that contains
// the object. Securable objects in Unity Catalog are hierarchical and
// privileges are inherited downward.
//
// Securable objects in Unity Catalog are hierarchical and privileges are
// inherited downward. This means that granting a privilege on the catalog
// automatically grants the privilege to all current and future objects within
// the catalog. Similarly, privileges granted on a schema are inherited by all
// current and future objects within that schema.
type GrantsAPI struct {
	grantsImpl
}

// Get permissions.
//
// Gets the permissions for a securable.
func (a *GrantsAPI) GetBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*PermissionsList, error) {
	return a.grantsImpl.Get(ctx, GetGrantRequest{
		SecurableType: securableType,
		FullName:      fullName,
	})
}

// Get effective permissions.
//
// Gets the effective permissions for a securable.
func (a *GrantsAPI) GetEffectiveBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*EffectivePermissionsList, error) {
	return a.grantsImpl.GetEffective(ctx, GetEffectiveRequest{
		SecurableType: securableType,
		FullName:      fullName,
	})
}

type MetastoresInterface interface {

	// Create an assignment.
	//
	// Creates a new metastore assignment. If an assignment for the same
	// __workspace_id__ exists, it will be overwritten by the new __metastore_id__
	// and __default_catalog_name__. The caller must be an account admin.
	Assign(ctx context.Context, request CreateMetastoreAssignment) error

	// Create a metastore.
	//
	// Creates a new metastore based on a provided name and optional storage root
	// path. By default (if the __owner__ field is not set), the owner of the new
	// metastore is the user calling the __createMetastore__ API. If the __owner__
	// field is set to the empty string (**""**), the ownership is assigned to the
	// System User instead.
	Create(ctx context.Context, request CreateMetastore) (*MetastoreInfo, error)

	// Get metastore assignment for workspace.
	//
	// Gets the metastore assignment for the workspace being accessed.
	Current(ctx context.Context) (*MetastoreAssignment, error)

	// Delete a metastore.
	//
	// Deletes a metastore. The caller must be a metastore admin.
	Delete(ctx context.Context, request DeleteMetastoreRequest) error

	// Delete a metastore.
	//
	// Deletes a metastore. The caller must be a metastore admin.
	DeleteById(ctx context.Context, id string) error

	// Get a metastore.
	//
	// Gets a metastore that matches the supplied ID. The caller must be a metastore
	// admin to retrieve this info.
	Get(ctx context.Context, request GetMetastoreRequest) (*MetastoreInfo, error)

	// Get a metastore.
	//
	// Gets a metastore that matches the supplied ID. The caller must be a metastore
	// admin to retrieve this info.
	GetById(ctx context.Context, id string) (*MetastoreInfo, error)

	// List metastores.
	//
	// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
	// caller must be an admin to retrieve this info. There is no guarantee of a
	// specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[MetastoreInfo]

	// List metastores.
	//
	// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
	// caller must be an admin to retrieve this info. There is no guarantee of a
	// specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]MetastoreInfo, error)

	// MetastoreInfoNameToMetastoreIdMap calls [MetastoresAPI.ListAll] and creates a map of results with [MetastoreInfo].Name as key and [MetastoreInfo].MetastoreId as value.
	//
	// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
	//
	// Note: All [MetastoreInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	MetastoreInfoNameToMetastoreIdMap(ctx context.Context) (map[string]string, error)

	// GetByName calls [MetastoresAPI.MetastoreInfoNameToMetastoreIdMap] and returns a single [MetastoreInfo].
	//
	// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
	//
	// Note: All [MetastoreInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*MetastoreInfo, error)

	// Get a metastore summary.
	//
	// Gets information about a metastore. This summary includes the storage
	// credential, the cloud vendor, the cloud region, and the global metastore ID.
	Summary(ctx context.Context) (*GetMetastoreSummaryResponse, error)

	// Delete an assignment.
	//
	// Deletes a metastore assignment. The caller must be an account administrator.
	Unassign(ctx context.Context, request UnassignRequest) error

	// Delete an assignment.
	//
	// Deletes a metastore assignment. The caller must be an account administrator.
	UnassignByWorkspaceId(ctx context.Context, workspaceId int64) error

	// Update a metastore.
	//
	// Updates information for a specific metastore. The caller must be a metastore
	// admin. If the __owner__ field is set to the empty string (**""**), the
	// ownership is updated to the System User.
	Update(ctx context.Context, request UpdateMetastore) (*MetastoreInfo, error)

	// Update an assignment.
	//
	// Updates a metastore assignment. This operation can be used to update
	// __metastore_id__ or __default_catalog_name__ for a specified Workspace, if
	// the Workspace is already assigned a metastore. The caller must be an account
	// admin to update __metastore_id__; otherwise, the caller can be a Workspace
	// admin.
	UpdateAssignment(ctx context.Context, request UpdateMetastoreAssignment) error
}

func NewMetastores(client *client.DatabricksClient) *MetastoresAPI {
	return &MetastoresAPI{
		metastoresImpl: metastoresImpl{
			client: client,
		},
	}
}

// A metastore is the top-level container of objects in Unity Catalog. It stores
// data assets (tables and views) and the permissions that govern access to
// them. Databricks account admins can create metastores and assign them to
// Databricks workspaces to control which workloads use each metastore. For a
// workspace to use Unity Catalog, it must have a Unity Catalog metastore
// attached.
//
// Each metastore is configured with a root storage location in a cloud storage
// account. This storage location is used for metadata and managed tables data.
//
// NOTE: This metastore is distinct from the metastore included in Databricks
// workspaces created before Unity Catalog was released. If your workspace
// includes a legacy Hive metastore, the data in that metastore is available in
// a catalog named hive_metastore.
type MetastoresAPI struct {
	metastoresImpl
}

// Delete a metastore.
//
// Deletes a metastore. The caller must be a metastore admin.
func (a *MetastoresAPI) DeleteById(ctx context.Context, id string) error {
	return a.metastoresImpl.Delete(ctx, DeleteMetastoreRequest{
		Id: id,
	})
}

// Get a metastore.
//
// Gets a metastore that matches the supplied ID. The caller must be a metastore
// admin to retrieve this info.
func (a *MetastoresAPI) GetById(ctx context.Context, id string) (*MetastoreInfo, error) {
	return a.metastoresImpl.Get(ctx, GetMetastoreRequest{
		Id: id,
	})
}

// MetastoreInfoNameToMetastoreIdMap calls [MetastoresAPI.ListAll] and creates a map of results with [MetastoreInfo].Name as key and [MetastoreInfo].MetastoreId as value.
//
// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
//
// Note: All [MetastoreInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *MetastoresAPI) MetastoreInfoNameToMetastoreIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.MetastoreId
	}
	return mapping, nil
}

// GetByName calls [MetastoresAPI.MetastoreInfoNameToMetastoreIdMap] and returns a single [MetastoreInfo].
//
// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
//
// Note: All [MetastoreInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *MetastoresAPI) GetByName(ctx context.Context, name string) (*MetastoreInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]MetastoreInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("MetastoreInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of MetastoreInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Delete an assignment.
//
// Deletes a metastore assignment. The caller must be an account administrator.
func (a *MetastoresAPI) UnassignByWorkspaceId(ctx context.Context, workspaceId int64) error {
	return a.metastoresImpl.Unassign(ctx, UnassignRequest{
		WorkspaceId: workspaceId,
	})
}

type ModelVersionsInterface interface {

	// Delete a Model Version.
	//
	// Deletes a model version from the specified registered model. Any aliases
	// assigned to the model version will also be deleted.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Delete(ctx context.Context, request DeleteModelVersionRequest) error

	// Delete a Model Version.
	//
	// Deletes a model version from the specified registered model. Any aliases
	// assigned to the model version will also be deleted.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteByFullNameAndVersion(ctx context.Context, fullName string, version int) error

	// Get a Model Version.
	//
	// Get a model version.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the parent registered model. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema.
	Get(ctx context.Context, request GetModelVersionRequest) (*ModelVersionInfo, error)

	// Get a Model Version.
	//
	// Get a model version.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the parent registered model. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema.
	GetByFullNameAndVersion(ctx context.Context, fullName string, version int) (*ModelVersionInfo, error)

	// Get Model Version By Alias.
	//
	// Get a model version by alias.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByAlias(ctx context.Context, request GetByAliasRequest) (*ModelVersionInfo, error)

	// Get Model Version By Alias.
	//
	// Get a model version by alias.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) (*ModelVersionInfo, error)

	// List Model Versions.
	//
	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	// The elements in the response will not contain any aliases or tags.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListModelVersionsRequest) listing.Iterator[ModelVersionInfo]

	// List Model Versions.
	//
	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	// The elements in the response will not contain any aliases or tags.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListModelVersionsRequest) ([]ModelVersionInfo, error)

	// List Model Versions.
	//
	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	// The elements in the response will not contain any aliases or tags.
	ListByFullName(ctx context.Context, fullName string) (*ListModelVersionsResponse, error)

	// Update a Model Version.
	//
	// Updates the specified model version.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// Currently only the comment of the model version can be updated.
	Update(ctx context.Context, request UpdateModelVersionRequest) (*ModelVersionInfo, error)
}

func NewModelVersions(client *client.DatabricksClient) *ModelVersionsAPI {
	return &ModelVersionsAPI{
		modelVersionsImpl: modelVersionsImpl{
			client: client,
		},
	}
}

// Databricks provides a hosted version of MLflow Model Registry in Unity
// Catalog. Models in Unity Catalog provide centralized access control,
// auditing, lineage, and discovery of ML models across Databricks workspaces.
//
// This API reference documents the REST endpoints for managing model versions
// in Unity Catalog. For more details, see the [registered models API
// docs](/api/workspace/registeredmodels).
type ModelVersionsAPI struct {
	modelVersionsImpl
}

// Delete a Model Version.
//
// Deletes a model version from the specified registered model. Any aliases
// assigned to the model version will also be deleted.
//
// The caller must be a metastore admin or an owner of the parent registered
// model. For the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *ModelVersionsAPI) DeleteByFullNameAndVersion(ctx context.Context, fullName string, version int) error {
	return a.modelVersionsImpl.Delete(ctx, DeleteModelVersionRequest{
		FullName: fullName,
		Version:  version,
	})
}

// Get a Model Version.
//
// Get a model version.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the parent registered model. For the latter case, the caller
// must also be the owner or have the **USE_CATALOG** privilege on the parent
// catalog and the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) GetByFullNameAndVersion(ctx context.Context, fullName string, version int) (*ModelVersionInfo, error) {
	return a.modelVersionsImpl.Get(ctx, GetModelVersionRequest{
		FullName: fullName,
		Version:  version,
	})
}

// Get Model Version By Alias.
//
// Get a model version by alias.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) GetByAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) (*ModelVersionInfo, error) {
	return a.modelVersionsImpl.GetByAlias(ctx, GetByAliasRequest{
		FullName: fullName,
		Alias:    alias,
	})
}

// List Model Versions.
//
// List model versions. You can list model versions under a particular schema,
// or list all model versions in the current metastore.
//
// The returned models are filtered based on the privileges of the calling user.
// For example, the metastore admin is able to list all the model versions. A
// regular user needs to be the owner or have the **EXECUTE** privilege on the
// parent registered model to recieve the model versions in the response. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
//
// There is no guarantee of a specific ordering of the elements in the response.
// The elements in the response will not contain any aliases or tags.
func (a *ModelVersionsAPI) ListByFullName(ctx context.Context, fullName string) (*ListModelVersionsResponse, error) {
	return a.modelVersionsImpl.internalList(ctx, ListModelVersionsRequest{
		FullName: fullName,
	})
}

type OnlineTablesInterface interface {

	// WaitGetOnlineTableActive repeatedly calls [OnlineTablesAPI.Get] and waits to reach ACTIVE state
	WaitGetOnlineTableActive(ctx context.Context, name string,
		timeout time.Duration, callback func(*OnlineTable)) (*OnlineTable, error)

	// Create an Online Table.
	//
	// Create a new Online Table.
	Create(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest) (*WaitGetOnlineTableActive[OnlineTable], error)

	// Calls [OnlineTablesAPIInterface.Create] and waits to reach ACTIVE state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[OnlineTable](60*time.Minute) functional option.
	//
	// Deprecated: use [OnlineTablesAPIInterface.Create].Get() or [OnlineTablesAPIInterface.WaitGetOnlineTableActive]
	CreateAndWait(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest, options ...retries.Option[OnlineTable]) (*OnlineTable, error)

	// Delete an Online Table.
	//
	// Delete an online table. Warning: This will delete all the data in the online
	// table. If the source Delta table was deleted or modified since this Online
	// Table was created, this will lose the data forever!
	Delete(ctx context.Context, request DeleteOnlineTableRequest) error

	// Delete an Online Table.
	//
	// Delete an online table. Warning: This will delete all the data in the online
	// table. If the source Delta table was deleted or modified since this Online
	// Table was created, this will lose the data forever!
	DeleteByName(ctx context.Context, name string) error

	// Get an Online Table.
	//
	// Get information about an existing online table and its status.
	Get(ctx context.Context, request GetOnlineTableRequest) (*OnlineTable, error)

	// Get an Online Table.
	//
	// Get information about an existing online table and its status.
	GetByName(ctx context.Context, name string) (*OnlineTable, error)
}

func NewOnlineTables(client *client.DatabricksClient) *OnlineTablesAPI {
	return &OnlineTablesAPI{
		onlineTablesImpl: onlineTablesImpl{
			client: client,
		},
	}
}

// Online tables provide lower latency and higher QPS access to data from Delta
// tables.
type OnlineTablesAPI struct {
	onlineTablesImpl
}

// WaitGetOnlineTableActive repeatedly calls [OnlineTablesAPI.Get] and waits to reach ACTIVE state
func (a *OnlineTablesAPI) WaitGetOnlineTableActive(ctx context.Context, name string,
	timeout time.Duration, callback func(*OnlineTable)) (*OnlineTable, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[OnlineTable](ctx, timeout, func() (*OnlineTable, *retries.Err) {
		onlineTable, err := a.Get(ctx, GetOnlineTableRequest{
			Name: name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(onlineTable)
		}
		status := onlineTable.UnityCatalogProvisioningState
		statusMessage := fmt.Sprintf("current status: %s", status)
		switch status {
		case ProvisioningInfoStateActive: // target state
			return onlineTable, nil
		case ProvisioningInfoStateFailed:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				ProvisioningInfoStateActive, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetOnlineTableActive is a wrapper that calls [OnlineTablesAPI.WaitGetOnlineTableActive] and waits to reach ACTIVE state.
type WaitGetOnlineTableActive[R any] struct {
	Response *R
	Name     string `json:"name"`
	Poll     func(time.Duration, func(*OnlineTable)) (*OnlineTable, error)
	callback func(*OnlineTable)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetOnlineTableActive[R]) OnProgress(callback func(*OnlineTable)) *WaitGetOnlineTableActive[R] {
	w.callback = callback
	return w
}

// Get the OnlineTable with the default timeout of 20 minutes.
func (w *WaitGetOnlineTableActive[R]) Get() (*OnlineTable, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the OnlineTable with custom timeout.
func (w *WaitGetOnlineTableActive[R]) GetWithTimeout(timeout time.Duration) (*OnlineTable, error) {
	return w.Poll(timeout, w.callback)
}

// Create an Online Table.
//
// Create a new Online Table.
func (a *OnlineTablesAPI) Create(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest) (*WaitGetOnlineTableActive[OnlineTable], error) {
	onlineTable, err := a.onlineTablesImpl.Create(ctx, createOnlineTableRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetOnlineTableActive[OnlineTable]{
		Response: onlineTable,
		Name:     onlineTable.Name,
		Poll: func(timeout time.Duration, callback func(*OnlineTable)) (*OnlineTable, error) {
			return a.WaitGetOnlineTableActive(ctx, onlineTable.Name, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [OnlineTablesAPI.Create] and waits to reach ACTIVE state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[OnlineTable](60*time.Minute) functional option.
//
// Deprecated: use [OnlineTablesAPI.Create].Get() or [OnlineTablesAPI.WaitGetOnlineTableActive]
func (a *OnlineTablesAPI) CreateAndWait(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest, options ...retries.Option[OnlineTable]) (*OnlineTable, error) {
	wait, err := a.Create(ctx, createOnlineTableRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[OnlineTable]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *OnlineTable) {
		for _, o := range options {
			o(&retries.Info[OnlineTable]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Delete an Online Table.
//
// Delete an online table. Warning: This will delete all the data in the online
// table. If the source Delta table was deleted or modified since this Online
// Table was created, this will lose the data forever!
func (a *OnlineTablesAPI) DeleteByName(ctx context.Context, name string) error {
	return a.onlineTablesImpl.Delete(ctx, DeleteOnlineTableRequest{
		Name: name,
	})
}

// Get an Online Table.
//
// Get information about an existing online table and its status.
func (a *OnlineTablesAPI) GetByName(ctx context.Context, name string) (*OnlineTable, error) {
	return a.onlineTablesImpl.Get(ctx, GetOnlineTableRequest{
		Name: name,
	})
}

type QualityMonitorsInterface interface {

	// Cancel refresh.
	//
	// Cancel an active monitor refresh for the given refresh ID.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	CancelRefresh(ctx context.Context, request CancelRefreshRequest) error

	// Create a table monitor.
	//
	// Creates a new monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog, have
	// **USE_SCHEMA** on the table's parent schema, and have **SELECT** access on
	// the table 2. have **USE_CATALOG** on the table's parent catalog, be an owner
	// of the table's parent schema, and have **SELECT** access on the table. 3.
	// have the following permissions: - **USE_CATALOG** on the table's parent
	// catalog - **USE_SCHEMA** on the table's parent schema - be an owner of the
	// table.
	//
	// Workspace assets, such as the dashboard, will be created in the workspace
	// where this call was made.
	Create(ctx context.Context, request CreateMonitor) (*MonitorInfo, error)

	// Delete a table monitor.
	//
	// Deletes a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	//
	// Note that the metric tables and dashboard will not be deleted as part of this
	// call; those assets must be manually cleaned up (if desired).
	Delete(ctx context.Context, request DeleteQualityMonitorRequest) error

	// Delete a table monitor.
	//
	// Deletes a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	//
	// Note that the metric tables and dashboard will not be deleted as part of this
	// call; those assets must be manually cleaned up (if desired).
	DeleteByTableName(ctx context.Context, tableName string) error

	// Get a table monitor.
	//
	// Gets a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// The returned information includes configuration values, as well as
	// information on assets created by the monitor. Some information (e.g.,
	// dashboard) may be filtered out if the caller is in a different workspace than
	// where the monitor was created.
	Get(ctx context.Context, request GetQualityMonitorRequest) (*MonitorInfo, error)

	// Get a table monitor.
	//
	// Gets a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// The returned information includes configuration values, as well as
	// information on assets created by the monitor. Some information (e.g.,
	// dashboard) may be filtered out if the caller is in a different workspace than
	// where the monitor was created.
	GetByTableName(ctx context.Context, tableName string) (*MonitorInfo, error)

	// Get refresh.
	//
	// Gets info about a specific monitor refresh using the given refresh ID.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	GetRefresh(ctx context.Context, request GetRefreshRequest) (*MonitorRefreshInfo, error)

	// Get refresh.
	//
	// Gets info about a specific monitor refresh using the given refresh ID.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	GetRefreshByTableNameAndRefreshId(ctx context.Context, tableName string, refreshId string) (*MonitorRefreshInfo, error)

	// List refreshes.
	//
	// Gets an array containing the history of the most recent refreshes (up to 25)
	// for this table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	ListRefreshes(ctx context.Context, request ListRefreshesRequest) (*MonitorRefreshListResponse, error)

	// List refreshes.
	//
	// Gets an array containing the history of the most recent refreshes (up to 25)
	// for this table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	ListRefreshesByTableName(ctx context.Context, tableName string) (*MonitorRefreshListResponse, error)

	// Regenerate a monitoring dashboard.
	//
	// Regenerates the monitoring dashboard for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table
	//
	// The call must be made from the workspace where the monitor was created. The
	// dashboard will be regenerated in the assets directory that was specified when
	// the monitor was created.
	RegenerateDashboard(ctx context.Context, request RegenerateDashboardRequest) (*RegenerateDashboardResponse, error)

	// Queue a metric refresh for a monitor.
	//
	// Queues a metric refresh on the monitor for the specified table. The refresh
	// will execute in the background.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	RunRefresh(ctx context.Context, request RunRefreshRequest) (*MonitorRefreshInfo, error)

	// Update a table monitor.
	//
	// Updates a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created, and the caller must be the original creator of the monitor.
	//
	// Certain configuration fields, such as output asset identifiers, cannot be
	// updated.
	Update(ctx context.Context, request UpdateMonitor) (*MonitorInfo, error)
}

func NewQualityMonitors(client *client.DatabricksClient) *QualityMonitorsAPI {
	return &QualityMonitorsAPI{
		qualityMonitorsImpl: qualityMonitorsImpl{
			client: client,
		},
	}
}

// A monitor computes and monitors data or model quality metrics for a table
// over time. It generates metrics tables and a dashboard that you can use to
// monitor table health and set alerts.
//
// Most write operations require the user to be the owner of the table (or its
// parent schema or parent catalog). Viewing the dashboard, computed metrics, or
// monitor configuration only requires the user to have **SELECT** privileges on
// the table (along with **USE_SCHEMA** and **USE_CATALOG**).
type QualityMonitorsAPI struct {
	qualityMonitorsImpl
}

// Delete a table monitor.
//
// Deletes a monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
// owner of the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
//
// Note that the metric tables and dashboard will not be deleted as part of this
// call; those assets must be manually cleaned up (if desired).
func (a *QualityMonitorsAPI) DeleteByTableName(ctx context.Context, tableName string) error {
	return a.qualityMonitorsImpl.Delete(ctx, DeleteQualityMonitorRequest{
		TableName: tableName,
	})
}

// Get a table monitor.
//
// Gets a monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// The returned information includes configuration values, as well as
// information on assets created by the monitor. Some information (e.g.,
// dashboard) may be filtered out if the caller is in a different workspace than
// where the monitor was created.
func (a *QualityMonitorsAPI) GetByTableName(ctx context.Context, tableName string) (*MonitorInfo, error) {
	return a.qualityMonitorsImpl.Get(ctx, GetQualityMonitorRequest{
		TableName: tableName,
	})
}

// Get refresh.
//
// Gets info about a specific monitor refresh using the given refresh ID.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *QualityMonitorsAPI) GetRefreshByTableNameAndRefreshId(ctx context.Context, tableName string, refreshId string) (*MonitorRefreshInfo, error) {
	return a.qualityMonitorsImpl.GetRefresh(ctx, GetRefreshRequest{
		TableName: tableName,
		RefreshId: refreshId,
	})
}

// List refreshes.
//
// Gets an array containing the history of the most recent refreshes (up to 25)
// for this table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *QualityMonitorsAPI) ListRefreshesByTableName(ctx context.Context, tableName string) (*MonitorRefreshListResponse, error) {
	return a.qualityMonitorsImpl.ListRefreshes(ctx, ListRefreshesRequest{
		TableName: tableName,
	})
}

type RegisteredModelsInterface interface {

	// Create a Registered Model.
	//
	// Creates a new registered model in Unity Catalog.
	//
	// File storage for model versions in the registered model will be located in
	// the default location which is specified by the parent schema, or the parent
	// catalog, or the Metastore.
	//
	// For registered model creation to succeed, the user must satisfy the following
	// conditions: - The caller must be a metastore admin, or be the owner of the
	// parent catalog and schema, or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
	// caller must have the **CREATE MODEL** or **CREATE FUNCTION** privilege on the
	// parent schema.
	Create(ctx context.Context, request CreateRegisteredModelRequest) (*RegisteredModelInfo, error)

	// Delete a Registered Model.
	//
	// Deletes a registered model and all its model versions from the specified
	// parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Delete(ctx context.Context, request DeleteRegisteredModelRequest) error

	// Delete a Registered Model.
	//
	// Deletes a registered model and all its model versions from the specified
	// parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Delete a Registered Model Alias.
	//
	// Deletes a registered model alias.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteAlias(ctx context.Context, request DeleteAliasRequest) error

	// Delete a Registered Model Alias.
	//
	// Deletes a registered model alias.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) error

	// Get a Registered Model.
	//
	// Get a registered model.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	Get(ctx context.Context, request GetRegisteredModelRequest) (*RegisteredModelInfo, error)

	// Get a Registered Model.
	//
	// Get a registered model.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByFullName(ctx context.Context, fullName string) (*RegisteredModelInfo, error)

	// List Registered Models.
	//
	// List registered models. You can list registered models under a particular
	// schema, or list all registered models in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the registered models. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// registered model to recieve the registered models in the response. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListRegisteredModelsRequest) listing.Iterator[RegisteredModelInfo]

	// List Registered Models.
	//
	// List registered models. You can list registered models under a particular
	// schema, or list all registered models in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the registered models. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// registered model to recieve the registered models in the response. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListRegisteredModelsRequest) ([]RegisteredModelInfo, error)

	// RegisteredModelInfoNameToFullNameMap calls [RegisteredModelsAPI.ListAll] and creates a map of results with [RegisteredModelInfo].Name as key and [RegisteredModelInfo].FullName as value.
	//
	// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
	//
	// Note: All [RegisteredModelInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	RegisteredModelInfoNameToFullNameMap(ctx context.Context, request ListRegisteredModelsRequest) (map[string]string, error)

	// GetByName calls [RegisteredModelsAPI.RegisteredModelInfoNameToFullNameMap] and returns a single [RegisteredModelInfo].
	//
	// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
	//
	// Note: All [RegisteredModelInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*RegisteredModelInfo, error)

	// Set a Registered Model Alias.
	//
	// Set an alias on the specified registered model.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	SetAlias(ctx context.Context, request SetRegisteredModelAliasRequest) (*RegisteredModelAlias, error)

	// Update a Registered Model.
	//
	// Updates the specified registered model.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// Currently only the name, the owner or the comment of the registered model can
	// be updated.
	Update(ctx context.Context, request UpdateRegisteredModelRequest) (*RegisteredModelInfo, error)
}

func NewRegisteredModels(client *client.DatabricksClient) *RegisteredModelsAPI {
	return &RegisteredModelsAPI{
		registeredModelsImpl: registeredModelsImpl{
			client: client,
		},
	}
}

// Databricks provides a hosted version of MLflow Model Registry in Unity
// Catalog. Models in Unity Catalog provide centralized access control,
// auditing, lineage, and discovery of ML models across Databricks workspaces.
//
// An MLflow registered model resides in the third layer of Unity Catalog’s
// three-level namespace. Registered models contain model versions, which
// correspond to actual ML models (MLflow models). Creating new model versions
// currently requires use of the MLflow Python client. Once model versions are
// created, you can load them for batch inference using MLflow Python client
// APIs, or deploy them for real-time serving using Databricks Model Serving.
//
// All operations on registered models and model versions require USE_CATALOG
// permissions on the enclosing catalog and USE_SCHEMA permissions on the
// enclosing schema. In addition, the following additional privileges are
// required for various operations:
//
// * To create a registered model, users must additionally have the CREATE_MODEL
// permission on the target schema. * To view registered model or model version
// metadata, model version data files, or invoke a model version, users must
// additionally have the EXECUTE permission on the registered model * To update
// registered model or model version tags, users must additionally have APPLY
// TAG permissions on the registered model * To update other registered model or
// model version metadata (comments, aliases) create a new model version, or
// update permissions on the registered model, users must be owners of the
// registered model.
//
// Note: The securable type for models is "FUNCTION". When using REST APIs (e.g.
// tagging, grants) that specify a securable type, use "FUNCTION" as the
// securable type.
type RegisteredModelsAPI struct {
	registeredModelsImpl
}

// Delete a Registered Model.
//
// Deletes a registered model and all its model versions from the specified
// parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.registeredModelsImpl.Delete(ctx, DeleteRegisteredModelRequest{
		FullName: fullName,
	})
}

// Delete a Registered Model Alias.
//
// Deletes a registered model alias.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) DeleteAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) error {
	return a.registeredModelsImpl.DeleteAlias(ctx, DeleteAliasRequest{
		FullName: fullName,
		Alias:    alias,
	})
}

// Get a Registered Model.
//
// Get a registered model.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *RegisteredModelsAPI) GetByFullName(ctx context.Context, fullName string) (*RegisteredModelInfo, error) {
	return a.registeredModelsImpl.Get(ctx, GetRegisteredModelRequest{
		FullName: fullName,
	})
}

// RegisteredModelInfoNameToFullNameMap calls [RegisteredModelsAPI.ListAll] and creates a map of results with [RegisteredModelInfo].Name as key and [RegisteredModelInfo].FullName as value.
//
// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
//
// Note: All [RegisteredModelInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) RegisteredModelInfoNameToFullNameMap(ctx context.Context, request ListRegisteredModelsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

// GetByName calls [RegisteredModelsAPI.RegisteredModelInfoNameToFullNameMap] and returns a single [RegisteredModelInfo].
//
// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
//
// Note: All [RegisteredModelInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) GetByName(ctx context.Context, name string) (*RegisteredModelInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListRegisteredModelsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]RegisteredModelInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("RegisteredModelInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of RegisteredModelInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ResourceQuotasInterface interface {

	// Get information for a single resource quota.
	//
	// The GetQuota API returns usage information for a single resource quota,
	// defined as a child-parent pair. This API also refreshes the quota count if it
	// is out of date. Refreshes are triggered asynchronously. The updated count
	// might not be returned in the first call.
	GetQuota(ctx context.Context, request GetQuotaRequest) (*GetQuotaResponse, error)

	// Get information for a single resource quota.
	//
	// The GetQuota API returns usage information for a single resource quota,
	// defined as a child-parent pair. This API also refreshes the quota count if it
	// is out of date. Refreshes are triggered asynchronously. The updated count
	// might not be returned in the first call.
	GetQuotaByParentSecurableTypeAndParentFullNameAndQuotaName(ctx context.Context, parentSecurableType string, parentFullName string, quotaName string) (*GetQuotaResponse, error)

	// List all resource quotas under a metastore.
	//
	// ListQuotas returns all quota values under the metastore. There are no SLAs on
	// the freshness of the counts returned. This API does not trigger a refresh of
	// quota counts.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListQuotas(ctx context.Context, request ListQuotasRequest) listing.Iterator[QuotaInfo]

	// List all resource quotas under a metastore.
	//
	// ListQuotas returns all quota values under the metastore. There are no SLAs on
	// the freshness of the counts returned. This API does not trigger a refresh of
	// quota counts.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListQuotasAll(ctx context.Context, request ListQuotasRequest) ([]QuotaInfo, error)
}

func NewResourceQuotas(client *client.DatabricksClient) *ResourceQuotasAPI {
	return &ResourceQuotasAPI{
		resourceQuotasImpl: resourceQuotasImpl{
			client: client,
		},
	}
}

// Unity Catalog enforces resource quotas on all securable objects, which limits
// the number of resources that can be created. Quotas are expressed in terms of
// a resource type and a parent (for example, tables per metastore or schemas
// per catalog). The resource quota APIs enable you to monitor your current
// usage and limits. For more information on resource quotas see the [Unity
// Catalog documentation].
//
// [Unity Catalog documentation]: https://docs.databricks.com/en/data-governance/unity-catalog/index.html#resource-quotas
type ResourceQuotasAPI struct {
	resourceQuotasImpl
}

// Get information for a single resource quota.
//
// The GetQuota API returns usage information for a single resource quota,
// defined as a child-parent pair. This API also refreshes the quota count if it
// is out of date. Refreshes are triggered asynchronously. The updated count
// might not be returned in the first call.
func (a *ResourceQuotasAPI) GetQuotaByParentSecurableTypeAndParentFullNameAndQuotaName(ctx context.Context, parentSecurableType string, parentFullName string, quotaName string) (*GetQuotaResponse, error) {
	return a.resourceQuotasImpl.GetQuota(ctx, GetQuotaRequest{
		ParentSecurableType: parentSecurableType,
		ParentFullName:      parentFullName,
		QuotaName:           quotaName,
	})
}

type SchemasInterface interface {

	// Create a schema.
	//
	// Creates a new schema for catalog in the Metatastore. The caller must be a
	// metastore admin, or have the **CREATE_SCHEMA** privilege in the parent
	// catalog.
	Create(ctx context.Context, request CreateSchema) (*SchemaInfo, error)

	// Delete a schema.
	//
	// Deletes the specified schema from the parent catalog. The caller must be the
	// owner of the schema or an owner of the parent catalog.
	Delete(ctx context.Context, request DeleteSchemaRequest) error

	// Delete a schema.
	//
	// Deletes the specified schema from the parent catalog. The caller must be the
	// owner of the schema or an owner of the parent catalog.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Get a schema.
	//
	// Gets the specified schema within the metastore. The caller must be a
	// metastore admin, the owner of the schema, or a user that has the
	// **USE_SCHEMA** privilege on the schema.
	Get(ctx context.Context, request GetSchemaRequest) (*SchemaInfo, error)

	// Get a schema.
	//
	// Gets the specified schema within the metastore. The caller must be a
	// metastore admin, the owner of the schema, or a user that has the
	// **USE_SCHEMA** privilege on the schema.
	GetByFullName(ctx context.Context, fullName string) (*SchemaInfo, error)

	// List schemas.
	//
	// Gets an array of schemas for a catalog in the metastore. If the caller is the
	// metastore admin or the owner of the parent catalog, all schemas for the
	// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
	// for which the caller has the **USE_SCHEMA** privilege) will be retrieved.
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListSchemasRequest) listing.Iterator[SchemaInfo]

	// List schemas.
	//
	// Gets an array of schemas for a catalog in the metastore. If the caller is the
	// metastore admin or the owner of the parent catalog, all schemas for the
	// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
	// for which the caller has the **USE_SCHEMA** privilege) will be retrieved.
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListSchemasRequest) ([]SchemaInfo, error)

	// SchemaInfoNameToFullNameMap calls [SchemasAPI.ListAll] and creates a map of results with [SchemaInfo].Name as key and [SchemaInfo].FullName as value.
	//
	// Returns an error if there's more than one [SchemaInfo] with the same .Name.
	//
	// Note: All [SchemaInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	SchemaInfoNameToFullNameMap(ctx context.Context, request ListSchemasRequest) (map[string]string, error)

	// GetByName calls [SchemasAPI.SchemaInfoNameToFullNameMap] and returns a single [SchemaInfo].
	//
	// Returns an error if there's more than one [SchemaInfo] with the same .Name.
	//
	// Note: All [SchemaInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*SchemaInfo, error)

	// Update a schema.
	//
	// Updates a schema for a catalog. The caller must be the owner of the schema or
	// a metastore admin. If the caller is a metastore admin, only the __owner__
	// field can be changed in the update. If the __name__ field must be updated,
	// the caller must be a metastore admin or have the **CREATE_SCHEMA** privilege
	// on the parent catalog.
	Update(ctx context.Context, request UpdateSchema) (*SchemaInfo, error)
}

func NewSchemas(client *client.DatabricksClient) *SchemasAPI {
	return &SchemasAPI{
		schemasImpl: schemasImpl{
			client: client,
		},
	}
}

// A schema (also called a database) is the second layer of Unity Catalog’s
// three-level namespace. A schema organizes tables, views and functions. To
// access (or list) a table or view in a schema, users must have the USE_SCHEMA
// data permission on the schema and its parent catalog, and they must have the
// SELECT permission on the table or view.
type SchemasAPI struct {
	schemasImpl
}

// Delete a schema.
//
// Deletes the specified schema from the parent catalog. The caller must be the
// owner of the schema or an owner of the parent catalog.
func (a *SchemasAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.schemasImpl.Delete(ctx, DeleteSchemaRequest{
		FullName: fullName,
	})
}

// Get a schema.
//
// Gets the specified schema within the metastore. The caller must be a
// metastore admin, the owner of the schema, or a user that has the
// **USE_SCHEMA** privilege on the schema.
func (a *SchemasAPI) GetByFullName(ctx context.Context, fullName string) (*SchemaInfo, error) {
	return a.schemasImpl.Get(ctx, GetSchemaRequest{
		FullName: fullName,
	})
}

// SchemaInfoNameToFullNameMap calls [SchemasAPI.ListAll] and creates a map of results with [SchemaInfo].Name as key and [SchemaInfo].FullName as value.
//
// Returns an error if there's more than one [SchemaInfo] with the same .Name.
//
// Note: All [SchemaInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SchemasAPI) SchemaInfoNameToFullNameMap(ctx context.Context, request ListSchemasRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

// GetByName calls [SchemasAPI.SchemaInfoNameToFullNameMap] and returns a single [SchemaInfo].
//
// Returns an error if there's more than one [SchemaInfo] with the same .Name.
//
// Note: All [SchemaInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SchemasAPI) GetByName(ctx context.Context, name string) (*SchemaInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListSchemasRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]SchemaInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("SchemaInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of SchemaInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type StorageCredentialsInterface interface {

	// Create a storage credential.
	//
	// Creates a new storage credential.
	Create(ctx context.Context, request CreateStorageCredential) (*StorageCredentialInfo, error)

	// Delete a credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	Delete(ctx context.Context, request DeleteStorageCredentialRequest) error

	// Delete a credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	DeleteByName(ctx context.Context, name string) error

	// Get a credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have some permission on the
	// storage credential.
	Get(ctx context.Context, request GetStorageCredentialRequest) (*StorageCredentialInfo, error)

	// Get a credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have some permission on the
	// storage credential.
	GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error)

	// List credentials.
	//
	// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
	// The array is limited to only those storage credentials the caller has
	// permission to access. If the caller is a metastore admin, retrieval of
	// credentials is unrestricted. There is no guarantee of a specific ordering of
	// the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListStorageCredentialsRequest) listing.Iterator[StorageCredentialInfo]

	// List credentials.
	//
	// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
	// The array is limited to only those storage credentials the caller has
	// permission to access. If the caller is a metastore admin, retrieval of
	// credentials is unrestricted. There is no guarantee of a specific ordering of
	// the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListStorageCredentialsRequest) ([]StorageCredentialInfo, error)

	// StorageCredentialInfoNameToIdMap calls [StorageCredentialsAPI.ListAll] and creates a map of results with [StorageCredentialInfo].Name as key and [StorageCredentialInfo].Id as value.
	//
	// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
	//
	// Note: All [StorageCredentialInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	StorageCredentialInfoNameToIdMap(ctx context.Context, request ListStorageCredentialsRequest) (map[string]string, error)

	// Update a credential.
	//
	// Updates a storage credential on the metastore.
	Update(ctx context.Context, request UpdateStorageCredential) (*StorageCredentialInfo, error)

	// Validate a storage credential.
	//
	// Validates a storage credential. At least one of __external_location_name__
	// and __url__ need to be provided. If only one of them is provided, it will be
	// used for validation. And if both are provided, the __url__ will be used for
	// validation, and __external_location_name__ will be ignored when checking
	// overlapping urls.
	//
	// Either the __storage_credential_name__ or the cloud-specific credential must
	// be provided.
	//
	// The caller must be a metastore admin or the storage credential owner or have
	// the **CREATE_EXTERNAL_LOCATION** privilege on the metastore and the storage
	// credential.
	Validate(ctx context.Context, request ValidateStorageCredential) (*ValidateStorageCredentialResponse, error)
}

func NewStorageCredentials(client *client.DatabricksClient) *StorageCredentialsAPI {
	return &StorageCredentialsAPI{
		storageCredentialsImpl: storageCredentialsImpl{
			client: client,
		},
	}
}

// A storage credential represents an authentication and authorization mechanism
// for accessing data stored on your cloud tenant. Each storage credential is
// subject to Unity Catalog access-control policies that control which users and
// groups can access the credential. If a user does not have access to a storage
// credential in Unity Catalog, the request fails and Unity Catalog does not
// attempt to authenticate to your cloud tenant on the user’s behalf.
//
// Databricks recommends using external locations rather than using storage
// credentials directly.
//
// To create storage credentials, you must be a Databricks account admin. The
// account admin who creates the storage credential can delegate ownership to
// another user or group to manage permissions on it.
type StorageCredentialsAPI struct {
	storageCredentialsImpl
}

// Delete a credential.
//
// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *StorageCredentialsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.storageCredentialsImpl.Delete(ctx, DeleteStorageCredentialRequest{
		Name: name,
	})
}

// Get a credential.
//
// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have some permission on the
// storage credential.
func (a *StorageCredentialsAPI) GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error) {
	return a.storageCredentialsImpl.Get(ctx, GetStorageCredentialRequest{
		Name: name,
	})
}

// StorageCredentialInfoNameToIdMap calls [StorageCredentialsAPI.ListAll] and creates a map of results with [StorageCredentialInfo].Name as key and [StorageCredentialInfo].Id as value.
//
// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
//
// Note: All [StorageCredentialInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *StorageCredentialsAPI) StorageCredentialInfoNameToIdMap(ctx context.Context, request ListStorageCredentialsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

type SystemSchemasInterface interface {

	// Disable a system schema.
	//
	// Disables the system schema and removes it from the system catalog. The caller
	// must be an account admin or a metastore admin.
	Disable(ctx context.Context, request DisableRequest) error

	// Disable a system schema.
	//
	// Disables the system schema and removes it from the system catalog. The caller
	// must be an account admin or a metastore admin.
	DisableByMetastoreIdAndSchemaName(ctx context.Context, metastoreId string, schemaName string) error

	// Enable a system schema.
	//
	// Enables the system schema and adds it to the system catalog. The caller must
	// be an account admin or a metastore admin.
	Enable(ctx context.Context, request EnableRequest) error

	// List system schemas.
	//
	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListSystemSchemasRequest) listing.Iterator[SystemSchemaInfo]

	// List system schemas.
	//
	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListSystemSchemasRequest) ([]SystemSchemaInfo, error)

	// List system schemas.
	//
	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListSystemSchemasResponse, error)
}

func NewSystemSchemas(client *client.DatabricksClient) *SystemSchemasAPI {
	return &SystemSchemasAPI{
		systemSchemasImpl: systemSchemasImpl{
			client: client,
		},
	}
}

// A system schema is a schema that lives within the system catalog. A system
// schema may contain information about customer usage of Unity Catalog such as
// audit-logs, billing-logs, lineage information, etc.
type SystemSchemasAPI struct {
	systemSchemasImpl
}

// Disable a system schema.
//
// Disables the system schema and removes it from the system catalog. The caller
// must be an account admin or a metastore admin.
func (a *SystemSchemasAPI) DisableByMetastoreIdAndSchemaName(ctx context.Context, metastoreId string, schemaName string) error {
	return a.systemSchemasImpl.Disable(ctx, DisableRequest{
		MetastoreId: metastoreId,
		SchemaName:  schemaName,
	})
}

// List system schemas.
//
// Gets an array of system schemas for a metastore. The caller must be an
// account admin or a metastore admin.
func (a *SystemSchemasAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListSystemSchemasResponse, error) {
	return a.systemSchemasImpl.internalList(ctx, ListSystemSchemasRequest{
		MetastoreId: metastoreId,
	})
}

type TableConstraintsInterface interface {

	// Create a table constraint.
	//
	// Creates a new table constraint.
	//
	// For the table constraint creation to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if the new constraint is a
	// __ForeignKeyConstraint__, the user must have the **USE_CATALOG** privilege on
	// the referenced parent table's catalog, the **USE_SCHEMA** privilege on the
	// referenced parent table's schema, and be the owner of the referenced parent
	// table.
	Create(ctx context.Context, request CreateTableConstraint) (*TableConstraint, error)

	// Delete a table constraint.
	//
	// Deletes a table constraint.
	//
	// For the table constraint deletion to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if __cascade__ argument is **true**,
	// the user must have the following permissions on all of the child tables: the
	// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
	// privilege on the table's schema, and be the owner of the table.
	Delete(ctx context.Context, request DeleteTableConstraintRequest) error

	// Delete a table constraint.
	//
	// Deletes a table constraint.
	//
	// For the table constraint deletion to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if __cascade__ argument is **true**,
	// the user must have the following permissions on all of the child tables: the
	// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
	// privilege on the table's schema, and be the owner of the table.
	DeleteByFullName(ctx context.Context, fullName string) error
}

func NewTableConstraints(client *client.DatabricksClient) *TableConstraintsAPI {
	return &TableConstraintsAPI{
		tableConstraintsImpl: tableConstraintsImpl{
			client: client,
		},
	}
}

// Primary key and foreign key constraints encode relationships between fields
// in tables.
//
// Primary and foreign keys are informational only and are not enforced. Foreign
// keys must reference a primary key in another table. This primary key is the
// parent constraint of the foreign key and the table this primary key is on is
// the parent table of the foreign key. Similarly, the foreign key is the child
// constraint of its referenced primary key; the table of the foreign key is the
// child table of the primary key.
//
// You can declare primary keys and foreign keys as part of the table
// specification during table creation. You can also add or drop constraints on
// existing tables.
type TableConstraintsAPI struct {
	tableConstraintsImpl
}

// Delete a table constraint.
//
// Deletes a table constraint.
//
// For the table constraint deletion to succeed, the user must satisfy both of
// these conditions: - the user must have the **USE_CATALOG** privilege on the
// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
// schema, and be the owner of the table. - if __cascade__ argument is **true**,
// the user must have the following permissions on all of the child tables: the
// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
// privilege on the table's schema, and be the owner of the table.
func (a *TableConstraintsAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.tableConstraintsImpl.Delete(ctx, DeleteTableConstraintRequest{
		FullName: fullName,
	})
}

type TablesInterface interface {

	// Delete a table.
	//
	// Deletes a table from the specified parent catalog and schema. The caller must
	// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
	// parent catalog and be the owner of the parent schema, or be the owner of the
	// table and have the **USE_CATALOG** privilege on the parent catalog and the
	// **USE_SCHEMA** privilege on the parent schema.
	Delete(ctx context.Context, request DeleteTableRequest) error

	// Delete a table.
	//
	// Deletes a table from the specified parent catalog and schema. The caller must
	// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
	// parent catalog and be the owner of the parent schema, or be the owner of the
	// table and have the **USE_CATALOG** privilege on the parent catalog and the
	// **USE_SCHEMA** privilege on the parent schema.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Get boolean reflecting if table exists.
	//
	// Gets if a table exists in the metastore for a specific catalog and schema.
	// The caller must satisfy one of the following requirements: * Be a metastore
	// admin * Be the owner of the parent catalog * Be the owner of the parent
	// schema and have the USE_CATALOG privilege on the parent catalog * Have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// SELECT privilege on the table. * Have BROWSE privilege on the parent catalog
	// * Have BROWSE privilege on the parent schema.
	Exists(ctx context.Context, request ExistsRequest) (*TableExistsResponse, error)

	// Get boolean reflecting if table exists.
	//
	// Gets if a table exists in the metastore for a specific catalog and schema.
	// The caller must satisfy one of the following requirements: * Be a metastore
	// admin * Be the owner of the parent catalog * Be the owner of the parent
	// schema and have the USE_CATALOG privilege on the parent catalog * Have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// SELECT privilege on the table. * Have BROWSE privilege on the parent catalog
	// * Have BROWSE privilege on the parent schema.
	ExistsByFullName(ctx context.Context, fullName string) (*TableExistsResponse, error)

	// Get a table.
	//
	// Gets a table from the metastore for a specific catalog and schema. The caller
	// must satisfy one of the following requirements: * Be a metastore admin * Be
	// the owner of the parent catalog * Be the owner of the parent schema and have
	// the USE_CATALOG privilege on the parent catalog * Have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema, and either be the table owner or have the SELECT privilege on
	// the table.
	Get(ctx context.Context, request GetTableRequest) (*TableInfo, error)

	// Get a table.
	//
	// Gets a table from the metastore for a specific catalog and schema. The caller
	// must satisfy one of the following requirements: * Be a metastore admin * Be
	// the owner of the parent catalog * Be the owner of the parent schema and have
	// the USE_CATALOG privilege on the parent catalog * Have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema, and either be the table owner or have the SELECT privilege on
	// the table.
	GetByFullName(ctx context.Context, fullName string) (*TableInfo, error)

	// List tables.
	//
	// Gets an array of all tables for the current metastore under the parent
	// catalog and schema. The caller must be a metastore admin or an owner of (or
	// have the **SELECT** privilege on) the table. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
	// guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListTablesRequest) listing.Iterator[TableInfo]

	// List tables.
	//
	// Gets an array of all tables for the current metastore under the parent
	// catalog and schema. The caller must be a metastore admin or an owner of (or
	// have the **SELECT** privilege on) the table. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
	// guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListTablesRequest) ([]TableInfo, error)

	// TableInfoNameToTableIdMap calls [TablesAPI.ListAll] and creates a map of results with [TableInfo].Name as key and [TableInfo].TableId as value.
	//
	// Returns an error if there's more than one [TableInfo] with the same .Name.
	//
	// Note: All [TableInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	TableInfoNameToTableIdMap(ctx context.Context, request ListTablesRequest) (map[string]string, error)

	// GetByName calls [TablesAPI.TableInfoNameToTableIdMap] and returns a single [TableInfo].
	//
	// Returns an error if there's more than one [TableInfo] with the same .Name.
	//
	// Note: All [TableInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*TableInfo, error)

	// List table summaries.
	//
	// Gets an array of summaries for tables for a schema and catalog within the
	// metastore. The table summaries returned are either:
	//
	// * summaries for tables (within the current metastore and parent catalog and
	// schema), when the user is a metastore admin, or: * summaries for tables and
	// schemas (within the current metastore and parent catalog) for which the user
	// has ownership or the **SELECT** privilege on the table and ownership or
	// **USE_SCHEMA** privilege on the schema, provided that the user also has
	// ownership or the **USE_CATALOG** privilege on the parent catalog.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListSummaries(ctx context.Context, request ListSummariesRequest) listing.Iterator[TableSummary]

	// List table summaries.
	//
	// Gets an array of summaries for tables for a schema and catalog within the
	// metastore. The table summaries returned are either:
	//
	// * summaries for tables (within the current metastore and parent catalog and
	// schema), when the user is a metastore admin, or: * summaries for tables and
	// schemas (within the current metastore and parent catalog) for which the user
	// has ownership or the **SELECT** privilege on the table and ownership or
	// **USE_SCHEMA** privilege on the schema, provided that the user also has
	// ownership or the **USE_CATALOG** privilege on the parent catalog.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListSummariesAll(ctx context.Context, request ListSummariesRequest) ([]TableSummary, error)

	// Update a table owner.
	//
	// Change the owner of the table. The caller must be the owner of the parent
	// catalog, have the **USE_CATALOG** privilege on the parent catalog and be the
	// owner of the parent schema, or be the owner of the table and have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Update(ctx context.Context, request UpdateTableRequest) error
}

func NewTables(client *client.DatabricksClient) *TablesAPI {
	return &TablesAPI{
		tablesImpl: tablesImpl{
			client: client,
		},
	}
}

// A table resides in the third layer of Unity Catalog’s three-level
// namespace. It contains rows of data. To create a table, users must have
// CREATE_TABLE and USE_SCHEMA permissions on the schema, and they must have the
// USE_CATALOG permission on its parent catalog. To query a table, users must
// have the SELECT permission on the table, and they must have the USE_CATALOG
// permission on its parent catalog and the USE_SCHEMA permission on its parent
// schema.
//
// A table can be managed or external. From an API perspective, a __VIEW__ is a
// particular kind of table (rather than a managed or external table).
type TablesAPI struct {
	tablesImpl
}

// Delete a table.
//
// Deletes a table from the specified parent catalog and schema. The caller must
// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
// parent catalog and be the owner of the parent schema, or be the owner of the
// table and have the **USE_CATALOG** privilege on the parent catalog and the
// **USE_SCHEMA** privilege on the parent schema.
func (a *TablesAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.tablesImpl.Delete(ctx, DeleteTableRequest{
		FullName: fullName,
	})
}

// Get boolean reflecting if table exists.
//
// Gets if a table exists in the metastore for a specific catalog and schema.
// The caller must satisfy one of the following requirements: * Be a metastore
// admin * Be the owner of the parent catalog * Be the owner of the parent
// schema and have the USE_CATALOG privilege on the parent catalog * Have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema, and either be the table owner or have the
// SELECT privilege on the table. * Have BROWSE privilege on the parent catalog
// * Have BROWSE privilege on the parent schema.
func (a *TablesAPI) ExistsByFullName(ctx context.Context, fullName string) (*TableExistsResponse, error) {
	return a.tablesImpl.Exists(ctx, ExistsRequest{
		FullName: fullName,
	})
}

// Get a table.
//
// Gets a table from the metastore for a specific catalog and schema. The caller
// must satisfy one of the following requirements: * Be a metastore admin * Be
// the owner of the parent catalog * Be the owner of the parent schema and have
// the USE_CATALOG privilege on the parent catalog * Have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema, and either be the table owner or have the SELECT privilege on
// the table.
func (a *TablesAPI) GetByFullName(ctx context.Context, fullName string) (*TableInfo, error) {
	return a.tablesImpl.Get(ctx, GetTableRequest{
		FullName: fullName,
	})
}

// TableInfoNameToTableIdMap calls [TablesAPI.ListAll] and creates a map of results with [TableInfo].Name as key and [TableInfo].TableId as value.
//
// Returns an error if there's more than one [TableInfo] with the same .Name.
//
// Note: All [TableInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) TableInfoNameToTableIdMap(ctx context.Context, request ListTablesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.TableId
	}
	return mapping, nil
}

// GetByName calls [TablesAPI.TableInfoNameToTableIdMap] and returns a single [TableInfo].
//
// Returns an error if there's more than one [TableInfo] with the same .Name.
//
// Note: All [TableInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) GetByName(ctx context.Context, name string) (*TableInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTablesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TableInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TableInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TableInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type TemporaryTableCredentialsInterface interface {

	// Generate a temporary table credential.
	//
	// Get a short-lived credential for directly accessing the table data on cloud
	// storage. The metastore must have external_access_enabled flag set to true
	// (default false). The caller must have EXTERNAL_USE_SCHEMA privilege on the
	// parent schema and this privilege can only be granted by catalog owners.
	GenerateTemporaryTableCredentials(ctx context.Context, request GenerateTemporaryTableCredentialRequest) (*GenerateTemporaryTableCredentialResponse, error)
}

func NewTemporaryTableCredentials(client *client.DatabricksClient) *TemporaryTableCredentialsAPI {
	return &TemporaryTableCredentialsAPI{
		temporaryTableCredentialsImpl: temporaryTableCredentialsImpl{
			client: client,
		},
	}
}

// Temporary Table Credentials refer to short-lived, downscoped credentials used
// to access cloud storage locationswhere table data is stored in Databricks.
// These credentials are employed to provide secure and time-limitedaccess to
// data in cloud environments such as AWS, Azure, and Google Cloud. Each cloud
// provider has its own typeof credentials: AWS uses temporary session tokens
// via AWS Security Token Service (STS), Azure utilizesShared Access Signatures
// (SAS) for its data storage services, and Google Cloud supports temporary
// credentialsthrough OAuth 2.0.Temporary table credentials ensure that data
// access is limited in scope and duration, reducing the risk ofunauthorized
// access or misuse. To use the temporary table credentials API, a metastore
// admin needs to enable the external_access_enabled flag (off by default) at
// the metastore level, and user needs to be granted the EXTERNAL USE SCHEMA
// permission at the schema level by catalog admin. Note that EXTERNAL USE
// SCHEMA is a schema level permission that can only be granted by catalog admin
// explicitly and is not included in schema ownership or ALL PRIVILEGES on the
// schema for security reason.
type TemporaryTableCredentialsAPI struct {
	temporaryTableCredentialsImpl
}

type VolumesInterface interface {

	// Create a Volume.
	//
	// Creates a new volume.
	//
	// The user could create either an external volume or a managed volume. An
	// external volume will be created in the specified external location, while a
	// managed volume will be located in the default location which is specified by
	// the parent schema, or the parent catalog, or the Metastore.
	//
	// For the volume creation to succeed, the user must satisfy following
	// conditions: - The caller must be a metastore admin, or be the owner of the
	// parent catalog and schema, or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
	// caller must have **CREATE VOLUME** privilege on the parent schema.
	//
	// For an external volume, following conditions also need to satisfy - The
	// caller must have **CREATE EXTERNAL VOLUME** privilege on the external
	// location. - There are no other tables, nor volumes existing in the specified
	// storage location. - The specified storage location is not under the location
	// of other tables, nor volumes, or catalogs or schemas.
	Create(ctx context.Context, request CreateVolumeRequestContent) (*VolumeInfo, error)

	// Delete a Volume.
	//
	// Deletes a volume from the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	Delete(ctx context.Context, request DeleteVolumeRequest) error

	// Delete a Volume.
	//
	// Deletes a volume from the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	DeleteByName(ctx context.Context, name string) error

	// List Volumes.
	//
	// Gets an array of volumes for the current metastore under the parent catalog
	// and schema.
	//
	// The returned volumes are filtered based on the privileges of the calling
	// user. For example, the metastore admin is able to list all the volumes. A
	// regular user needs to be the owner or have the **READ VOLUME** privilege on
	// the volume to recieve the volumes in the response. For the latter case, the
	// caller must also be the owner or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListVolumesRequest) listing.Iterator[VolumeInfo]

	// List Volumes.
	//
	// Gets an array of volumes for the current metastore under the parent catalog
	// and schema.
	//
	// The returned volumes are filtered based on the privileges of the calling
	// user. For example, the metastore admin is able to list all the volumes. A
	// regular user needs to be the owner or have the **READ VOLUME** privilege on
	// the volume to recieve the volumes in the response. For the latter case, the
	// caller must also be the owner or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListVolumesRequest) ([]VolumeInfo, error)

	// VolumeInfoNameToVolumeIdMap calls [VolumesAPI.ListAll] and creates a map of results with [VolumeInfo].Name as key and [VolumeInfo].VolumeId as value.
	//
	// Returns an error if there's more than one [VolumeInfo] with the same .Name.
	//
	// Note: All [VolumeInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	VolumeInfoNameToVolumeIdMap(ctx context.Context, request ListVolumesRequest) (map[string]string, error)

	// GetByName calls [VolumesAPI.VolumeInfoNameToVolumeIdMap] and returns a single [VolumeInfo].
	//
	// Returns an error if there's more than one [VolumeInfo] with the same .Name.
	//
	// Note: All [VolumeInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*VolumeInfo, error)

	// Get a Volume.
	//
	// Gets a volume from the metastore for a specific catalog and schema.
	//
	// The caller must be a metastore admin or an owner of (or have the **READ
	// VOLUME** privilege on) the volume. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	Read(ctx context.Context, request ReadVolumeRequest) (*VolumeInfo, error)

	// Get a Volume.
	//
	// Gets a volume from the metastore for a specific catalog and schema.
	//
	// The caller must be a metastore admin or an owner of (or have the **READ
	// VOLUME** privilege on) the volume. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	ReadByName(ctx context.Context, name string) (*VolumeInfo, error)

	// Update a Volume.
	//
	// Updates the specified volume under the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// Currently only the name, the owner or the comment of the volume could be
	// updated.
	Update(ctx context.Context, request UpdateVolumeRequestContent) (*VolumeInfo, error)
}

func NewVolumes(client *client.DatabricksClient) *VolumesAPI {
	return &VolumesAPI{
		volumesImpl: volumesImpl{
			client: client,
		},
	}
}

// Volumes are a Unity Catalog (UC) capability for accessing, storing,
// governing, organizing and processing files. Use cases include running machine
// learning on unstructured data such as image, audio, video, or PDF files,
// organizing data sets during the data exploration stages in data science,
// working with libraries that require access to the local file system on
// cluster machines, storing library and config files of arbitrary formats such
// as .whl or .txt centrally and providing secure access across workspaces to
// it, or transforming and querying non-tabular data files in ETL.
type VolumesAPI struct {
	volumesImpl
}

// Delete a Volume.
//
// Deletes a volume from the specified parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the volume. For the
// latter case, the caller must also be the owner or have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema.
func (a *VolumesAPI) DeleteByName(ctx context.Context, name string) error {
	return a.volumesImpl.Delete(ctx, DeleteVolumeRequest{
		Name: name,
	})
}

// VolumeInfoNameToVolumeIdMap calls [VolumesAPI.ListAll] and creates a map of results with [VolumeInfo].Name as key and [VolumeInfo].VolumeId as value.
//
// Returns an error if there's more than one [VolumeInfo] with the same .Name.
//
// Note: All [VolumeInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) VolumeInfoNameToVolumeIdMap(ctx context.Context, request ListVolumesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.VolumeId
	}
	return mapping, nil
}

// GetByName calls [VolumesAPI.VolumeInfoNameToVolumeIdMap] and returns a single [VolumeInfo].
//
// Returns an error if there's more than one [VolumeInfo] with the same .Name.
//
// Note: All [VolumeInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) GetByName(ctx context.Context, name string) (*VolumeInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListVolumesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]VolumeInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("VolumeInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of VolumeInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Get a Volume.
//
// Gets a volume from the metastore for a specific catalog and schema.
//
// The caller must be a metastore admin or an owner of (or have the **READ
// VOLUME** privilege on) the volume. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *VolumesAPI) ReadByName(ctx context.Context, name string) (*VolumeInfo, error) {
	return a.volumesImpl.Read(ctx, ReadVolumeRequest{
		Name: name,
	})
}

type WorkspaceBindingsInterface interface {

	// Get catalog workspace bindings.
	//
	// Gets workspace bindings of the catalog. The caller must be a metastore admin
	// or an owner of the catalog.
	Get(ctx context.Context, request GetWorkspaceBindingRequest) (*CurrentWorkspaceBindings, error)

	// Get catalog workspace bindings.
	//
	// Gets workspace bindings of the catalog. The caller must be a metastore admin
	// or an owner of the catalog.
	GetByName(ctx context.Context, name string) (*CurrentWorkspaceBindings, error)

	// Get securable workspace bindings.
	//
	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetBindings(ctx context.Context, request GetBindingsRequest) listing.Iterator[WorkspaceBinding]

	// Get securable workspace bindings.
	//
	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetBindingsAll(ctx context.Context, request GetBindingsRequest) ([]WorkspaceBinding, error)

	// Get securable workspace bindings.
	//
	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	GetBindingsBySecurableTypeAndSecurableName(ctx context.Context, securableType GetBindingsSecurableType, securableName string) (*WorkspaceBindingsResponse, error)

	// Update catalog workspace bindings.
	//
	// Updates workspace bindings of the catalog. The caller must be a metastore
	// admin or an owner of the catalog.
	Update(ctx context.Context, request UpdateWorkspaceBindings) (*CurrentWorkspaceBindings, error)

	// Update securable workspace bindings.
	//
	// Updates workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	UpdateBindings(ctx context.Context, request UpdateWorkspaceBindingsParameters) (*WorkspaceBindingsResponse, error)
}

func NewWorkspaceBindings(client *client.DatabricksClient) *WorkspaceBindingsAPI {
	return &WorkspaceBindingsAPI{
		workspaceBindingsImpl: workspaceBindingsImpl{
			client: client,
		},
	}
}

// A securable in Databricks can be configured as __OPEN__ or __ISOLATED__. An
// __OPEN__ securable can be accessed from any workspace, while an __ISOLATED__
// securable can only be accessed from a configured list of workspaces. This API
// allows you to configure (bind) securables to workspaces.
//
// NOTE: The __isolation_mode__ is configured for the securable itself (using
// its Update method) and the workspace bindings are only consulted when the
// securable's __isolation_mode__ is set to __ISOLATED__.
//
// A securable's workspace bindings can be configured by a metastore admin or
// the owner of the securable.
//
// The original path (/api/2.1/unity-catalog/workspace-bindings/catalogs/{name})
// is deprecated. Please use the new path
// (/api/2.1/unity-catalog/bindings/{securable_type}/{securable_name}) which
// introduces the ability to bind a securable in READ_ONLY mode (catalogs only).
//
// Securable types that support binding: - catalog - storage_credential -
// external_location
type WorkspaceBindingsAPI struct {
	workspaceBindingsImpl
}

// Get catalog workspace bindings.
//
// Gets workspace bindings of the catalog. The caller must be a metastore admin
// or an owner of the catalog.
func (a *WorkspaceBindingsAPI) GetByName(ctx context.Context, name string) (*CurrentWorkspaceBindings, error) {
	return a.workspaceBindingsImpl.Get(ctx, GetWorkspaceBindingRequest{
		Name: name,
	})
}

// Get securable workspace bindings.
//
// Gets workspace bindings of the securable. The caller must be a metastore
// admin or an owner of the securable.
func (a *WorkspaceBindingsAPI) GetBindingsBySecurableTypeAndSecurableName(ctx context.Context, securableType GetBindingsSecurableType, securableName string) (*WorkspaceBindingsResponse, error) {
	return a.workspaceBindingsImpl.internalGetBindings(ctx, GetBindingsRequest{
		SecurableType: securableType,
		SecurableName: securableName,
	})
}
