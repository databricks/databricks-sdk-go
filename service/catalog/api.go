// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Metastore Assignments, Account Metastores, Account Storage Credentials, Artifact Allowlists, Catalogs, Connections, Credentials, Entity Tag Assignments, External Lineage, External Locations, External Metadata, Functions, Grants, Metastores, Model Versions, Online Tables, Policies, Quality Monitors, Registered Models, Resource Quotas, Rfa, Schemas, Storage Credentials, System Schemas, Table Constraints, Tables, Temporary Path Credentials, Temporary Table Credentials, Volumes, Workspace Bindings, etc.
package catalog

import (
	"context"
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/retries"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AccountMetastoreAssignmentsInterface interface {

	// Creates an assignment to a metastore for a workspace
	Create(ctx context.Context, request AccountsCreateMetastoreAssignment) (*AccountsCreateMetastoreAssignmentResponse, error)

	// Deletes a metastore assignment to a workspace, leaving the workspace with no
	// metastore.
	Delete(ctx context.Context, request DeleteAccountMetastoreAssignmentRequest) (*AccountsDeleteMetastoreAssignmentResponse, error)

	// Deletes a metastore assignment to a workspace, leaving the workspace with no
	// metastore.
	DeleteByWorkspaceIdAndMetastoreId(ctx context.Context, workspaceId int64, metastoreId string) (*AccountsDeleteMetastoreAssignmentResponse, error)

	// Gets the metastore assignment, if any, for the workspace specified by ID. If
	// the workspace is assigned a metastore, the mapping will be returned. If no
	// metastore is assigned to the workspace, the assignment will not be found and
	// a 404 returned.
	Get(ctx context.Context, request GetAccountMetastoreAssignmentRequest) (*AccountsMetastoreAssignment, error)

	// Gets the metastore assignment, if any, for the workspace specified by ID. If
	// the workspace is assigned a metastore, the mapping will be returned. If no
	// metastore is assigned to the workspace, the assignment will not be found and
	// a 404 returned.
	GetByWorkspaceId(ctx context.Context, workspaceId int64) (*AccountsMetastoreAssignment, error)

	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) listing.Iterator[int64]

	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) ([]int64, error)

	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountMetastoreAssignmentsResponse, error)

	// Updates an assignment to a metastore for a workspace. Currently, only the
	// default catalog may be updated.
	Update(ctx context.Context, request AccountsUpdateMetastoreAssignment) (*AccountsUpdateMetastoreAssignmentResponse, error)
}

func NewAccountMetastoreAssignments(client *client.DatabricksClient) *AccountMetastoreAssignmentsAPI {
	return &AccountMetastoreAssignmentsAPI{
		accountMetastoreAssignmentsImpl: accountMetastoreAssignmentsImpl{
			client: client,
		},
	}
}

// These APIs manage metastore assignments to a workspace.
type AccountMetastoreAssignmentsAPI struct {
	accountMetastoreAssignmentsImpl
}

// Deletes a metastore assignment to a workspace, leaving the workspace with no
// metastore.
func (a *AccountMetastoreAssignmentsAPI) DeleteByWorkspaceIdAndMetastoreId(ctx context.Context, workspaceId int64, metastoreId string) (*AccountsDeleteMetastoreAssignmentResponse, error) {
	return a.accountMetastoreAssignmentsImpl.Delete(ctx, DeleteAccountMetastoreAssignmentRequest{
		WorkspaceId: workspaceId,
		MetastoreId: metastoreId,
	})
}

// Gets the metastore assignment, if any, for the workspace specified by ID. If
// the workspace is assigned a metastore, the mapping will be returned. If no
// metastore is assigned to the workspace, the assignment will not be found and
// a 404 returned.
func (a *AccountMetastoreAssignmentsAPI) GetByWorkspaceId(ctx context.Context, workspaceId int64) (*AccountsMetastoreAssignment, error) {
	return a.accountMetastoreAssignmentsImpl.Get(ctx, GetAccountMetastoreAssignmentRequest{
		WorkspaceId: workspaceId,
	})
}

// Gets a list of all Databricks workspace IDs that have been assigned to given
// metastore.
func (a *AccountMetastoreAssignmentsAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountMetastoreAssignmentsResponse, error) {
	return a.accountMetastoreAssignmentsImpl.internalList(ctx, ListAccountMetastoreAssignmentsRequest{
		MetastoreId: metastoreId,
	})
}

type AccountMetastoresInterface interface {

	// Creates a Unity Catalog metastore.
	Create(ctx context.Context, request AccountsCreateMetastore) (*AccountsCreateMetastoreResponse, error)

	// Deletes a Unity Catalog metastore for an account, both specified by ID.
	Delete(ctx context.Context, request DeleteAccountMetastoreRequest) (*AccountsDeleteMetastoreResponse, error)

	// Deletes a Unity Catalog metastore for an account, both specified by ID.
	DeleteByMetastoreId(ctx context.Context, metastoreId string) (*AccountsDeleteMetastoreResponse, error)

	// Gets a Unity Catalog metastore from an account, both specified by ID.
	Get(ctx context.Context, request GetAccountMetastoreRequest) (*AccountsGetMetastoreResponse, error)

	// Gets a Unity Catalog metastore from an account, both specified by ID.
	GetByMetastoreId(ctx context.Context, metastoreId string) (*AccountsGetMetastoreResponse, error)

	// Gets all Unity Catalog metastores associated with an account specified by ID.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[MetastoreInfo]

	// Gets all Unity Catalog metastores associated with an account specified by ID.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]MetastoreInfo, error)

	// Updates an existing Unity Catalog metastore.
	Update(ctx context.Context, request AccountsUpdateMetastore) (*AccountsUpdateMetastoreResponse, error)
}

func NewAccountMetastores(client *client.DatabricksClient) *AccountMetastoresAPI {
	return &AccountMetastoresAPI{
		accountMetastoresImpl: accountMetastoresImpl{
			client: client,
		},
	}
}

// These APIs manage Unity Catalog metastores for an account. A metastore
// contains catalogs that can be associated with workspaces
type AccountMetastoresAPI struct {
	accountMetastoresImpl
}

// Deletes a Unity Catalog metastore for an account, both specified by ID.
func (a *AccountMetastoresAPI) DeleteByMetastoreId(ctx context.Context, metastoreId string) (*AccountsDeleteMetastoreResponse, error) {
	return a.accountMetastoresImpl.Delete(ctx, DeleteAccountMetastoreRequest{
		MetastoreId: metastoreId,
	})
}

// Gets a Unity Catalog metastore from an account, both specified by ID.
func (a *AccountMetastoresAPI) GetByMetastoreId(ctx context.Context, metastoreId string) (*AccountsGetMetastoreResponse, error) {
	return a.accountMetastoresImpl.Get(ctx, GetAccountMetastoreRequest{
		MetastoreId: metastoreId,
	})
}

type AccountStorageCredentialsInterface interface {

	// Creates a new storage credential. The request object is specific to the
	// cloud: - **AwsIamRole** for AWS credentials - **AzureServicePrincipal** for
	// Azure credentials - **GcpServiceAccountKey** for GCP credentials
	//
	// The caller must be a metastore admin and have the `CREATE_STORAGE_CREDENTIAL`
	// privilege on the metastore.
	Create(ctx context.Context, request AccountsCreateStorageCredential) (*AccountsCreateStorageCredentialInfo, error)

	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	Delete(ctx context.Context, request DeleteAccountStorageCredentialRequest) (*AccountsDeleteStorageCredentialResponse, error)

	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	DeleteByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsDeleteStorageCredentialResponse, error)

	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have a level of privilege on
	// the storage credential.
	Get(ctx context.Context, request GetAccountStorageCredentialRequest) (*AccountsStorageCredentialInfo, error)

	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have a level of privilege on
	// the storage credential.
	GetByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsStorageCredentialInfo, error)

	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAccountStorageCredentialsRequest) listing.Iterator[StorageCredentialInfo]

	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAccountStorageCredentialsRequest) ([]StorageCredentialInfo, error)

	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountStorageCredentialsResponse, error)

	// Updates a storage credential on the metastore. The caller must be the owner
	// of the storage credential. If the caller is a metastore admin, only the
	// **owner** credential can be changed.
	Update(ctx context.Context, request AccountsUpdateStorageCredential) (*AccountsUpdateStorageCredentialResponse, error)
}

func NewAccountStorageCredentials(client *client.DatabricksClient) *AccountStorageCredentialsAPI {
	return &AccountStorageCredentialsAPI{
		accountStorageCredentialsImpl: accountStorageCredentialsImpl{
			client: client,
		},
	}
}

// These APIs manage storage credentials for a particular metastore.
type AccountStorageCredentialsAPI struct {
	accountStorageCredentialsImpl
}

// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *AccountStorageCredentialsAPI) DeleteByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsDeleteStorageCredentialResponse, error) {
	return a.accountStorageCredentialsImpl.Delete(ctx, DeleteAccountStorageCredentialRequest{
		MetastoreId:           metastoreId,
		StorageCredentialName: storageCredentialName,
	})
}

// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have a level of privilege on
// the storage credential.
func (a *AccountStorageCredentialsAPI) GetByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsStorageCredentialInfo, error) {
	return a.accountStorageCredentialsImpl.Get(ctx, GetAccountStorageCredentialRequest{
		MetastoreId:           metastoreId,
		StorageCredentialName: storageCredentialName,
	})
}

// Gets a list of all storage credentials that have been assigned to given
// metastore.
func (a *AccountStorageCredentialsAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountStorageCredentialsResponse, error) {
	return a.accountStorageCredentialsImpl.internalList(ctx, ListAccountStorageCredentialsRequest{
		MetastoreId: metastoreId,
	})
}

type ArtifactAllowlistsInterface interface {

	// Get the artifact allowlist of a certain artifact type. The caller must be a
	// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	Get(ctx context.Context, request GetArtifactAllowlistRequest) (*ArtifactAllowlistInfo, error)

	// Get the artifact allowlist of a certain artifact type. The caller must be a
	// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	GetByArtifactType(ctx context.Context, artifactType ArtifactType) (*ArtifactAllowlistInfo, error)

	// Set the artifact allowlist of a certain artifact type. The whole artifact
	// allowlist is replaced with the new allowlist. The caller must be a metastore
	// admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	Update(ctx context.Context, request SetArtifactAllowlist) (*ArtifactAllowlistInfo, error)
}

func NewArtifactAllowlists(client *client.DatabricksClient) *ArtifactAllowlistsAPI {
	return &ArtifactAllowlistsAPI{
		artifactAllowlistsImpl: artifactAllowlistsImpl{
			client: client,
		},
	}
}

// In Databricks Runtime 13.3 and above, you can add libraries and init scripts
// to the `allowlist` in UC so that users can leverage these artifacts on
// compute configured with shared access mode.
type ArtifactAllowlistsAPI struct {
	artifactAllowlistsImpl
}

// Get the artifact allowlist of a certain artifact type. The caller must be a
// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
func (a *ArtifactAllowlistsAPI) GetByArtifactType(ctx context.Context, artifactType ArtifactType) (*ArtifactAllowlistInfo, error) {
	return a.artifactAllowlistsImpl.Get(ctx, GetArtifactAllowlistRequest{
		ArtifactType: artifactType,
	})
}

type CatalogsInterface interface {

	// Creates a new catalog instance in the parent metastore if the caller is a
	// metastore admin or has the **CREATE_CATALOG** privilege.
	Create(ctx context.Context, request CreateCatalog) (*CatalogInfo, error)

	// Deletes the catalog that matches the supplied name. The caller must be a
	// metastore admin or the owner of the catalog.
	Delete(ctx context.Context, request DeleteCatalogRequest) error

	// Deletes the catalog that matches the supplied name. The caller must be a
	// metastore admin or the owner of the catalog.
	DeleteByName(ctx context.Context, name string) error

	// Gets the specified catalog in a metastore. The caller must be a metastore
	// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
	// privilege set for their account.
	Get(ctx context.Context, request GetCatalogRequest) (*CatalogInfo, error)

	// Gets the specified catalog in a metastore. The caller must be a metastore
	// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
	// privilege set for their account.
	GetByName(ctx context.Context, name string) (*CatalogInfo, error)

	// Gets an array of catalogs in the metastore. If the caller is the metastore
	// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
	// caller (or for which the caller has the **USE_CATALOG** privilege) will be
	// retrieved. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListCatalogsRequest) listing.Iterator[CatalogInfo]

	// Gets an array of catalogs in the metastore. If the caller is the metastore
	// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
	// caller (or for which the caller has the **USE_CATALOG** privilege) will be
	// retrieved. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListCatalogsRequest) ([]CatalogInfo, error)

	// Updates the catalog that matches the supplied name. The caller must be either
	// the owner of the catalog, or a metastore admin (when changing the owner field
	// of the catalog).
	Update(ctx context.Context, request UpdateCatalog) (*CatalogInfo, error)
}

func NewCatalogs(client *client.DatabricksClient) *CatalogsAPI {
	return &CatalogsAPI{
		catalogsImpl: catalogsImpl{
			client: client,
		},
	}
}

// A catalog is the first layer of Unity Catalog’s three-level namespace.
// It’s used to organize your data assets. Users can see all catalogs on which
// they have been assigned the USE_CATALOG data permission.
//
// In Unity Catalog, admins and data stewards manage users and their access to
// data centrally across all of the workspaces in a Databricks account. Users in
// different workspaces can share access to the same data, depending on
// privileges granted centrally in Unity Catalog.
type CatalogsAPI struct {
	catalogsImpl
}

// Deletes the catalog that matches the supplied name. The caller must be a
// metastore admin or the owner of the catalog.
func (a *CatalogsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.catalogsImpl.Delete(ctx, DeleteCatalogRequest{
		Name: name,
	})
}

// Gets the specified catalog in a metastore. The caller must be a metastore
// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
// privilege set for their account.
func (a *CatalogsAPI) GetByName(ctx context.Context, name string) (*CatalogInfo, error) {
	return a.catalogsImpl.Get(ctx, GetCatalogRequest{
		Name: name,
	})
}

type ConnectionsInterface interface {

	// Creates a new connection
	//
	// Creates a new connection to an external data source. It allows users to
	// specify connection details and configurations for interaction with the
	// external server.
	Create(ctx context.Context, request CreateConnection) (*ConnectionInfo, error)

	// Deletes the connection that matches the supplied name.
	Delete(ctx context.Context, request DeleteConnectionRequest) error

	// Deletes the connection that matches the supplied name.
	DeleteByName(ctx context.Context, name string) error

	// Gets a connection from it's name.
	Get(ctx context.Context, request GetConnectionRequest) (*ConnectionInfo, error)

	// Gets a connection from it's name.
	GetByName(ctx context.Context, name string) (*ConnectionInfo, error)

	// List all connections.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListConnectionsRequest) listing.Iterator[ConnectionInfo]

	// List all connections.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListConnectionsRequest) ([]ConnectionInfo, error)

	// ConnectionInfoNameToFullNameMap calls [ConnectionsAPI.ListAll] and creates a map of results with [ConnectionInfo].Name as key and [ConnectionInfo].FullName as value.
	//
	// Returns an error if there's more than one [ConnectionInfo] with the same .Name.
	//
	// Note: All [ConnectionInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	ConnectionInfoNameToFullNameMap(ctx context.Context, request ListConnectionsRequest) (map[string]string, error)

	// Updates the connection that matches the supplied name.
	Update(ctx context.Context, request UpdateConnection) (*ConnectionInfo, error)
}

func NewConnections(client *client.DatabricksClient) *ConnectionsAPI {
	return &ConnectionsAPI{
		connectionsImpl: connectionsImpl{
			client: client,
		},
	}
}

// Connections allow for creating a connection to an external data source.
//
// A connection is an abstraction of an external data source that can be
// connected from Databricks Compute. Creating a connection object is the first
// step to managing external data sources within Unity Catalog, with the second
// step being creating a data object (catalog, schema, or table) using the
// connection. Data objects derived from a connection can be written to or read
// from similar to other Unity Catalog data objects based on cloud storage.
// Users may create different types of connections with each connection having a
// unique set of configuration options to support credential management and
// other settings.
type ConnectionsAPI struct {
	connectionsImpl
}

// Deletes the connection that matches the supplied name.
func (a *ConnectionsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.connectionsImpl.Delete(ctx, DeleteConnectionRequest{
		Name: name,
	})
}

// Gets a connection from it's name.
func (a *ConnectionsAPI) GetByName(ctx context.Context, name string) (*ConnectionInfo, error) {
	return a.connectionsImpl.Get(ctx, GetConnectionRequest{
		Name: name,
	})
}

// ConnectionInfoNameToFullNameMap calls [ConnectionsAPI.ListAll] and creates a map of results with [ConnectionInfo].Name as key and [ConnectionInfo].FullName as value.
//
// Returns an error if there's more than one [ConnectionInfo] with the same .Name.
//
// Note: All [ConnectionInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConnectionsAPI) ConnectionInfoNameToFullNameMap(ctx context.Context, request ListConnectionsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

type CredentialsInterface interface {

	// Creates a new credential. The type of credential to be created is determined
	// by the **purpose** field, which should be either **SERVICE** or **STORAGE**.
	//
	// The caller must be a metastore admin or have the metastore privilege
	// **CREATE_STORAGE_CREDENTIAL** for storage credentials, or
	// **CREATE_SERVICE_CREDENTIAL** for service credentials.
	CreateCredential(ctx context.Context, request CreateCredentialRequest) (*CredentialInfo, error)

	// Deletes a service or storage credential from the metastore. The caller must
	// be an owner of the credential.
	DeleteCredential(ctx context.Context, request DeleteCredentialRequest) error

	// Deletes a service or storage credential from the metastore. The caller must
	// be an owner of the credential.
	DeleteCredentialByNameArg(ctx context.Context, nameArg string) error

	// Returns a set of temporary credentials generated using the specified service
	// credential. The caller must be a metastore admin or have the metastore
	// privilege **ACCESS** on the service credential.
	GenerateTemporaryServiceCredential(ctx context.Context, request GenerateTemporaryServiceCredentialRequest) (*TemporaryCredentials, error)

	// Gets a service or storage credential from the metastore. The caller must be a
	// metastore admin, the owner of the credential, or have any permission on the
	// credential.
	GetCredential(ctx context.Context, request GetCredentialRequest) (*CredentialInfo, error)

	// Gets a service or storage credential from the metastore. The caller must be a
	// metastore admin, the owner of the credential, or have any permission on the
	// credential.
	GetCredentialByNameArg(ctx context.Context, nameArg string) (*CredentialInfo, error)

	// Gets an array of credentials (as __CredentialInfo__ objects).
	//
	// The array is limited to only the credentials that the caller has permission
	// to access. If the caller is a metastore admin, retrieval of credentials is
	// unrestricted. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListCredentials(ctx context.Context, request ListCredentialsRequest) listing.Iterator[CredentialInfo]

	// Gets an array of credentials (as __CredentialInfo__ objects).
	//
	// The array is limited to only the credentials that the caller has permission
	// to access. If the caller is a metastore admin, retrieval of credentials is
	// unrestricted. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListCredentialsAll(ctx context.Context, request ListCredentialsRequest) ([]CredentialInfo, error)

	// Updates a service or storage credential on the metastore.
	//
	// The caller must be the owner of the credential or a metastore admin or have
	// the `MANAGE` permission. If the caller is a metastore admin, only the
	// __owner__ field can be changed.
	UpdateCredential(ctx context.Context, request UpdateCredentialRequest) (*CredentialInfo, error)

	// Validates a credential.
	//
	// For service credentials (purpose is **SERVICE**), either the
	// __credential_name__ or the cloud-specific credential must be provided.
	//
	// For storage credentials (purpose is **STORAGE**), at least one of
	// __external_location_name__ and __url__ need to be provided. If only one of
	// them is provided, it will be used for validation. And if both are provided,
	// the __url__ will be used for validation, and __external_location_name__ will
	// be ignored when checking overlapping urls. Either the __credential_name__ or
	// the cloud-specific credential must be provided.
	//
	// The caller must be a metastore admin or the credential owner or have the
	// required permission on the metastore and the credential (e.g.,
	// **CREATE_EXTERNAL_LOCATION** when purpose is **STORAGE**).
	ValidateCredential(ctx context.Context, request ValidateCredentialRequest) (*ValidateCredentialResponse, error)
}

func NewCredentials(client *client.DatabricksClient) *CredentialsAPI {
	return &CredentialsAPI{
		credentialsImpl: credentialsImpl{
			client: client,
		},
	}
}

// A credential represents an authentication and authorization mechanism for
// accessing services on your cloud tenant. Each credential is subject to Unity
// Catalog access-control policies that control which users and groups can
// access the credential.
//
// To create credentials, you must be a Databricks account admin or have the
// `CREATE SERVICE CREDENTIAL` privilege. The user who creates the credential
// can delegate ownership to another user or group to manage permissions on it.
type CredentialsAPI struct {
	credentialsImpl
}

// Deletes a service or storage credential from the metastore. The caller must
// be an owner of the credential.
func (a *CredentialsAPI) DeleteCredentialByNameArg(ctx context.Context, nameArg string) error {
	return a.credentialsImpl.DeleteCredential(ctx, DeleteCredentialRequest{
		NameArg: nameArg,
	})
}

// Gets a service or storage credential from the metastore. The caller must be a
// metastore admin, the owner of the credential, or have any permission on the
// credential.
func (a *CredentialsAPI) GetCredentialByNameArg(ctx context.Context, nameArg string) (*CredentialInfo, error) {
	return a.credentialsImpl.GetCredential(ctx, GetCredentialRequest{
		NameArg: nameArg,
	})
}

type EntityTagAssignmentsInterface interface {

	// Creates a tag assignment for an Unity Catalog entity.
	//
	// To add tags to Unity Catalog entities, you must own the entity or have the
	// following privileges: - **APPLY TAG** on the entity - **USE SCHEMA** on the
	// entity's parent schema - **USE CATALOG** on the entity's parent catalog
	//
	// To add a governed tag to Unity Catalog entities, you must also have the
	// **ASSIGN** or **MANAGE** permission on the tag policy. See [Manage tag policy
	// permissions].
	//
	// [Manage tag policy permissions]: https://docs.databricks.com/aws/en/admin/tag-policies/manage-permissions
	Create(ctx context.Context, request CreateEntityTagAssignmentRequest) (*EntityTagAssignment, error)

	// Deletes a tag assignment for an Unity Catalog entity by its key.
	//
	// To delete tags from Unity Catalog entities, you must own the entity or have
	// the following privileges: - **APPLY TAG** on the entity - **USE_SCHEMA** on
	// the entity's parent schema - **USE_CATALOG** on the entity's parent catalog
	//
	// To delete a governed tag from Unity Catalog entities, you must also have the
	// **ASSIGN** or **MANAGE** permission on the tag policy. See [Manage tag policy
	// permissions].
	//
	// [Manage tag policy permissions]: https://docs.databricks.com/aws/en/admin/tag-policies/manage-permissions
	Delete(ctx context.Context, request DeleteEntityTagAssignmentRequest) error

	// Gets a tag assignment for an Unity Catalog entity by tag key.
	Get(ctx context.Context, request GetEntityTagAssignmentRequest) (*EntityTagAssignment, error)

	// List tag assignments for an Unity Catalog entity
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListEntityTagAssignmentsRequest) listing.Iterator[EntityTagAssignment]

	// List tag assignments for an Unity Catalog entity
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListEntityTagAssignmentsRequest) ([]EntityTagAssignment, error)

	// Updates an existing tag assignment for an Unity Catalog entity.
	//
	// To update tags to Unity Catalog entities, you must own the entity or have the
	// following privileges: - **APPLY TAG** on the entity - **USE SCHEMA** on the
	// entity's parent schema - **USE CATALOG** on the entity's parent catalog
	//
	// To update a governed tag to Unity Catalog entities, you must also have the
	// **ASSIGN** or **MANAGE** permission on the tag policy. See [Manage tag policy
	// permissions].
	//
	// [Manage tag policy permissions]: https://docs.databricks.com/aws/en/admin/tag-policies/manage-permissions
	Update(ctx context.Context, request UpdateEntityTagAssignmentRequest) (*EntityTagAssignment, error)
}

func NewEntityTagAssignments(client *client.DatabricksClient) *EntityTagAssignmentsAPI {
	return &EntityTagAssignmentsAPI{
		entityTagAssignmentsImpl: entityTagAssignmentsImpl{
			client: client,
		},
	}
}

// Tags are attributes that include keys and optional values that you can use to
// organize and categorize entities in Unity Catalog. Entity tagging is
// currently supported on catalogs, schemas, tables (including views), columns,
// volumes. With these APIs, users can create, update, delete, and list tag
// assignments across Unity Catalog entities
type EntityTagAssignmentsAPI struct {
	entityTagAssignmentsImpl
}

type ExternalLineageInterface interface {

	// Creates an external lineage relationship between a Databricks or external
	// metadata object and another external metadata object.
	CreateExternalLineageRelationship(ctx context.Context, request CreateExternalLineageRelationshipRequest) (*ExternalLineageRelationship, error)

	// Deletes an external lineage relationship between a Databricks or external
	// metadata object and another external metadata object.
	DeleteExternalLineageRelationship(ctx context.Context, request DeleteExternalLineageRelationshipRequest) error

	// Lists external lineage relationships of a Databricks object or external
	// metadata given a supplied direction.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListExternalLineageRelationships(ctx context.Context, request ListExternalLineageRelationshipsRequest) listing.Iterator[ExternalLineageInfo]

	// Lists external lineage relationships of a Databricks object or external
	// metadata given a supplied direction.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListExternalLineageRelationshipsAll(ctx context.Context, request ListExternalLineageRelationshipsRequest) ([]ExternalLineageInfo, error)

	// Updates an external lineage relationship between a Databricks or external
	// metadata object and another external metadata object.
	UpdateExternalLineageRelationship(ctx context.Context, request UpdateExternalLineageRelationshipRequest) (*ExternalLineageRelationship, error)
}

func NewExternalLineage(client *client.DatabricksClient) *ExternalLineageAPI {
	return &ExternalLineageAPI{
		externalLineageImpl: externalLineageImpl{
			client: client,
		},
	}
}

// External Lineage APIs enable defining and managing lineage relationships
// between Databricks objects and external systems. These APIs allow users to
// capture data flows connecting Databricks tables, models, and file paths with
// external metadata objects.
//
// With these APIs, users can create, update, delete, and list lineage
// relationships with support for column-level mappings and custom properties.
type ExternalLineageAPI struct {
	externalLineageImpl
}

type ExternalLocationsInterface interface {

	// Creates a new external location entry in the metastore. The caller must be a
	// metastore admin or have the **CREATE_EXTERNAL_LOCATION** privilege on both
	// the metastore and the associated storage credential.
	Create(ctx context.Context, request CreateExternalLocation) (*ExternalLocationInfo, error)

	// Deletes the specified external location from the metastore. The caller must
	// be the owner of the external location.
	Delete(ctx context.Context, request DeleteExternalLocationRequest) error

	// Deletes the specified external location from the metastore. The caller must
	// be the owner of the external location.
	DeleteByName(ctx context.Context, name string) error

	// Gets an external location from the metastore. The caller must be either a
	// metastore admin, the owner of the external location, or a user that has some
	// privilege on the external location.
	Get(ctx context.Context, request GetExternalLocationRequest) (*ExternalLocationInfo, error)

	// Gets an external location from the metastore. The caller must be either a
	// metastore admin, the owner of the external location, or a user that has some
	// privilege on the external location.
	GetByName(ctx context.Context, name string) (*ExternalLocationInfo, error)

	// Gets an array of external locations (__ExternalLocationInfo__ objects) from
	// the metastore. The caller must be a metastore admin, the owner of the
	// external location, or a user that has some privilege on the external
	// location. There is no guarantee of a specific ordering of the elements in the
	// array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListExternalLocationsRequest) listing.Iterator[ExternalLocationInfo]

	// Gets an array of external locations (__ExternalLocationInfo__ objects) from
	// the metastore. The caller must be a metastore admin, the owner of the
	// external location, or a user that has some privilege on the external
	// location. There is no guarantee of a specific ordering of the elements in the
	// array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListExternalLocationsRequest) ([]ExternalLocationInfo, error)

	// Updates an external location in the metastore. The caller must be the owner
	// of the external location, or be a metastore admin. In the second case, the
	// admin can only update the name of the external location.
	Update(ctx context.Context, request UpdateExternalLocation) (*ExternalLocationInfo, error)
}

func NewExternalLocations(client *client.DatabricksClient) *ExternalLocationsAPI {
	return &ExternalLocationsAPI{
		externalLocationsImpl: externalLocationsImpl{
			client: client,
		},
	}
}

// An external location is an object that combines a cloud storage path with a
// storage credential that authorizes access to the cloud storage path. Each
// external location is subject to Unity Catalog access-control policies that
// control which users and groups can access the credential. If a user does not
// have access to an external location in Unity Catalog, the request fails and
// Unity Catalog does not attempt to authenticate to your cloud tenant on the
// user’s behalf.
//
// Databricks recommends using external locations rather than using storage
// credentials directly.
//
// To create external locations, you must be a metastore admin or a user with
// the **CREATE_EXTERNAL_LOCATION** privilege.
type ExternalLocationsAPI struct {
	externalLocationsImpl
}

// Deletes the specified external location from the metastore. The caller must
// be the owner of the external location.
func (a *ExternalLocationsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.externalLocationsImpl.Delete(ctx, DeleteExternalLocationRequest{
		Name: name,
	})
}

// Gets an external location from the metastore. The caller must be either a
// metastore admin, the owner of the external location, or a user that has some
// privilege on the external location.
func (a *ExternalLocationsAPI) GetByName(ctx context.Context, name string) (*ExternalLocationInfo, error) {
	return a.externalLocationsImpl.Get(ctx, GetExternalLocationRequest{
		Name: name,
	})
}

type ExternalMetadataInterface interface {

	// Creates a new external metadata object in the parent metastore if the caller
	// is a metastore admin or has the **CREATE_EXTERNAL_METADATA** privilege.
	// Grants **BROWSE** to all account users upon creation by default.
	CreateExternalMetadata(ctx context.Context, request CreateExternalMetadataRequest) (*ExternalMetadata, error)

	// Deletes the external metadata object that matches the supplied name. The
	// caller must be a metastore admin, the owner of the external metadata object,
	// or a user that has the **MANAGE** privilege.
	DeleteExternalMetadata(ctx context.Context, request DeleteExternalMetadataRequest) error

	// Deletes the external metadata object that matches the supplied name. The
	// caller must be a metastore admin, the owner of the external metadata object,
	// or a user that has the **MANAGE** privilege.
	DeleteExternalMetadataByName(ctx context.Context, name string) error

	// Gets the specified external metadata object in a metastore. The caller must
	// be a metastore admin, the owner of the external metadata object, or a user
	// that has the **BROWSE** privilege.
	GetExternalMetadata(ctx context.Context, request GetExternalMetadataRequest) (*ExternalMetadata, error)

	// Gets the specified external metadata object in a metastore. The caller must
	// be a metastore admin, the owner of the external metadata object, or a user
	// that has the **BROWSE** privilege.
	GetExternalMetadataByName(ctx context.Context, name string) (*ExternalMetadata, error)

	// Gets an array of external metadata objects in the metastore. If the caller is
	// the metastore admin, all external metadata objects will be retrieved.
	// Otherwise, only external metadata objects that the caller has **BROWSE** on
	// will be retrieved. There is no guarantee of a specific ordering of the
	// elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListExternalMetadata(ctx context.Context, request ListExternalMetadataRequest) listing.Iterator[ExternalMetadata]

	// Gets an array of external metadata objects in the metastore. If the caller is
	// the metastore admin, all external metadata objects will be retrieved.
	// Otherwise, only external metadata objects that the caller has **BROWSE** on
	// will be retrieved. There is no guarantee of a specific ordering of the
	// elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListExternalMetadataAll(ctx context.Context, request ListExternalMetadataRequest) ([]ExternalMetadata, error)

	// Updates the external metadata object that matches the supplied name. The
	// caller can only update either the owner or other metadata fields in one
	// request. The caller must be a metastore admin, the owner of the external
	// metadata object, or a user that has the **MODIFY** privilege. If the caller
	// is updating the owner, they must also have the **MANAGE** privilege.
	UpdateExternalMetadata(ctx context.Context, request UpdateExternalMetadataRequest) (*ExternalMetadata, error)
}

func NewExternalMetadata(client *client.DatabricksClient) *ExternalMetadataAPI {
	return &ExternalMetadataAPI{
		externalMetadataImpl: externalMetadataImpl{
			client: client,
		},
	}
}

// External Metadata objects enable customers to register and manage metadata
// about external systems within Unity Catalog.
//
// These APIs provide a standardized way to create, update, retrieve, list, and
// delete external metadata objects. Fine-grained authorization ensures that
// only users with appropriate permissions can view and manage external metadata
// objects.
type ExternalMetadataAPI struct {
	externalMetadataImpl
}

// Deletes the external metadata object that matches the supplied name. The
// caller must be a metastore admin, the owner of the external metadata object,
// or a user that has the **MANAGE** privilege.
func (a *ExternalMetadataAPI) DeleteExternalMetadataByName(ctx context.Context, name string) error {
	return a.externalMetadataImpl.DeleteExternalMetadata(ctx, DeleteExternalMetadataRequest{
		Name: name,
	})
}

// Gets the specified external metadata object in a metastore. The caller must
// be a metastore admin, the owner of the external metadata object, or a user
// that has the **BROWSE** privilege.
func (a *ExternalMetadataAPI) GetExternalMetadataByName(ctx context.Context, name string) (*ExternalMetadata, error) {
	return a.externalMetadataImpl.GetExternalMetadata(ctx, GetExternalMetadataRequest{
		Name: name,
	})
}

type FunctionsInterface interface {

	// **WARNING: This API is experimental and will change in future versions**
	//
	// Creates a new function
	//
	// The user must have the following permissions in order for the function to be
	// created: - **USE_CATALOG** on the function's parent catalog - **USE_SCHEMA**
	// and **CREATE_FUNCTION** on the function's parent schema
	Create(ctx context.Context, request CreateFunctionRequest) (*FunctionInfo, error)

	// Deletes the function that matches the supplied name. For the deletion to
	// succeed, the user must satisfy one of the following conditions: - Is the
	// owner of the function's parent catalog - Is the owner of the function's
	// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
	// Is the owner of the function itself and have both the **USE_CATALOG**
	// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
	// parent schema
	Delete(ctx context.Context, request DeleteFunctionRequest) error

	// Deletes the function that matches the supplied name. For the deletion to
	// succeed, the user must satisfy one of the following conditions: - Is the
	// owner of the function's parent catalog - Is the owner of the function's
	// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
	// Is the owner of the function itself and have both the **USE_CATALOG**
	// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
	// parent schema
	DeleteByName(ctx context.Context, name string) error

	// Gets a function from within a parent catalog and schema. For the fetch to
	// succeed, the user must satisfy one of the following requirements: - Is a
	// metastore admin - Is an owner of the function's parent catalog - Have the
	// **USE_CATALOG** privilege on the function's parent catalog and be the owner
	// of the function - Have the **USE_CATALOG** privilege on the function's parent
	// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
	// the **EXECUTE** privilege on the function itself
	Get(ctx context.Context, request GetFunctionRequest) (*FunctionInfo, error)

	// Gets a function from within a parent catalog and schema. For the fetch to
	// succeed, the user must satisfy one of the following requirements: - Is a
	// metastore admin - Is an owner of the function's parent catalog - Have the
	// **USE_CATALOG** privilege on the function's parent catalog and be the owner
	// of the function - Have the **USE_CATALOG** privilege on the function's parent
	// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
	// the **EXECUTE** privilege on the function itself
	GetByName(ctx context.Context, name string) (*FunctionInfo, error)

	// List functions within the specified parent catalog and schema. If the user is
	// a metastore admin, all functions are returned in the output list. Otherwise,
	// the user must have the **USE_CATALOG** privilege on the catalog and the
	// **USE_SCHEMA** privilege on the schema, and the output list contains only
	// functions for which either the user has the **EXECUTE** privilege or the user
	// is the owner. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListFunctionsRequest) listing.Iterator[FunctionInfo]

	// List functions within the specified parent catalog and schema. If the user is
	// a metastore admin, all functions are returned in the output list. Otherwise,
	// the user must have the **USE_CATALOG** privilege on the catalog and the
	// **USE_SCHEMA** privilege on the schema, and the output list contains only
	// functions for which either the user has the **EXECUTE** privilege or the user
	// is the owner. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListFunctionsRequest) ([]FunctionInfo, error)

	// FunctionInfoNameToFullNameMap calls [FunctionsAPI.ListAll] and creates a map of results with [FunctionInfo].Name as key and [FunctionInfo].FullName as value.
	//
	// Returns an error if there's more than one [FunctionInfo] with the same .Name.
	//
	// Note: All [FunctionInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	FunctionInfoNameToFullNameMap(ctx context.Context, request ListFunctionsRequest) (map[string]string, error)

	// Updates the function that matches the supplied name. Only the owner of the
	// function can be updated. If the user is not a metastore admin, the user must
	// be a member of the group that is the new function owner. - Is a metastore
	// admin - Is the owner of the function's parent catalog - Is the owner of the
	// function's parent schema and has the **USE_CATALOG** privilege on its parent
	// catalog - Is the owner of the function itself and has the **USE_CATALOG**
	// privilege on its parent catalog as well as the **USE_SCHEMA** privilege on
	// the function's parent schema.
	Update(ctx context.Context, request UpdateFunction) (*FunctionInfo, error)
}

func NewFunctions(client *client.DatabricksClient) *FunctionsAPI {
	return &FunctionsAPI{
		functionsImpl: functionsImpl{
			client: client,
		},
	}
}

// Functions implement User-Defined Functions (UDFs) in Unity Catalog.
//
// The function implementation can be any SQL expression or Query, and it can be
// invoked wherever a table reference is allowed in a query. In Unity Catalog, a
// function resides at the same level as a table, so it can be referenced with
// the form __catalog_name__.__schema_name__.__function_name__.
type FunctionsAPI struct {
	functionsImpl
}

// Deletes the function that matches the supplied name. For the deletion to
// succeed, the user must satisfy one of the following conditions: - Is the
// owner of the function's parent catalog - Is the owner of the function's
// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
// Is the owner of the function itself and have both the **USE_CATALOG**
// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
// parent schema
func (a *FunctionsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.functionsImpl.Delete(ctx, DeleteFunctionRequest{
		Name: name,
	})
}

// Gets a function from within a parent catalog and schema. For the fetch to
// succeed, the user must satisfy one of the following requirements: - Is a
// metastore admin - Is an owner of the function's parent catalog - Have the
// **USE_CATALOG** privilege on the function's parent catalog and be the owner
// of the function - Have the **USE_CATALOG** privilege on the function's parent
// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
// the **EXECUTE** privilege on the function itself
func (a *FunctionsAPI) GetByName(ctx context.Context, name string) (*FunctionInfo, error) {
	return a.functionsImpl.Get(ctx, GetFunctionRequest{
		Name: name,
	})
}

// FunctionInfoNameToFullNameMap calls [FunctionsAPI.ListAll] and creates a map of results with [FunctionInfo].Name as key and [FunctionInfo].FullName as value.
//
// Returns an error if there's more than one [FunctionInfo] with the same .Name.
//
// Note: All [FunctionInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *FunctionsAPI) FunctionInfoNameToFullNameMap(ctx context.Context, request ListFunctionsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

type GrantsInterface interface {

	// Gets the permissions for a securable. Does not include inherited permissions.
	Get(ctx context.Context, request GetGrantRequest) (*GetPermissionsResponse, error)

	// Gets the permissions for a securable. Does not include inherited permissions.
	GetBySecurableTypeAndFullName(ctx context.Context, securableType string, fullName string) (*GetPermissionsResponse, error)

	// Gets the effective permissions for a securable. Includes inherited
	// permissions from any parent securables.
	GetEffective(ctx context.Context, request GetEffectiveRequest) (*EffectivePermissionsList, error)

	// Gets the effective permissions for a securable. Includes inherited
	// permissions from any parent securables.
	GetEffectiveBySecurableTypeAndFullName(ctx context.Context, securableType string, fullName string) (*EffectivePermissionsList, error)

	// Updates the permissions for a securable.
	Update(ctx context.Context, request UpdatePermissions) (*UpdatePermissionsResponse, error)
}

func NewGrants(client *client.DatabricksClient) *GrantsAPI {
	return &GrantsAPI{
		grantsImpl: grantsImpl{
			client: client,
		},
	}
}

// In Unity Catalog, data is secure by default. Initially, users have no access
// to data in a metastore. Access can be granted by either a metastore admin,
// the owner of an object, or the owner of the catalog or schema that contains
// the object. Securable objects in Unity Catalog are hierarchical and
// privileges are inherited downward.
//
// Securable objects in Unity Catalog are hierarchical and privileges are
// inherited downward. This means that granting a privilege on the catalog
// automatically grants the privilege to all current and future objects within
// the catalog. Similarly, privileges granted on a schema are inherited by all
// current and future objects within that schema.
type GrantsAPI struct {
	grantsImpl
}

// Gets the permissions for a securable. Does not include inherited permissions.
func (a *GrantsAPI) GetBySecurableTypeAndFullName(ctx context.Context, securableType string, fullName string) (*GetPermissionsResponse, error) {
	return a.grantsImpl.Get(ctx, GetGrantRequest{
		SecurableType: securableType,
		FullName:      fullName,
	})
}

// Gets the effective permissions for a securable. Includes inherited
// permissions from any parent securables.
func (a *GrantsAPI) GetEffectiveBySecurableTypeAndFullName(ctx context.Context, securableType string, fullName string) (*EffectivePermissionsList, error) {
	return a.grantsImpl.GetEffective(ctx, GetEffectiveRequest{
		SecurableType: securableType,
		FullName:      fullName,
	})
}

type MetastoresInterface interface {

	// Creates a new metastore assignment. If an assignment for the same
	// __workspace_id__ exists, it will be overwritten by the new __metastore_id__
	// and __default_catalog_name__. The caller must be an account admin.
	Assign(ctx context.Context, request CreateMetastoreAssignment) error

	// Creates a new metastore based on a provided name and optional storage root
	// path. By default (if the __owner__ field is not set), the owner of the new
	// metastore is the user calling the __createMetastore__ API. If the __owner__
	// field is set to the empty string (**""**), the ownership is assigned to the
	// System User instead.
	Create(ctx context.Context, request CreateMetastore) (*MetastoreInfo, error)

	// Gets the metastore assignment for the workspace being accessed.
	Current(ctx context.Context) (*MetastoreAssignment, error)

	// Deletes a metastore. The caller must be a metastore admin.
	Delete(ctx context.Context, request DeleteMetastoreRequest) error

	// Deletes a metastore. The caller must be a metastore admin.
	DeleteById(ctx context.Context, id string) error

	// Gets a metastore that matches the supplied ID. The caller must be a metastore
	// admin to retrieve this info.
	Get(ctx context.Context, request GetMetastoreRequest) (*MetastoreInfo, error)

	// Gets a metastore that matches the supplied ID. The caller must be a metastore
	// admin to retrieve this info.
	GetById(ctx context.Context, id string) (*MetastoreInfo, error)

	// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
	// caller must be an admin to retrieve this info. There is no guarantee of a
	// specific ordering of the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListMetastoresRequest) listing.Iterator[MetastoreInfo]

	// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
	// caller must be an admin to retrieve this info. There is no guarantee of a
	// specific ordering of the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListMetastoresRequest) ([]MetastoreInfo, error)

	// Gets information about a metastore. This summary includes the storage
	// credential, the cloud vendor, the cloud region, and the global metastore ID.
	Summary(ctx context.Context) (*GetMetastoreSummaryResponse, error)

	// Deletes a metastore assignment. The caller must be an account administrator.
	Unassign(ctx context.Context, request UnassignRequest) error

	// Deletes a metastore assignment. The caller must be an account administrator.
	UnassignByWorkspaceId(ctx context.Context, workspaceId int64) error

	// Updates information for a specific metastore. The caller must be a metastore
	// admin. If the __owner__ field is set to the empty string (**""**), the
	// ownership is updated to the System User.
	Update(ctx context.Context, request UpdateMetastore) (*MetastoreInfo, error)

	// Updates a metastore assignment. This operation can be used to update
	// __metastore_id__ or __default_catalog_name__ for a specified Workspace, if
	// the Workspace is already assigned a metastore. The caller must be an account
	// admin to update __metastore_id__; otherwise, the caller can be a Workspace
	// admin.
	UpdateAssignment(ctx context.Context, request UpdateMetastoreAssignment) error
}

func NewMetastores(client *client.DatabricksClient) *MetastoresAPI {
	return &MetastoresAPI{
		metastoresImpl: metastoresImpl{
			client: client,
		},
	}
}

// A metastore is the top-level container of objects in Unity Catalog. It stores
// data assets (tables and views) and the permissions that govern access to
// them. Databricks account admins can create metastores and assign them to
// Databricks workspaces to control which workloads use each metastore. For a
// workspace to use Unity Catalog, it must have a Unity Catalog metastore
// attached.
//
// Each metastore is configured with a root storage location in a cloud storage
// account. This storage location is used for metadata and managed tables data.
//
// NOTE: This metastore is distinct from the metastore included in Databricks
// workspaces created before Unity Catalog was released. If your workspace
// includes a legacy Hive metastore, the data in that metastore is available in
// a catalog named hive_metastore.
type MetastoresAPI struct {
	metastoresImpl
}

// Deletes a metastore. The caller must be a metastore admin.
func (a *MetastoresAPI) DeleteById(ctx context.Context, id string) error {
	return a.metastoresImpl.Delete(ctx, DeleteMetastoreRequest{
		Id: id,
	})
}

// Gets a metastore that matches the supplied ID. The caller must be a metastore
// admin to retrieve this info.
func (a *MetastoresAPI) GetById(ctx context.Context, id string) (*MetastoreInfo, error) {
	return a.metastoresImpl.Get(ctx, GetMetastoreRequest{
		Id: id,
	})
}

// Deletes a metastore assignment. The caller must be an account administrator.
func (a *MetastoresAPI) UnassignByWorkspaceId(ctx context.Context, workspaceId int64) error {
	return a.metastoresImpl.Unassign(ctx, UnassignRequest{
		WorkspaceId: workspaceId,
	})
}

type ModelVersionsInterface interface {

	// Deletes a model version from the specified registered model. Any aliases
	// assigned to the model version will also be deleted.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Delete(ctx context.Context, request DeleteModelVersionRequest) error

	// Deletes a model version from the specified registered model. Any aliases
	// assigned to the model version will also be deleted.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteByFullNameAndVersion(ctx context.Context, fullName string, version int) error

	// Get a model version.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the parent registered model. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema.
	Get(ctx context.Context, request GetModelVersionRequest) (*ModelVersionInfo, error)

	// Get a model version.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the parent registered model. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema.
	GetByFullNameAndVersion(ctx context.Context, fullName string, version int) (*ModelVersionInfo, error)

	// Get a model version by alias.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByAlias(ctx context.Context, request GetByAliasRequest) (*ModelVersionInfo, error)

	// Get a model version by alias.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) (*ModelVersionInfo, error)

	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	// The elements in the response will not contain any aliases or tags.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListModelVersionsRequest) listing.Iterator[ModelVersionInfo]

	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	// The elements in the response will not contain any aliases or tags.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListModelVersionsRequest) ([]ModelVersionInfo, error)

	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	// The elements in the response will not contain any aliases or tags.
	ListByFullName(ctx context.Context, fullName string) (*ListModelVersionsResponse, error)

	// Updates the specified model version.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// Currently only the comment of the model version can be updated.
	Update(ctx context.Context, request UpdateModelVersionRequest) (*ModelVersionInfo, error)
}

func NewModelVersions(client *client.DatabricksClient) *ModelVersionsAPI {
	return &ModelVersionsAPI{
		modelVersionsImpl: modelVersionsImpl{
			client: client,
		},
	}
}

// Databricks provides a hosted version of MLflow Model Registry in Unity
// Catalog. Models in Unity Catalog provide centralized access control,
// auditing, lineage, and discovery of ML models across Databricks workspaces.
//
// This API reference documents the REST endpoints for managing model versions
// in Unity Catalog. For more details, see the [registered models API
// docs](/api/workspace/registeredmodels).
type ModelVersionsAPI struct {
	modelVersionsImpl
}

// Deletes a model version from the specified registered model. Any aliases
// assigned to the model version will also be deleted.
//
// The caller must be a metastore admin or an owner of the parent registered
// model. For the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *ModelVersionsAPI) DeleteByFullNameAndVersion(ctx context.Context, fullName string, version int) error {
	return a.modelVersionsImpl.Delete(ctx, DeleteModelVersionRequest{
		FullName: fullName,
		Version:  version,
	})
}

// Get a model version.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the parent registered model. For the latter case, the caller
// must also be the owner or have the **USE_CATALOG** privilege on the parent
// catalog and the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) GetByFullNameAndVersion(ctx context.Context, fullName string, version int) (*ModelVersionInfo, error) {
	return a.modelVersionsImpl.Get(ctx, GetModelVersionRequest{
		FullName: fullName,
		Version:  version,
	})
}

// Get a model version by alias.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) GetByAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) (*ModelVersionInfo, error) {
	return a.modelVersionsImpl.GetByAlias(ctx, GetByAliasRequest{
		FullName: fullName,
		Alias:    alias,
	})
}

// List model versions. You can list model versions under a particular schema,
// or list all model versions in the current metastore.
//
// The returned models are filtered based on the privileges of the calling user.
// For example, the metastore admin is able to list all the model versions. A
// regular user needs to be the owner or have the **EXECUTE** privilege on the
// parent registered model to recieve the model versions in the response. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
//
// There is no guarantee of a specific ordering of the elements in the response.
// The elements in the response will not contain any aliases or tags.
func (a *ModelVersionsAPI) ListByFullName(ctx context.Context, fullName string) (*ListModelVersionsResponse, error) {
	return a.modelVersionsImpl.internalList(ctx, ListModelVersionsRequest{
		FullName: fullName,
	})
}

type OnlineTablesInterface interface {

	// WaitGetOnlineTableActive repeatedly calls [OnlineTablesAPI.Get] and waits to reach ACTIVE state
	WaitGetOnlineTableActive(ctx context.Context, name string,
		timeout time.Duration, callback func(*OnlineTable)) (*OnlineTable, error)

	// Create a new Online Table.
	Create(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest) (*WaitGetOnlineTableActive[OnlineTable], error)

	// Calls [OnlineTablesAPIInterface.Create] and waits to reach ACTIVE state
	//
	// You can override the default timeout of 20 minutes by calling adding
	// retries.Timeout[OnlineTable](60*time.Minute) functional option.
	//
	// Deprecated: use [OnlineTablesAPIInterface.Create].Get() or [OnlineTablesAPIInterface.WaitGetOnlineTableActive]
	CreateAndWait(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest, options ...retries.Option[OnlineTable]) (*OnlineTable, error)

	// Delete an online table. Warning: This will delete all the data in the online
	// table. If the source Delta table was deleted or modified since this Online
	// Table was created, this will lose the data forever!
	Delete(ctx context.Context, request DeleteOnlineTableRequest) error

	// Delete an online table. Warning: This will delete all the data in the online
	// table. If the source Delta table was deleted or modified since this Online
	// Table was created, this will lose the data forever!
	DeleteByName(ctx context.Context, name string) error

	// Get information about an existing online table and its status.
	Get(ctx context.Context, request GetOnlineTableRequest) (*OnlineTable, error)

	// Get information about an existing online table and its status.
	GetByName(ctx context.Context, name string) (*OnlineTable, error)
}

func NewOnlineTables(client *client.DatabricksClient) *OnlineTablesAPI {
	return &OnlineTablesAPI{
		onlineTablesImpl: onlineTablesImpl{
			client: client,
		},
	}
}

// Online tables provide lower latency and higher QPS access to data from Delta
// tables.
type OnlineTablesAPI struct {
	onlineTablesImpl
}

// WaitGetOnlineTableActive repeatedly calls [OnlineTablesAPI.Get] and waits to reach ACTIVE state
func (a *OnlineTablesAPI) WaitGetOnlineTableActive(ctx context.Context, name string,
	timeout time.Duration, callback func(*OnlineTable)) (*OnlineTable, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "long-running")
	return retries.Poll[OnlineTable](ctx, timeout, func() (*OnlineTable, *retries.Err) {
		onlineTable, err := a.Get(ctx, GetOnlineTableRequest{
			Name: name,
		})
		if err != nil {
			return nil, retries.Halt(err)
		}
		if callback != nil {
			callback(onlineTable)
		}
		status := onlineTable.UnityCatalogProvisioningState
		statusMessage := fmt.Sprintf("current status: %s", status)
		switch status {
		case ProvisioningInfoStateActive: // target state
			return onlineTable, nil
		case ProvisioningInfoStateFailed:
			err := fmt.Errorf("failed to reach %s, got %s: %s",
				ProvisioningInfoStateActive, status, statusMessage)
			return nil, retries.Halt(err)
		default:
			return nil, retries.Continues(statusMessage)
		}
	})
}

// WaitGetOnlineTableActive is a wrapper that calls [OnlineTablesAPI.WaitGetOnlineTableActive] and waits to reach ACTIVE state.
type WaitGetOnlineTableActive[R any] struct {
	Response *R
	Name     string `json:"name"`
	Poll     func(time.Duration, func(*OnlineTable)) (*OnlineTable, error)
	callback func(*OnlineTable)
	timeout  time.Duration
}

// OnProgress invokes a callback every time it polls for the status update.
func (w *WaitGetOnlineTableActive[R]) OnProgress(callback func(*OnlineTable)) *WaitGetOnlineTableActive[R] {
	w.callback = callback
	return w
}

// Get the OnlineTable with the default timeout of 20 minutes.
func (w *WaitGetOnlineTableActive[R]) Get() (*OnlineTable, error) {
	return w.Poll(w.timeout, w.callback)
}

// Get the OnlineTable with custom timeout.
func (w *WaitGetOnlineTableActive[R]) GetWithTimeout(timeout time.Duration) (*OnlineTable, error) {
	return w.Poll(timeout, w.callback)
}

// Create a new Online Table.
func (a *OnlineTablesAPI) Create(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest) (*WaitGetOnlineTableActive[OnlineTable], error) {
	onlineTable, err := a.onlineTablesImpl.Create(ctx, createOnlineTableRequest)
	if err != nil {
		return nil, err
	}
	return &WaitGetOnlineTableActive[OnlineTable]{
		Response: onlineTable,
		Name:     onlineTable.Name,
		Poll: func(timeout time.Duration, callback func(*OnlineTable)) (*OnlineTable, error) {
			return a.WaitGetOnlineTableActive(ctx, onlineTable.Name, timeout, callback)
		},
		timeout:  20 * time.Minute,
		callback: nil,
	}, nil
}

// Calls [OnlineTablesAPI.Create] and waits to reach ACTIVE state
//
// You can override the default timeout of 20 minutes by calling adding
// retries.Timeout[OnlineTable](60*time.Minute) functional option.
//
// Deprecated: use [OnlineTablesAPI.Create].Get() or [OnlineTablesAPI.WaitGetOnlineTableActive]
func (a *OnlineTablesAPI) CreateAndWait(ctx context.Context, createOnlineTableRequest CreateOnlineTableRequest, options ...retries.Option[OnlineTable]) (*OnlineTable, error) {
	wait, err := a.Create(ctx, createOnlineTableRequest)
	if err != nil {
		return nil, err
	}
	tmp := &retries.Info[OnlineTable]{Timeout: 20 * time.Minute}
	for _, o := range options {
		o(tmp)
	}
	wait.timeout = tmp.Timeout
	wait.callback = func(info *OnlineTable) {
		for _, o := range options {
			o(&retries.Info[OnlineTable]{
				Info:    info,
				Timeout: wait.timeout,
			})
		}
	}
	return wait.Get()
}

// Delete an online table. Warning: This will delete all the data in the online
// table. If the source Delta table was deleted or modified since this Online
// Table was created, this will lose the data forever!
func (a *OnlineTablesAPI) DeleteByName(ctx context.Context, name string) error {
	return a.onlineTablesImpl.Delete(ctx, DeleteOnlineTableRequest{
		Name: name,
	})
}

// Get information about an existing online table and its status.
func (a *OnlineTablesAPI) GetByName(ctx context.Context, name string) (*OnlineTable, error) {
	return a.onlineTablesImpl.Get(ctx, GetOnlineTableRequest{
		Name: name,
	})
}

type PoliciesInterface interface {

	// Creates a new policy on a securable. The new policy applies to the securable
	// and all its descendants.
	CreatePolicy(ctx context.Context, request CreatePolicyRequest) (*PolicyInfo, error)

	// Delete an ABAC policy defined on a securable.
	DeletePolicy(ctx context.Context, request DeletePolicyRequest) (*DeletePolicyResponse, error)

	// Get the policy definition on a securable
	GetPolicy(ctx context.Context, request GetPolicyRequest) (*PolicyInfo, error)

	// List all policies defined on a securable. Optionally, the list can include
	// inherited policies defined on the securable's parent schema or catalog.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPolicies(ctx context.Context, request ListPoliciesRequest) listing.Iterator[PolicyInfo]

	// List all policies defined on a securable. Optionally, the list can include
	// inherited policies defined on the securable's parent schema or catalog.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListPoliciesAll(ctx context.Context, request ListPoliciesRequest) ([]PolicyInfo, error)

	// Update an ABAC policy on a securable.
	UpdatePolicy(ctx context.Context, request UpdatePolicyRequest) (*PolicyInfo, error)
}

func NewPolicies(client *client.DatabricksClient) *PoliciesAPI {
	return &PoliciesAPI{
		policiesImpl: policiesImpl{
			client: client,
		},
	}
}

// Attribute-Based Access Control (ABAC) provides high leverage governance for
// enforcing compliance policies in Unity Catalog. With ABAC policies, access is
// controlled in a hierarchical and scalable manner, based on data attributes
// rather than specific resources, enabling more flexible and comprehensive
// access control. ABAC policies in Unity Catalog support conditions on
// securable properties, governance tags, and environment contexts. Callers must
// have the `MANAGE` privilege on a securable to view, create, update, or delete
// ABAC policies.
type PoliciesAPI struct {
	policiesImpl
}

type QualityMonitorsInterface interface {

	// Cancels an already-initiated refresh job.
	CancelRefresh(ctx context.Context, request CancelRefreshRequest) error

	// Creates a new monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog, have
	// **USE_SCHEMA** on the table's parent schema, and have **SELECT** access on
	// the table 2. have **USE_CATALOG** on the table's parent catalog, be an owner
	// of the table's parent schema, and have **SELECT** access on the table. 3.
	// have the following permissions: - **USE_CATALOG** on the table's parent
	// catalog - **USE_SCHEMA** on the table's parent schema - be an owner of the
	// table.
	//
	// Workspace assets, such as the dashboard, will be created in the workspace
	// where this call was made.
	Create(ctx context.Context, request CreateMonitor) (*MonitorInfo, error)

	// Deletes a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	//
	// Note that the metric tables and dashboard will not be deleted as part of this
	// call; those assets must be manually cleaned up (if desired).
	Delete(ctx context.Context, request DeleteQualityMonitorRequest) (*DeleteMonitorResponse, error)

	// Gets a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// The returned information includes configuration values, as well as
	// information on assets created by the monitor. Some information (e.g.,
	// dashboard) may be filtered out if the caller is in a different workspace than
	// where the monitor was created.
	Get(ctx context.Context, request GetQualityMonitorRequest) (*MonitorInfo, error)

	// Gets info about a specific monitor refresh using the given refresh ID.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	GetRefresh(ctx context.Context, request GetRefreshRequest) (*MonitorRefreshInfo, error)

	// Gets an array containing the history of the most recent refreshes (up to 25)
	// for this table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	ListRefreshes(ctx context.Context, request ListRefreshesRequest) (*MonitorRefreshListResponse, error)

	// Regenerates the monitoring dashboard for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table
	//
	// The call must be made from the workspace where the monitor was created. The
	// dashboard will be regenerated in the assets directory that was specified when
	// the monitor was created.
	RegenerateDashboard(ctx context.Context, request RegenerateDashboardRequest) (*RegenerateDashboardResponse, error)

	// Queues a metric refresh on the monitor for the specified table. The refresh
	// will execute in the background.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	RunRefresh(ctx context.Context, request RunRefreshRequest) (*MonitorRefreshInfo, error)

	// Updates a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created, and the caller must be the original creator of the monitor.
	//
	// Certain configuration fields, such as output asset identifiers, cannot be
	// updated.
	Update(ctx context.Context, request UpdateMonitor) (*MonitorInfo, error)
}

func NewQualityMonitors(client *client.DatabricksClient) *QualityMonitorsAPI {
	return &QualityMonitorsAPI{
		qualityMonitorsImpl: qualityMonitorsImpl{
			client: client,
		},
	}
}

// A monitor computes and monitors data or model quality metrics for a table
// over time. It generates metrics tables and a dashboard that you can use to
// monitor table health and set alerts. Most write operations require the user
// to be the owner of the table (or its parent schema or parent catalog).
// Viewing the dashboard, computed metrics, or monitor configuration only
// requires the user to have **SELECT** privileges on the table (along with
// **USE_SCHEMA** and **USE_CATALOG**).
type QualityMonitorsAPI struct {
	qualityMonitorsImpl
}

type RegisteredModelsInterface interface {

	// Creates a new registered model in Unity Catalog.
	//
	// File storage for model versions in the registered model will be located in
	// the default location which is specified by the parent schema, or the parent
	// catalog, or the Metastore.
	//
	// For registered model creation to succeed, the user must satisfy the following
	// conditions: - The caller must be a metastore admin, or be the owner of the
	// parent catalog and schema, or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
	// caller must have the **CREATE MODEL** or **CREATE FUNCTION** privilege on the
	// parent schema.
	Create(ctx context.Context, request CreateRegisteredModelRequest) (*RegisteredModelInfo, error)

	// Deletes a registered model and all its model versions from the specified
	// parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Delete(ctx context.Context, request DeleteRegisteredModelRequest) error

	// Deletes a registered model and all its model versions from the specified
	// parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Deletes a registered model alias.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteAlias(ctx context.Context, request DeleteAliasRequest) error

	// Deletes a registered model alias.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) error

	// Get a registered model.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	Get(ctx context.Context, request GetRegisteredModelRequest) (*RegisteredModelInfo, error)

	// Get a registered model.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByFullName(ctx context.Context, fullName string) (*RegisteredModelInfo, error)

	// List registered models. You can list registered models under a particular
	// schema, or list all registered models in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the registered models. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// registered model to recieve the registered models in the response. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListRegisteredModelsRequest) listing.Iterator[RegisteredModelInfo]

	// List registered models. You can list registered models under a particular
	// schema, or list all registered models in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the registered models. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// registered model to recieve the registered models in the response. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListRegisteredModelsRequest) ([]RegisteredModelInfo, error)

	// RegisteredModelInfoNameToFullNameMap calls [RegisteredModelsAPI.ListAll] and creates a map of results with [RegisteredModelInfo].Name as key and [RegisteredModelInfo].FullName as value.
	//
	// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
	//
	// Note: All [RegisteredModelInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	RegisteredModelInfoNameToFullNameMap(ctx context.Context, request ListRegisteredModelsRequest) (map[string]string, error)

	// GetByName calls [RegisteredModelsAPI.RegisteredModelInfoNameToFullNameMap] and returns a single [RegisteredModelInfo].
	//
	// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
	//
	// Note: All [RegisteredModelInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*RegisteredModelInfo, error)

	// Set an alias on the specified registered model.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	SetAlias(ctx context.Context, request SetRegisteredModelAliasRequest) (*RegisteredModelAlias, error)

	// Updates the specified registered model.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// Currently only the name, the owner or the comment of the registered model can
	// be updated.
	Update(ctx context.Context, request UpdateRegisteredModelRequest) (*RegisteredModelInfo, error)
}

func NewRegisteredModels(client *client.DatabricksClient) *RegisteredModelsAPI {
	return &RegisteredModelsAPI{
		registeredModelsImpl: registeredModelsImpl{
			client: client,
		},
	}
}

// Databricks provides a hosted version of MLflow Model Registry in Unity
// Catalog. Models in Unity Catalog provide centralized access control,
// auditing, lineage, and discovery of ML models across Databricks workspaces.
//
// An MLflow registered model resides in the third layer of Unity Catalog’s
// three-level namespace. Registered models contain model versions, which
// correspond to actual ML models (MLflow models). Creating new model versions
// currently requires use of the MLflow Python client. Once model versions are
// created, you can load them for batch inference using MLflow Python client
// APIs, or deploy them for real-time serving using Databricks Model Serving.
//
// All operations on registered models and model versions require USE_CATALOG
// permissions on the enclosing catalog and USE_SCHEMA permissions on the
// enclosing schema. In addition, the following additional privileges are
// required for various operations:
//
// * To create a registered model, users must additionally have the CREATE_MODEL
// permission on the target schema. * To view registered model or model version
// metadata, model version data files, or invoke a model version, users must
// additionally have the EXECUTE permission on the registered model * To update
// registered model or model version tags, users must additionally have APPLY
// TAG permissions on the registered model * To update other registered model or
// model version metadata (comments, aliases) create a new model version, or
// update permissions on the registered model, users must be owners of the
// registered model.
//
// Note: The securable type for models is FUNCTION. When using REST APIs (e.g.
// tagging, grants) that specify a securable type, use FUNCTION as the securable
// type.
type RegisteredModelsAPI struct {
	registeredModelsImpl
}

// Deletes a registered model and all its model versions from the specified
// parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.registeredModelsImpl.Delete(ctx, DeleteRegisteredModelRequest{
		FullName: fullName,
	})
}

// Deletes a registered model alias.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) DeleteAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) error {
	return a.registeredModelsImpl.DeleteAlias(ctx, DeleteAliasRequest{
		FullName: fullName,
		Alias:    alias,
	})
}

// Get a registered model.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *RegisteredModelsAPI) GetByFullName(ctx context.Context, fullName string) (*RegisteredModelInfo, error) {
	return a.registeredModelsImpl.Get(ctx, GetRegisteredModelRequest{
		FullName: fullName,
	})
}

// RegisteredModelInfoNameToFullNameMap calls [RegisteredModelsAPI.ListAll] and creates a map of results with [RegisteredModelInfo].Name as key and [RegisteredModelInfo].FullName as value.
//
// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
//
// Note: All [RegisteredModelInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) RegisteredModelInfoNameToFullNameMap(ctx context.Context, request ListRegisteredModelsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

// GetByName calls [RegisteredModelsAPI.RegisteredModelInfoNameToFullNameMap] and returns a single [RegisteredModelInfo].
//
// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
//
// Note: All [RegisteredModelInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) GetByName(ctx context.Context, name string) (*RegisteredModelInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListRegisteredModelsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]RegisteredModelInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("RegisteredModelInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of RegisteredModelInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

type ResourceQuotasInterface interface {

	// The GetQuota API returns usage information for a single resource quota,
	// defined as a child-parent pair. This API also refreshes the quota count if it
	// is out of date. Refreshes are triggered asynchronously. The updated count
	// might not be returned in the first call.
	GetQuota(ctx context.Context, request GetQuotaRequest) (*GetQuotaResponse, error)

	// ListQuotas returns all quota values under the metastore. There are no SLAs on
	// the freshness of the counts returned. This API does not trigger a refresh of
	// quota counts.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListQuotas(ctx context.Context, request ListQuotasRequest) listing.Iterator[QuotaInfo]

	// ListQuotas returns all quota values under the metastore. There are no SLAs on
	// the freshness of the counts returned. This API does not trigger a refresh of
	// quota counts.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListQuotasAll(ctx context.Context, request ListQuotasRequest) ([]QuotaInfo, error)
}

func NewResourceQuotas(client *client.DatabricksClient) *ResourceQuotasAPI {
	return &ResourceQuotasAPI{
		resourceQuotasImpl: resourceQuotasImpl{
			client: client,
		},
	}
}

// Unity Catalog enforces resource quotas on all securable objects, which limits
// the number of resources that can be created. Quotas are expressed in terms of
// a resource type and a parent (for example, tables per metastore or schemas
// per catalog). The resource quota APIs enable you to monitor your current
// usage and limits. For more information on resource quotas see the [Unity
// Catalog documentation].
//
// [Unity Catalog documentation]: https://docs.databricks.com/en/data-governance/unity-catalog/index.html#resource-quotas
type ResourceQuotasAPI struct {
	resourceQuotasImpl
}

type RfaInterface interface {

	// Creates access requests for Unity Catalog permissions for a specified
	// principal on a securable object. This Batch API can take in multiple
	// principals, securable objects, and permissions as the input and returns the
	// access request destinations for each. Principals must be unique across the
	// API call.
	//
	// The supported securable types are: "metastore", "catalog", "schema", "table",
	// "external_location", "connection", "credential", "function",
	// "registered_model", and "volume".
	BatchCreateAccessRequests(ctx context.Context, request BatchCreateAccessRequestsRequest) (*BatchCreateAccessRequestsResponse, error)

	// Gets an array of access request destinations for the specified securable. Any
	// caller can see URL destinations or the destinations on the metastore.
	// Otherwise, only those with **BROWSE** permissions on the securable can see
	// destinations.
	//
	// The supported securable types are: "metastore", "catalog", "schema", "table",
	// "external_location", "connection", "credential", "function",
	// "registered_model", and "volume".
	GetAccessRequestDestinations(ctx context.Context, request GetAccessRequestDestinationsRequest) (*AccessRequestDestinations, error)

	// Updates the access request destinations for the given securable. The caller
	// must be a metastore admin, the owner of the securable, or a user that has the
	// **MANAGE** privilege on the securable in order to assign destinations.
	// Destinations cannot be updated for securables underneath schemas (tables,
	// volumes, functions, and models). For these securable types, destinations are
	// inherited from the parent securable. A maximum of 5 emails and 5 external
	// notification destinations (Slack, Microsoft Teams, and Generic Webhook
	// destinations) can be assigned to a securable. If a URL destination is
	// assigned, no other destinations can be set.
	//
	// The supported securable types are: "metastore", "catalog", "schema", "table",
	// "external_location", "connection", "credential", "function",
	// "registered_model", and "volume".
	UpdateAccessRequestDestinations(ctx context.Context, request UpdateAccessRequestDestinationsRequest) (*AccessRequestDestinations, error)
}

func NewRfa(client *client.DatabricksClient) *RfaAPI {
	return &RfaAPI{
		rfaImpl: rfaImpl{
			client: client,
		},
	}
}

// Request for Access enables customers to request access to and manage access
// request destinations for Unity Catalog securables.
//
// These APIs provide a standardized way to update, get, and request to access
// request destinations. Fine-grained authorization ensures that only users with
// appropriate permissions can manage access request destinations.
type RfaAPI struct {
	rfaImpl
}

type SchemasInterface interface {

	// Creates a new schema for catalog in the Metastore. The caller must be a
	// metastore admin, or have the **CREATE_SCHEMA** privilege in the parent
	// catalog.
	Create(ctx context.Context, request CreateSchema) (*SchemaInfo, error)

	// Deletes the specified schema from the parent catalog. The caller must be the
	// owner of the schema or an owner of the parent catalog.
	Delete(ctx context.Context, request DeleteSchemaRequest) error

	// Deletes the specified schema from the parent catalog. The caller must be the
	// owner of the schema or an owner of the parent catalog.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Gets the specified schema within the metastore. The caller must be a
	// metastore admin, the owner of the schema, or a user that has the
	// **USE_SCHEMA** privilege on the schema.
	Get(ctx context.Context, request GetSchemaRequest) (*SchemaInfo, error)

	// Gets the specified schema within the metastore. The caller must be a
	// metastore admin, the owner of the schema, or a user that has the
	// **USE_SCHEMA** privilege on the schema.
	GetByFullName(ctx context.Context, fullName string) (*SchemaInfo, error)

	// Gets an array of schemas for a catalog in the metastore. If the caller is the
	// metastore admin or the owner of the parent catalog, all schemas for the
	// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
	// for which the caller has the **USE_SCHEMA** privilege) will be retrieved.
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListSchemasRequest) listing.Iterator[SchemaInfo]

	// Gets an array of schemas for a catalog in the metastore. If the caller is the
	// metastore admin or the owner of the parent catalog, all schemas for the
	// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
	// for which the caller has the **USE_SCHEMA** privilege) will be retrieved.
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListSchemasRequest) ([]SchemaInfo, error)

	// Updates a schema for a catalog. The caller must be the owner of the schema or
	// a metastore admin. If the caller is a metastore admin, only the __owner__
	// field can be changed in the update. If the __name__ field must be updated,
	// the caller must be a metastore admin or have the **CREATE_SCHEMA** privilege
	// on the parent catalog.
	Update(ctx context.Context, request UpdateSchema) (*SchemaInfo, error)
}

func NewSchemas(client *client.DatabricksClient) *SchemasAPI {
	return &SchemasAPI{
		schemasImpl: schemasImpl{
			client: client,
		},
	}
}

// A schema (also called a database) is the second layer of Unity Catalog’s
// three-level namespace. A schema organizes tables, views and functions. To
// access (or list) a table or view in a schema, users must have the USE_SCHEMA
// data permission on the schema and its parent catalog, and they must have the
// SELECT permission on the table or view.
type SchemasAPI struct {
	schemasImpl
}

// Deletes the specified schema from the parent catalog. The caller must be the
// owner of the schema or an owner of the parent catalog.
func (a *SchemasAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.schemasImpl.Delete(ctx, DeleteSchemaRequest{
		FullName: fullName,
	})
}

// Gets the specified schema within the metastore. The caller must be a
// metastore admin, the owner of the schema, or a user that has the
// **USE_SCHEMA** privilege on the schema.
func (a *SchemasAPI) GetByFullName(ctx context.Context, fullName string) (*SchemaInfo, error) {
	return a.schemasImpl.Get(ctx, GetSchemaRequest{
		FullName: fullName,
	})
}

type StorageCredentialsInterface interface {

	// Creates a new storage credential.
	//
	// The caller must be a metastore admin or have the
	// **CREATE_STORAGE_CREDENTIAL** privilege on the metastore.
	Create(ctx context.Context, request CreateStorageCredential) (*StorageCredentialInfo, error)

	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	Delete(ctx context.Context, request DeleteStorageCredentialRequest) error

	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	DeleteByName(ctx context.Context, name string) error

	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have some permission on the
	// storage credential.
	Get(ctx context.Context, request GetStorageCredentialRequest) (*StorageCredentialInfo, error)

	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have some permission on the
	// storage credential.
	GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error)

	// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
	// The array is limited to only those storage credentials the caller has
	// permission to access. If the caller is a metastore admin, retrieval of
	// credentials is unrestricted. There is no guarantee of a specific ordering of
	// the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListStorageCredentialsRequest) listing.Iterator[StorageCredentialInfo]

	// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
	// The array is limited to only those storage credentials the caller has
	// permission to access. If the caller is a metastore admin, retrieval of
	// credentials is unrestricted. There is no guarantee of a specific ordering of
	// the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListStorageCredentialsRequest) ([]StorageCredentialInfo, error)

	// Updates a storage credential on the metastore.
	//
	// The caller must be the owner of the storage credential or a metastore admin.
	// If the caller is a metastore admin, only the **owner** field can be changed.
	Update(ctx context.Context, request UpdateStorageCredential) (*StorageCredentialInfo, error)

	// Validates a storage credential. At least one of __external_location_name__
	// and __url__ need to be provided. If only one of them is provided, it will be
	// used for validation. And if both are provided, the __url__ will be used for
	// validation, and __external_location_name__ will be ignored when checking
	// overlapping urls.
	//
	// Either the __storage_credential_name__ or the cloud-specific credential must
	// be provided.
	//
	// The caller must be a metastore admin or the storage credential owner or have
	// the **CREATE_EXTERNAL_LOCATION** privilege on the metastore and the storage
	// credential.
	Validate(ctx context.Context, request ValidateStorageCredential) (*ValidateStorageCredentialResponse, error)
}

func NewStorageCredentials(client *client.DatabricksClient) *StorageCredentialsAPI {
	return &StorageCredentialsAPI{
		storageCredentialsImpl: storageCredentialsImpl{
			client: client,
		},
	}
}

// A storage credential represents an authentication and authorization mechanism
// for accessing data stored on your cloud tenant. Each storage credential is
// subject to Unity Catalog access-control policies that control which users and
// groups can access the credential. If a user does not have access to a storage
// credential in Unity Catalog, the request fails and Unity Catalog does not
// attempt to authenticate to your cloud tenant on the user’s behalf.
//
// Databricks recommends using external locations rather than using storage
// credentials directly.
//
// To create storage credentials, you must be a Databricks account admin. The
// account admin who creates the storage credential can delegate ownership to
// another user or group to manage permissions on it.
type StorageCredentialsAPI struct {
	storageCredentialsImpl
}

// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *StorageCredentialsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.storageCredentialsImpl.Delete(ctx, DeleteStorageCredentialRequest{
		Name: name,
	})
}

// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have some permission on the
// storage credential.
func (a *StorageCredentialsAPI) GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error) {
	return a.storageCredentialsImpl.Get(ctx, GetStorageCredentialRequest{
		Name: name,
	})
}

type SystemSchemasInterface interface {

	// Disables the system schema and removes it from the system catalog. The caller
	// must be an account admin or a metastore admin.
	Disable(ctx context.Context, request DisableRequest) error

	// Disables the system schema and removes it from the system catalog. The caller
	// must be an account admin or a metastore admin.
	DisableByMetastoreIdAndSchemaName(ctx context.Context, metastoreId string, schemaName string) error

	// Enables the system schema and adds it to the system catalog. The caller must
	// be an account admin or a metastore admin.
	Enable(ctx context.Context, request EnableRequest) error

	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListSystemSchemasRequest) listing.Iterator[SystemSchemaInfo]

	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListSystemSchemasRequest) ([]SystemSchemaInfo, error)

	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListSystemSchemasResponse, error)
}

func NewSystemSchemas(client *client.DatabricksClient) *SystemSchemasAPI {
	return &SystemSchemasAPI{
		systemSchemasImpl: systemSchemasImpl{
			client: client,
		},
	}
}

// A system schema is a schema that lives within the system catalog. A system
// schema may contain information about customer usage of Unity Catalog such as
// audit-logs, billing-logs, lineage information, etc.
type SystemSchemasAPI struct {
	systemSchemasImpl
}

// Disables the system schema and removes it from the system catalog. The caller
// must be an account admin or a metastore admin.
func (a *SystemSchemasAPI) DisableByMetastoreIdAndSchemaName(ctx context.Context, metastoreId string, schemaName string) error {
	return a.systemSchemasImpl.Disable(ctx, DisableRequest{
		MetastoreId: metastoreId,
		SchemaName:  schemaName,
	})
}

// Gets an array of system schemas for a metastore. The caller must be an
// account admin or a metastore admin.
//
// NOTE: we recommend using max_results=0 to use the paginated version of this
// API. Unpaginated calls will be deprecated soon.
//
// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
// contain zero results while still providing a next_page_token. Clients must
// continue reading pages until next_page_token is absent, which is the only
// indication that the end of results has been reached. This behavior follows
// Google AIP-158 guidelines.
func (a *SystemSchemasAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListSystemSchemasResponse, error) {
	return a.systemSchemasImpl.internalList(ctx, ListSystemSchemasRequest{
		MetastoreId: metastoreId,
	})
}

type TableConstraintsInterface interface {

	// Creates a new table constraint.
	//
	// For the table constraint creation to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if the new constraint is a
	// __ForeignKeyConstraint__, the user must have the **USE_CATALOG** privilege on
	// the referenced parent table's catalog, the **USE_SCHEMA** privilege on the
	// referenced parent table's schema, and be the owner of the referenced parent
	// table.
	Create(ctx context.Context, request CreateTableConstraint) (*TableConstraint, error)

	// Deletes a table constraint.
	//
	// For the table constraint deletion to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if __cascade__ argument is **true**,
	// the user must have the following permissions on all of the child tables: the
	// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
	// privilege on the table's schema, and be the owner of the table.
	Delete(ctx context.Context, request DeleteTableConstraintRequest) error

	// Deletes a table constraint.
	//
	// For the table constraint deletion to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if __cascade__ argument is **true**,
	// the user must have the following permissions on all of the child tables: the
	// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
	// privilege on the table's schema, and be the owner of the table.
	DeleteByFullName(ctx context.Context, fullName string) error
}

func NewTableConstraints(client *client.DatabricksClient) *TableConstraintsAPI {
	return &TableConstraintsAPI{
		tableConstraintsImpl: tableConstraintsImpl{
			client: client,
		},
	}
}

// Primary key and foreign key constraints encode relationships between fields
// in tables.
//
// Primary and foreign keys are informational only and are not enforced. Foreign
// keys must reference a primary key in another table. This primary key is the
// parent constraint of the foreign key and the table this primary key is on is
// the parent table of the foreign key. Similarly, the foreign key is the child
// constraint of its referenced primary key; the table of the foreign key is the
// child table of the primary key.
//
// You can declare primary keys and foreign keys as part of the table
// specification during table creation. You can also add or drop constraints on
// existing tables.
type TableConstraintsAPI struct {
	tableConstraintsImpl
}

// Deletes a table constraint.
//
// For the table constraint deletion to succeed, the user must satisfy both of
// these conditions: - the user must have the **USE_CATALOG** privilege on the
// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
// schema, and be the owner of the table. - if __cascade__ argument is **true**,
// the user must have the following permissions on all of the child tables: the
// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
// privilege on the table's schema, and be the owner of the table.
func (a *TableConstraintsAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.tableConstraintsImpl.Delete(ctx, DeleteTableConstraintRequest{
		FullName: fullName,
	})
}

type TablesInterface interface {

	// Creates a new table in the specified catalog and schema.
	//
	// To create an external delta table, the caller must have the
	// **EXTERNAL_USE_SCHEMA** privilege on the parent schema and the
	// **EXTERNAL_USE_LOCATION** privilege on the external location. These
	// privileges must always be granted explicitly, and cannot be inherited through
	// ownership or **ALL_PRIVILEGES**.
	//
	// Standard UC permissions needed to create tables still apply: **USE_CATALOG**
	// on the parent catalog (or ownership of the parent catalog), **CREATE_TABLE**
	// and **USE_SCHEMA** on the parent schema (or ownership of the parent schema),
	// and **CREATE_EXTERNAL_TABLE** on external location.
	//
	// The **columns** field needs to be in a Spark compatible format, so we
	// recommend you use Spark to create these tables. The API itself does not
	// validate the correctness of the column spec. If the spec is not Spark
	// compatible, the tables may not be readable by Databricks Runtime.
	//
	// NOTE: The Create Table API for external clients only supports creating
	// **external delta tables**. The values shown in the respective enums are all
	// values supported by Databricks, however for this specific Create Table API,
	// only **table_type** **EXTERNAL** and **data_source_format** **DELTA** are
	// supported. Additionally, column masks are not supported when creating tables
	// through this API.
	Create(ctx context.Context, request CreateTableRequest) (*TableInfo, error)

	// Deletes a table from the specified parent catalog and schema. The caller must
	// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
	// parent catalog and be the owner of the parent schema, or be the owner of the
	// table and have the **USE_CATALOG** privilege on the parent catalog and the
	// **USE_SCHEMA** privilege on the parent schema.
	Delete(ctx context.Context, request DeleteTableRequest) error

	// Deletes a table from the specified parent catalog and schema. The caller must
	// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
	// parent catalog and be the owner of the parent schema, or be the owner of the
	// table and have the **USE_CATALOG** privilege on the parent catalog and the
	// **USE_SCHEMA** privilege on the parent schema.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Gets if a table exists in the metastore for a specific catalog and schema.
	// The caller must satisfy one of the following requirements: * Be a metastore
	// admin * Be the owner of the parent catalog * Be the owner of the parent
	// schema and have the **USE_CATALOG** privilege on the parent catalog * Have
	// the **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// **SELECT** privilege on the table. * Have **BROWSE** privilege on the parent
	// catalog * Have **BROWSE** privilege on the parent schema
	Exists(ctx context.Context, request ExistsRequest) (*TableExistsResponse, error)

	// Gets if a table exists in the metastore for a specific catalog and schema.
	// The caller must satisfy one of the following requirements: * Be a metastore
	// admin * Be the owner of the parent catalog * Be the owner of the parent
	// schema and have the **USE_CATALOG** privilege on the parent catalog * Have
	// the **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// **SELECT** privilege on the table. * Have **BROWSE** privilege on the parent
	// catalog * Have **BROWSE** privilege on the parent schema
	ExistsByFullName(ctx context.Context, fullName string) (*TableExistsResponse, error)

	// Gets a table from the metastore for a specific catalog and schema. The caller
	// must satisfy one of the following requirements: * Be a metastore admin * Be
	// the owner of the parent catalog * Be the owner of the parent schema and have
	// the **USE_CATALOG** privilege on the parent catalog * Have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// **SELECT** privilege on the table.
	Get(ctx context.Context, request GetTableRequest) (*TableInfo, error)

	// Gets a table from the metastore for a specific catalog and schema. The caller
	// must satisfy one of the following requirements: * Be a metastore admin * Be
	// the owner of the parent catalog * Be the owner of the parent schema and have
	// the **USE_CATALOG** privilege on the parent catalog * Have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// **SELECT** privilege on the table.
	GetByFullName(ctx context.Context, fullName string) (*TableInfo, error)

	// Gets an array of all tables for the current metastore under the parent
	// catalog and schema. The caller must be a metastore admin or an owner of (or
	// have the **SELECT** privilege on) the table. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
	// guarantee of a specific ordering of the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListTablesRequest) listing.Iterator[TableInfo]

	// Gets an array of all tables for the current metastore under the parent
	// catalog and schema. The caller must be a metastore admin or an owner of (or
	// have the **SELECT** privilege on) the table. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
	// guarantee of a specific ordering of the elements in the array.
	//
	// NOTE: we recommend using max_results=0 to use the paginated version of this
	// API. Unpaginated calls will be deprecated soon.
	//
	// PAGINATION BEHAVIOR: When using pagination (max_results >= 0), a page may
	// contain zero results while still providing a next_page_token. Clients must
	// continue reading pages until next_page_token is absent, which is the only
	// indication that the end of results has been reached. This behavior follows
	// Google AIP-158 guidelines.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListTablesRequest) ([]TableInfo, error)

	// Gets an array of summaries for tables for a schema and catalog within the
	// metastore. The table summaries returned are either:
	//
	// * summaries for tables (within the current metastore and parent catalog and
	// schema), when the user is a metastore admin, or: * summaries for tables and
	// schemas (within the current metastore and parent catalog) for which the user
	// has ownership or the **SELECT** privilege on the table and ownership or
	// **USE_SCHEMA** privilege on the schema, provided that the user also has
	// ownership or the **USE_CATALOG** privilege on the parent catalog.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListSummaries(ctx context.Context, request ListSummariesRequest) listing.Iterator[TableSummary]

	// Gets an array of summaries for tables for a schema and catalog within the
	// metastore. The table summaries returned are either:
	//
	// * summaries for tables (within the current metastore and parent catalog and
	// schema), when the user is a metastore admin, or: * summaries for tables and
	// schemas (within the current metastore and parent catalog) for which the user
	// has ownership or the **SELECT** privilege on the table and ownership or
	// **USE_SCHEMA** privilege on the schema, provided that the user also has
	// ownership or the **USE_CATALOG** privilege on the parent catalog.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListSummariesAll(ctx context.Context, request ListSummariesRequest) ([]TableSummary, error)

	// Change the owner of the table. The caller must be the owner of the parent
	// catalog, have the **USE_CATALOG** privilege on the parent catalog and be the
	// owner of the parent schema, or be the owner of the table and have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Update(ctx context.Context, request UpdateTableRequest) error
}

func NewTables(client *client.DatabricksClient) *TablesAPI {
	return &TablesAPI{
		tablesImpl: tablesImpl{
			client: client,
		},
	}
}

// A table resides in the third layer of Unity Catalog’s three-level
// namespace. It contains rows of data. To create a table, users must have
// CREATE_TABLE and USE_SCHEMA permissions on the schema, and they must have the
// USE_CATALOG permission on its parent catalog. To query a table, users must
// have the SELECT permission on the table, and they must have the USE_CATALOG
// permission on its parent catalog and the USE_SCHEMA permission on its parent
// schema.
//
// A table can be managed or external. From an API perspective, a __VIEW__ is a
// particular kind of table (rather than a managed or external table).
type TablesAPI struct {
	tablesImpl
}

// Deletes a table from the specified parent catalog and schema. The caller must
// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
// parent catalog and be the owner of the parent schema, or be the owner of the
// table and have the **USE_CATALOG** privilege on the parent catalog and the
// **USE_SCHEMA** privilege on the parent schema.
func (a *TablesAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.tablesImpl.Delete(ctx, DeleteTableRequest{
		FullName: fullName,
	})
}

// Gets if a table exists in the metastore for a specific catalog and schema.
// The caller must satisfy one of the following requirements: * Be a metastore
// admin * Be the owner of the parent catalog * Be the owner of the parent
// schema and have the **USE_CATALOG** privilege on the parent catalog * Have
// the **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema, and either be the table owner or have the
// **SELECT** privilege on the table. * Have **BROWSE** privilege on the parent
// catalog * Have **BROWSE** privilege on the parent schema
func (a *TablesAPI) ExistsByFullName(ctx context.Context, fullName string) (*TableExistsResponse, error) {
	return a.tablesImpl.Exists(ctx, ExistsRequest{
		FullName: fullName,
	})
}

// Gets a table from the metastore for a specific catalog and schema. The caller
// must satisfy one of the following requirements: * Be a metastore admin * Be
// the owner of the parent catalog * Be the owner of the parent schema and have
// the **USE_CATALOG** privilege on the parent catalog * Have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema, and either be the table owner or have the
// **SELECT** privilege on the table.
func (a *TablesAPI) GetByFullName(ctx context.Context, fullName string) (*TableInfo, error) {
	return a.tablesImpl.Get(ctx, GetTableRequest{
		FullName: fullName,
	})
}

type TemporaryPathCredentialsInterface interface {

	// Get a short-lived credential for directly accessing cloud storage locations
	// registered in Databricks. The Generate Temporary Path Credentials API is only
	// supported for external storage paths, specifically external locations and
	// external tables. Managed tables are not supported by this API. The metastore
	// must have **external_access_enabled** flag set to true (default false). The
	// caller must have the **EXTERNAL_USE_LOCATION** privilege on the external
	// location; this privilege can only be granted by external location owners. For
	// requests on existing external tables, the caller must also have the
	// **EXTERNAL_USE_SCHEMA** privilege on the parent schema; this privilege can
	// only be granted by catalog owners.
	GenerateTemporaryPathCredentials(ctx context.Context, request GenerateTemporaryPathCredentialRequest) (*GenerateTemporaryPathCredentialResponse, error)
}

func NewTemporaryPathCredentials(client *client.DatabricksClient) *TemporaryPathCredentialsAPI {
	return &TemporaryPathCredentialsAPI{
		temporaryPathCredentialsImpl: temporaryPathCredentialsImpl{
			client: client,
		},
	}
}

// Temporary Path Credentials refer to short-lived, downscoped credentials used
// to access external cloud storage locations registered in Databricks. These
// credentials are employed to provide secure and time-limited access to data in
// cloud environments such as AWS, Azure, and Google Cloud. Each cloud provider
// has its own type of credentials: AWS uses temporary session tokens via AWS
// Security Token Service (STS), Azure utilizes Shared Access Signatures (SAS)
// for its data storage services, and Google Cloud supports temporary
// credentials through OAuth 2.0.
//
// Temporary path credentials ensure that data access is limited in scope and
// duration, reducing the risk of unauthorized access or misuse. To use the
// temporary path credentials API, a metastore admin needs to enable the
// external_access_enabled flag (off by default) at the metastore level. A user
// needs to be granted the EXTERNAL USE LOCATION permission by external location
// owner. For requests on existing external tables, user also needs to be
// granted the EXTERNAL USE SCHEMA permission at the schema level by catalog
// admin.
//
// Note that EXTERNAL USE SCHEMA is a schema level permission that can only be
// granted by catalog admin explicitly and is not included in schema ownership
// or ALL PRIVILEGES on the schema for security reasons. Similarly, EXTERNAL USE
// LOCATION is an external location level permission that can only be granted by
// external location owner explicitly and is not included in external location
// ownership or ALL PRIVILEGES on the external location for security reasons.
//
// This API only supports temporary path credentials for external locations and
// external tables, and volumes will be supported in the future.
type TemporaryPathCredentialsAPI struct {
	temporaryPathCredentialsImpl
}

type TemporaryTableCredentialsInterface interface {

	// Get a short-lived credential for directly accessing the table data on cloud
	// storage. The metastore must have **external_access_enabled** flag set to true
	// (default false). The caller must have the **EXTERNAL_USE_SCHEMA** privilege
	// on the parent schema and this privilege can only be granted by catalog
	// owners.
	GenerateTemporaryTableCredentials(ctx context.Context, request GenerateTemporaryTableCredentialRequest) (*GenerateTemporaryTableCredentialResponse, error)
}

func NewTemporaryTableCredentials(client *client.DatabricksClient) *TemporaryTableCredentialsAPI {
	return &TemporaryTableCredentialsAPI{
		temporaryTableCredentialsImpl: temporaryTableCredentialsImpl{
			client: client,
		},
	}
}

// Temporary Table Credentials refer to short-lived, downscoped credentials used
// to access cloud storage locations where table data is stored in Databricks.
// These credentials are employed to provide secure and time-limited access to
// data in cloud environments such as AWS, Azure, and Google Cloud. Each cloud
// provider has its own type of credentials: AWS uses temporary session tokens
// via AWS Security Token Service (STS), Azure utilizes Shared Access Signatures
// (SAS) for its data storage services, and Google Cloud supports temporary
// credentials through OAuth 2.0.
//
// Temporary table credentials ensure that data access is limited in scope and
// duration, reducing the risk of unauthorized access or misuse. To use the
// temporary table credentials API, a metastore admin needs to enable the
// external_access_enabled flag (off by default) at the metastore level, and
// user needs to be granted the EXTERNAL USE SCHEMA permission at the schema
// level by catalog admin. Note that EXTERNAL USE SCHEMA is a schema level
// permission that can only be granted by catalog admin explicitly and is not
// included in schema ownership or ALL PRIVILEGES on the schema for security
// reasons.
type TemporaryTableCredentialsAPI struct {
	temporaryTableCredentialsImpl
}

type VolumesInterface interface {

	// Creates a new volume.
	//
	// The user could create either an external volume or a managed volume. An
	// external volume will be created in the specified external location, while a
	// managed volume will be located in the default location which is specified by
	// the parent schema, or the parent catalog, or the Metastore.
	//
	// For the volume creation to succeed, the user must satisfy following
	// conditions: - The caller must be a metastore admin, or be the owner of the
	// parent catalog and schema, or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
	// caller must have **CREATE VOLUME** privilege on the parent schema.
	//
	// For an external volume, following conditions also need to satisfy - The
	// caller must have **CREATE EXTERNAL VOLUME** privilege on the external
	// location. - There are no other tables, nor volumes existing in the specified
	// storage location. - The specified storage location is not under the location
	// of other tables, nor volumes, or catalogs or schemas.
	Create(ctx context.Context, request CreateVolumeRequestContent) (*VolumeInfo, error)

	// Deletes a volume from the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	Delete(ctx context.Context, request DeleteVolumeRequest) error

	// Deletes a volume from the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	DeleteByName(ctx context.Context, name string) error

	// Gets an array of volumes for the current metastore under the parent catalog
	// and schema.
	//
	// The returned volumes are filtered based on the privileges of the calling
	// user. For example, the metastore admin is able to list all the volumes. A
	// regular user needs to be the owner or have the **READ VOLUME** privilege on
	// the volume to receive the volumes in the response. For the latter case, the
	// caller must also be the owner or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListVolumesRequest) listing.Iterator[VolumeInfo]

	// Gets an array of volumes for the current metastore under the parent catalog
	// and schema.
	//
	// The returned volumes are filtered based on the privileges of the calling
	// user. For example, the metastore admin is able to list all the volumes. A
	// regular user needs to be the owner or have the **READ VOLUME** privilege on
	// the volume to receive the volumes in the response. For the latter case, the
	// caller must also be the owner or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListVolumesRequest) ([]VolumeInfo, error)

	// VolumeInfoNameToVolumeIdMap calls [VolumesAPI.ListAll] and creates a map of results with [VolumeInfo].Name as key and [VolumeInfo].VolumeId as value.
	//
	// Returns an error if there's more than one [VolumeInfo] with the same .Name.
	//
	// Note: All [VolumeInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	VolumeInfoNameToVolumeIdMap(ctx context.Context, request ListVolumesRequest) (map[string]string, error)

	// GetByName calls [VolumesAPI.VolumeInfoNameToVolumeIdMap] and returns a single [VolumeInfo].
	//
	// Returns an error if there's more than one [VolumeInfo] with the same .Name.
	//
	// Note: All [VolumeInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*VolumeInfo, error)

	// Gets a volume from the metastore for a specific catalog and schema.
	//
	// The caller must be a metastore admin or an owner of (or have the **READ
	// VOLUME** privilege on) the volume. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	Read(ctx context.Context, request ReadVolumeRequest) (*VolumeInfo, error)

	// Gets a volume from the metastore for a specific catalog and schema.
	//
	// The caller must be a metastore admin or an owner of (or have the **READ
	// VOLUME** privilege on) the volume. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	ReadByName(ctx context.Context, name string) (*VolumeInfo, error)

	// Updates the specified volume under the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// Currently only the name, the owner or the comment of the volume could be
	// updated.
	Update(ctx context.Context, request UpdateVolumeRequestContent) (*VolumeInfo, error)
}

func NewVolumes(client *client.DatabricksClient) *VolumesAPI {
	return &VolumesAPI{
		volumesImpl: volumesImpl{
			client: client,
		},
	}
}

// Volumes are a Unity Catalog (UC) capability for accessing, storing,
// governing, organizing and processing files. Use cases include running machine
// learning on unstructured data such as image, audio, video, or PDF files,
// organizing data sets during the data exploration stages in data science,
// working with libraries that require access to the local file system on
// cluster machines, storing library and config files of arbitrary formats such
// as .whl or .txt centrally and providing secure access across workspaces to
// it, or transforming and querying non-tabular data files in ETL.
type VolumesAPI struct {
	volumesImpl
}

// Deletes a volume from the specified parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the volume. For the
// latter case, the caller must also be the owner or have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema.
func (a *VolumesAPI) DeleteByName(ctx context.Context, name string) error {
	return a.volumesImpl.Delete(ctx, DeleteVolumeRequest{
		Name: name,
	})
}

// VolumeInfoNameToVolumeIdMap calls [VolumesAPI.ListAll] and creates a map of results with [VolumeInfo].Name as key and [VolumeInfo].VolumeId as value.
//
// Returns an error if there's more than one [VolumeInfo] with the same .Name.
//
// Note: All [VolumeInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) VolumeInfoNameToVolumeIdMap(ctx context.Context, request ListVolumesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.VolumeId
	}
	return mapping, nil
}

// GetByName calls [VolumesAPI.VolumeInfoNameToVolumeIdMap] and returns a single [VolumeInfo].
//
// Returns an error if there's more than one [VolumeInfo] with the same .Name.
//
// Note: All [VolumeInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) GetByName(ctx context.Context, name string) (*VolumeInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListVolumesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]VolumeInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("VolumeInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of VolumeInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Gets a volume from the metastore for a specific catalog and schema.
//
// The caller must be a metastore admin or an owner of (or have the **READ
// VOLUME** privilege on) the volume. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *VolumesAPI) ReadByName(ctx context.Context, name string) (*VolumeInfo, error) {
	return a.volumesImpl.Read(ctx, ReadVolumeRequest{
		Name: name,
	})
}

type WorkspaceBindingsInterface interface {

	// Gets workspace bindings of the catalog. The caller must be a metastore admin
	// or an owner of the catalog.
	Get(ctx context.Context, request GetWorkspaceBindingRequest) (*GetCatalogWorkspaceBindingsResponse, error)

	// Gets workspace bindings of the catalog. The caller must be a metastore admin
	// or an owner of the catalog.
	GetByName(ctx context.Context, name string) (*GetCatalogWorkspaceBindingsResponse, error)

	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetBindings(ctx context.Context, request GetBindingsRequest) listing.Iterator[WorkspaceBinding]

	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetBindingsAll(ctx context.Context, request GetBindingsRequest) ([]WorkspaceBinding, error)

	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	GetBindingsBySecurableTypeAndSecurableName(ctx context.Context, securableType string, securableName string) (*GetWorkspaceBindingsResponse, error)

	// Updates workspace bindings of the catalog. The caller must be a metastore
	// admin or an owner of the catalog.
	Update(ctx context.Context, request UpdateWorkspaceBindings) (*UpdateCatalogWorkspaceBindingsResponse, error)

	// Updates workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	UpdateBindings(ctx context.Context, request UpdateWorkspaceBindingsParameters) (*UpdateWorkspaceBindingsResponse, error)
}

func NewWorkspaceBindings(client *client.DatabricksClient) *WorkspaceBindingsAPI {
	return &WorkspaceBindingsAPI{
		workspaceBindingsImpl: workspaceBindingsImpl{
			client: client,
		},
	}
}

// A securable in Databricks can be configured as __OPEN__ or __ISOLATED__. An
// __OPEN__ securable can be accessed from any workspace, while an __ISOLATED__
// securable can only be accessed from a configured list of workspaces. This API
// allows you to configure (bind) securables to workspaces.
//
// NOTE: The __isolation_mode__ is configured for the securable itself (using
// its Update method) and the workspace bindings are only consulted when the
// securable's __isolation_mode__ is set to __ISOLATED__.
//
// A securable's workspace bindings can be configured by a metastore admin or
// the owner of the securable.
//
// The original path (/api/2.1/unity-catalog/workspace-bindings/catalogs/{name})
// is deprecated. Please use the new path
// (/api/2.1/unity-catalog/bindings/{securable_type}/{securable_name}) which
// introduces the ability to bind a securable in READ_ONLY mode (catalogs only).
//
// Securable types that support binding: - catalog - storage_credential -
// credential - external_location
type WorkspaceBindingsAPI struct {
	workspaceBindingsImpl
}

// Gets workspace bindings of the catalog. The caller must be a metastore admin
// or an owner of the catalog.
func (a *WorkspaceBindingsAPI) GetByName(ctx context.Context, name string) (*GetCatalogWorkspaceBindingsResponse, error) {
	return a.workspaceBindingsImpl.Get(ctx, GetWorkspaceBindingRequest{
		Name: name,
	})
}

// Gets workspace bindings of the securable. The caller must be a metastore
// admin or an owner of the securable.
func (a *WorkspaceBindingsAPI) GetBindingsBySecurableTypeAndSecurableName(ctx context.Context, securableType string, securableName string) (*GetWorkspaceBindingsResponse, error) {
	return a.workspaceBindingsImpl.internalGetBindings(ctx, GetBindingsRequest{
		SecurableType: securableType,
		SecurableName: securableName,
	})
}
