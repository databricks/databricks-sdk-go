// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

// These APIs allow you to manage Account Metastore Assignments, Account Metastores, Account Storage Credentials, Artifact Allowlists, Catalogs, Connections, External Locations, Functions, Grants, Lakehouse Monitors, Metastores, Model Versions, Online Tables, Registered Models, Schemas, Storage Credentials, System Schemas, Table Constraints, Tables, Volumes, Workspace Bindings, etc.
package catalog

import (
	"context"
	"fmt"

	"github.com/databricks/databricks-sdk-go/client"
	"github.com/databricks/databricks-sdk-go/listing"
	"github.com/databricks/databricks-sdk-go/useragent"
)

type AccountMetastoreAssignmentsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAccountMetastoreAssignmentsInterface instead.
	WithImpl(impl AccountMetastoreAssignmentsService) AccountMetastoreAssignmentsInterface

	// Impl returns low-level AccountMetastoreAssignments API implementation
	// Deprecated: use MockAccountMetastoreAssignmentsInterface instead.
	Impl() AccountMetastoreAssignmentsService

	// Assigns a workspace to a metastore.
	//
	// Creates an assignment to a metastore for a workspace
	Create(ctx context.Context, request AccountsCreateMetastoreAssignment) error

	// Delete a metastore assignment.
	//
	// Deletes a metastore assignment to a workspace, leaving the workspace with no
	// metastore.
	Delete(ctx context.Context, request DeleteAccountMetastoreAssignmentRequest) error

	// Delete a metastore assignment.
	//
	// Deletes a metastore assignment to a workspace, leaving the workspace with no
	// metastore.
	DeleteByWorkspaceIdAndMetastoreId(ctx context.Context, workspaceId int64, metastoreId string) error

	// Gets the metastore assignment for a workspace.
	//
	// Gets the metastore assignment, if any, for the workspace specified by ID. If
	// the workspace is assigned a metastore, the mappig will be returned. If no
	// metastore is assigned to the workspace, the assignment will not be found and
	// a 404 returned.
	Get(ctx context.Context, request GetAccountMetastoreAssignmentRequest) (*AccountsMetastoreAssignment, error)

	// Gets the metastore assignment for a workspace.
	//
	// Gets the metastore assignment, if any, for the workspace specified by ID. If
	// the workspace is assigned a metastore, the mappig will be returned. If no
	// metastore is assigned to the workspace, the assignment will not be found and
	// a 404 returned.
	GetByWorkspaceId(ctx context.Context, workspaceId int64) (*AccountsMetastoreAssignment, error)

	// Get all workspaces assigned to a metastore.
	//
	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) listing.Iterator[int64]

	// Get all workspaces assigned to a metastore.
	//
	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) ([]int64, error)

	// Get all workspaces assigned to a metastore.
	//
	// Gets a list of all Databricks workspace IDs that have been assigned to given
	// metastore.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountMetastoreAssignmentsResponse, error)

	// Updates a metastore assignment to a workspaces.
	//
	// Updates an assignment to a metastore for a workspace. Currently, only the
	// default catalog may be updated.
	Update(ctx context.Context, request AccountsUpdateMetastoreAssignment) error
}

func NewAccountMetastoreAssignments(client *client.DatabricksClient) *AccountMetastoreAssignmentsAPI {
	return &AccountMetastoreAssignmentsAPI{
		impl: &accountMetastoreAssignmentsImpl{
			client: client,
		},
	}
}

// These APIs manage metastore assignments to a workspace.
type AccountMetastoreAssignmentsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AccountMetastoreAssignmentsService)
	impl AccountMetastoreAssignmentsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAccountMetastoreAssignmentsInterface instead.
func (a *AccountMetastoreAssignmentsAPI) WithImpl(impl AccountMetastoreAssignmentsService) AccountMetastoreAssignmentsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AccountMetastoreAssignments API implementation
// Deprecated: use MockAccountMetastoreAssignmentsInterface instead.
func (a *AccountMetastoreAssignmentsAPI) Impl() AccountMetastoreAssignmentsService {
	return a.impl
}

// Assigns a workspace to a metastore.
//
// Creates an assignment to a metastore for a workspace
func (a *AccountMetastoreAssignmentsAPI) Create(ctx context.Context, request AccountsCreateMetastoreAssignment) error {
	return a.impl.Create(ctx, request)
}

// Delete a metastore assignment.
//
// Deletes a metastore assignment to a workspace, leaving the workspace with no
// metastore.
func (a *AccountMetastoreAssignmentsAPI) Delete(ctx context.Context, request DeleteAccountMetastoreAssignmentRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a metastore assignment.
//
// Deletes a metastore assignment to a workspace, leaving the workspace with no
// metastore.
func (a *AccountMetastoreAssignmentsAPI) DeleteByWorkspaceIdAndMetastoreId(ctx context.Context, workspaceId int64, metastoreId string) error {
	return a.impl.Delete(ctx, DeleteAccountMetastoreAssignmentRequest{
		WorkspaceId: workspaceId,
		MetastoreId: metastoreId,
	})
}

// Gets the metastore assignment for a workspace.
//
// Gets the metastore assignment, if any, for the workspace specified by ID. If
// the workspace is assigned a metastore, the mappig will be returned. If no
// metastore is assigned to the workspace, the assignment will not be found and
// a 404 returned.
func (a *AccountMetastoreAssignmentsAPI) Get(ctx context.Context, request GetAccountMetastoreAssignmentRequest) (*AccountsMetastoreAssignment, error) {
	return a.impl.Get(ctx, request)
}

// Gets the metastore assignment for a workspace.
//
// Gets the metastore assignment, if any, for the workspace specified by ID. If
// the workspace is assigned a metastore, the mappig will be returned. If no
// metastore is assigned to the workspace, the assignment will not be found and
// a 404 returned.
func (a *AccountMetastoreAssignmentsAPI) GetByWorkspaceId(ctx context.Context, workspaceId int64) (*AccountsMetastoreAssignment, error) {
	return a.impl.Get(ctx, GetAccountMetastoreAssignmentRequest{
		WorkspaceId: workspaceId,
	})
}

// Get all workspaces assigned to a metastore.
//
// Gets a list of all Databricks workspace IDs that have been assigned to given
// metastore.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountMetastoreAssignmentsAPI) List(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) listing.Iterator[int64] {

	getNextPage := func(ctx context.Context, req ListAccountMetastoreAssignmentsRequest) (*ListAccountMetastoreAssignmentsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListAccountMetastoreAssignmentsResponse) []int64 {
		return resp.WorkspaceIds
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// Get all workspaces assigned to a metastore.
//
// Gets a list of all Databricks workspace IDs that have been assigned to given
// metastore.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountMetastoreAssignmentsAPI) ListAll(ctx context.Context, request ListAccountMetastoreAssignmentsRequest) ([]int64, error) {
	iterator := a.List(ctx, request)
	return listing.ToSlice[int64](ctx, iterator)
}

// Get all workspaces assigned to a metastore.
//
// Gets a list of all Databricks workspace IDs that have been assigned to given
// metastore.
func (a *AccountMetastoreAssignmentsAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListAccountMetastoreAssignmentsResponse, error) {
	return a.impl.List(ctx, ListAccountMetastoreAssignmentsRequest{
		MetastoreId: metastoreId,
	})
}

// Updates a metastore assignment to a workspaces.
//
// Updates an assignment to a metastore for a workspace. Currently, only the
// default catalog may be updated.
func (a *AccountMetastoreAssignmentsAPI) Update(ctx context.Context, request AccountsUpdateMetastoreAssignment) error {
	return a.impl.Update(ctx, request)
}

type AccountMetastoresInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAccountMetastoresInterface instead.
	WithImpl(impl AccountMetastoresService) AccountMetastoresInterface

	// Impl returns low-level AccountMetastores API implementation
	// Deprecated: use MockAccountMetastoresInterface instead.
	Impl() AccountMetastoresService

	// Create metastore.
	//
	// Creates a Unity Catalog metastore.
	Create(ctx context.Context, request AccountsCreateMetastore) (*AccountsMetastoreInfo, error)

	// Delete a metastore.
	//
	// Deletes a Unity Catalog metastore for an account, both specified by ID.
	Delete(ctx context.Context, request DeleteAccountMetastoreRequest) error

	// Delete a metastore.
	//
	// Deletes a Unity Catalog metastore for an account, both specified by ID.
	DeleteByMetastoreId(ctx context.Context, metastoreId string) error

	// Get a metastore.
	//
	// Gets a Unity Catalog metastore from an account, both specified by ID.
	Get(ctx context.Context, request GetAccountMetastoreRequest) (*AccountsMetastoreInfo, error)

	// Get a metastore.
	//
	// Gets a Unity Catalog metastore from an account, both specified by ID.
	GetByMetastoreId(ctx context.Context, metastoreId string) (*AccountsMetastoreInfo, error)

	// Get all metastores associated with an account.
	//
	// Gets all Unity Catalog metastores associated with an account specified by ID.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[MetastoreInfo]

	// Get all metastores associated with an account.
	//
	// Gets all Unity Catalog metastores associated with an account specified by ID.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]MetastoreInfo, error)

	// Update a metastore.
	//
	// Updates an existing Unity Catalog metastore.
	Update(ctx context.Context, request AccountsUpdateMetastore) (*AccountsMetastoreInfo, error)
}

func NewAccountMetastores(client *client.DatabricksClient) *AccountMetastoresAPI {
	return &AccountMetastoresAPI{
		impl: &accountMetastoresImpl{
			client: client,
		},
	}
}

// These APIs manage Unity Catalog metastores for an account. A metastore
// contains catalogs that can be associated with workspaces
type AccountMetastoresAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AccountMetastoresService)
	impl AccountMetastoresService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAccountMetastoresInterface instead.
func (a *AccountMetastoresAPI) WithImpl(impl AccountMetastoresService) AccountMetastoresInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AccountMetastores API implementation
// Deprecated: use MockAccountMetastoresInterface instead.
func (a *AccountMetastoresAPI) Impl() AccountMetastoresService {
	return a.impl
}

// Create metastore.
//
// Creates a Unity Catalog metastore.
func (a *AccountMetastoresAPI) Create(ctx context.Context, request AccountsCreateMetastore) (*AccountsMetastoreInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a metastore.
//
// Deletes a Unity Catalog metastore for an account, both specified by ID.
func (a *AccountMetastoresAPI) Delete(ctx context.Context, request DeleteAccountMetastoreRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a metastore.
//
// Deletes a Unity Catalog metastore for an account, both specified by ID.
func (a *AccountMetastoresAPI) DeleteByMetastoreId(ctx context.Context, metastoreId string) error {
	return a.impl.Delete(ctx, DeleteAccountMetastoreRequest{
		MetastoreId: metastoreId,
	})
}

// Get a metastore.
//
// Gets a Unity Catalog metastore from an account, both specified by ID.
func (a *AccountMetastoresAPI) Get(ctx context.Context, request GetAccountMetastoreRequest) (*AccountsMetastoreInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a metastore.
//
// Gets a Unity Catalog metastore from an account, both specified by ID.
func (a *AccountMetastoresAPI) GetByMetastoreId(ctx context.Context, metastoreId string) (*AccountsMetastoreInfo, error) {
	return a.impl.Get(ctx, GetAccountMetastoreRequest{
		MetastoreId: metastoreId,
	})
}

// Get all metastores associated with an account.
//
// Gets all Unity Catalog metastores associated with an account specified by ID.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountMetastoresAPI) List(ctx context.Context) listing.Iterator[MetastoreInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListMetastoresResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListMetastoresResponse) []MetastoreInfo {
		return resp.Metastores
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// Get all metastores associated with an account.
//
// Gets all Unity Catalog metastores associated with an account specified by ID.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountMetastoresAPI) ListAll(ctx context.Context) ([]MetastoreInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[MetastoreInfo](ctx, iterator)
}

// Update a metastore.
//
// Updates an existing Unity Catalog metastore.
func (a *AccountMetastoresAPI) Update(ctx context.Context, request AccountsUpdateMetastore) (*AccountsMetastoreInfo, error) {
	return a.impl.Update(ctx, request)
}

type AccountStorageCredentialsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockAccountStorageCredentialsInterface instead.
	WithImpl(impl AccountStorageCredentialsService) AccountStorageCredentialsInterface

	// Impl returns low-level AccountStorageCredentials API implementation
	// Deprecated: use MockAccountStorageCredentialsInterface instead.
	Impl() AccountStorageCredentialsService

	// Create a storage credential.
	//
	// Creates a new storage credential. The request object is specific to the
	// cloud:
	//
	// * **AwsIamRole** for AWS credentials * **AzureServicePrincipal** for Azure
	// credentials * **GcpServiceAcountKey** for GCP credentials.
	//
	// The caller must be a metastore admin and have the
	// **CREATE_STORAGE_CREDENTIAL** privilege on the metastore.
	Create(ctx context.Context, request AccountsCreateStorageCredential) (*AccountsStorageCredentialInfo, error)

	// Delete a storage credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	Delete(ctx context.Context, request DeleteAccountStorageCredentialRequest) error

	// Delete a storage credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	DeleteByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) error

	// Gets the named storage credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have a level of privilege on
	// the storage credential.
	Get(ctx context.Context, request GetAccountStorageCredentialRequest) (*AccountsStorageCredentialInfo, error)

	// Gets the named storage credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have a level of privilege on
	// the storage credential.
	GetByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsStorageCredentialInfo, error)

	// Get all storage credentials assigned to a metastore.
	//
	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	List(ctx context.Context, request ListAccountStorageCredentialsRequest) ([]StorageCredentialInfo, error)

	// StorageCredentialInfoNameToIdMap calls [AccountStorageCredentialsAPI.List] and creates a map of results with [StorageCredentialInfo].Name as key and [StorageCredentialInfo].Id as value.
	//
	// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
	//
	// Note: All [StorageCredentialInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	StorageCredentialInfoNameToIdMap(ctx context.Context, request ListAccountStorageCredentialsRequest) (map[string]string, error)

	// GetByName calls [AccountStorageCredentialsAPI.StorageCredentialInfoNameToIdMap] and returns a single [StorageCredentialInfo].
	//
	// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
	//
	// Note: All [StorageCredentialInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error)

	// Get all storage credentials assigned to a metastore.
	//
	// Gets a list of all storage credentials that have been assigned to given
	// metastore.
	ListByMetastoreId(ctx context.Context, metastoreId string) ([]StorageCredentialInfo, error)

	// Updates a storage credential.
	//
	// Updates a storage credential on the metastore. The caller must be the owner
	// of the storage credential. If the caller is a metastore admin, only the
	// __owner__ credential can be changed.
	Update(ctx context.Context, request AccountsUpdateStorageCredential) (*AccountsStorageCredentialInfo, error)
}

func NewAccountStorageCredentials(client *client.DatabricksClient) *AccountStorageCredentialsAPI {
	return &AccountStorageCredentialsAPI{
		impl: &accountStorageCredentialsImpl{
			client: client,
		},
	}
}

// These APIs manage storage credentials for a particular metastore.
type AccountStorageCredentialsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(AccountStorageCredentialsService)
	impl AccountStorageCredentialsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockAccountStorageCredentialsInterface instead.
func (a *AccountStorageCredentialsAPI) WithImpl(impl AccountStorageCredentialsService) AccountStorageCredentialsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level AccountStorageCredentials API implementation
// Deprecated: use MockAccountStorageCredentialsInterface instead.
func (a *AccountStorageCredentialsAPI) Impl() AccountStorageCredentialsService {
	return a.impl
}

// Create a storage credential.
//
// Creates a new storage credential. The request object is specific to the
// cloud:
//
// * **AwsIamRole** for AWS credentials * **AzureServicePrincipal** for Azure
// credentials * **GcpServiceAcountKey** for GCP credentials.
//
// The caller must be a metastore admin and have the
// **CREATE_STORAGE_CREDENTIAL** privilege on the metastore.
func (a *AccountStorageCredentialsAPI) Create(ctx context.Context, request AccountsCreateStorageCredential) (*AccountsStorageCredentialInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a storage credential.
//
// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *AccountStorageCredentialsAPI) Delete(ctx context.Context, request DeleteAccountStorageCredentialRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a storage credential.
//
// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *AccountStorageCredentialsAPI) DeleteByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) error {
	return a.impl.Delete(ctx, DeleteAccountStorageCredentialRequest{
		MetastoreId:           metastoreId,
		StorageCredentialName: storageCredentialName,
	})
}

// Gets the named storage credential.
//
// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have a level of privilege on
// the storage credential.
func (a *AccountStorageCredentialsAPI) Get(ctx context.Context, request GetAccountStorageCredentialRequest) (*AccountsStorageCredentialInfo, error) {
	return a.impl.Get(ctx, request)
}

// Gets the named storage credential.
//
// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have a level of privilege on
// the storage credential.
func (a *AccountStorageCredentialsAPI) GetByMetastoreIdAndStorageCredentialName(ctx context.Context, metastoreId string, storageCredentialName string) (*AccountsStorageCredentialInfo, error) {
	return a.impl.Get(ctx, GetAccountStorageCredentialRequest{
		MetastoreId:           metastoreId,
		StorageCredentialName: storageCredentialName,
	})
}

// Get all storage credentials assigned to a metastore.
//
// Gets a list of all storage credentials that have been assigned to given
// metastore.
func (a *AccountStorageCredentialsAPI) List(ctx context.Context, request ListAccountStorageCredentialsRequest) ([]StorageCredentialInfo, error) {
	return a.impl.List(ctx, request)
}

// StorageCredentialInfoNameToIdMap calls [AccountStorageCredentialsAPI.List] and creates a map of results with [StorageCredentialInfo].Name as key and [StorageCredentialInfo].Id as value.
//
// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
//
// Note: All [StorageCredentialInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountStorageCredentialsAPI) StorageCredentialInfoNameToIdMap(ctx context.Context, request ListAccountStorageCredentialsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.List(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// GetByName calls [AccountStorageCredentialsAPI.StorageCredentialInfoNameToIdMap] and returns a single [StorageCredentialInfo].
//
// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
//
// Note: All [StorageCredentialInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *AccountStorageCredentialsAPI) GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.List(ctx, ListAccountStorageCredentialsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]StorageCredentialInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("StorageCredentialInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of StorageCredentialInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Get all storage credentials assigned to a metastore.
//
// Gets a list of all storage credentials that have been assigned to given
// metastore.
func (a *AccountStorageCredentialsAPI) ListByMetastoreId(ctx context.Context, metastoreId string) ([]StorageCredentialInfo, error) {
	return a.impl.List(ctx, ListAccountStorageCredentialsRequest{
		MetastoreId: metastoreId,
	})
}

// Updates a storage credential.
//
// Updates a storage credential on the metastore. The caller must be the owner
// of the storage credential. If the caller is a metastore admin, only the
// __owner__ credential can be changed.
func (a *AccountStorageCredentialsAPI) Update(ctx context.Context, request AccountsUpdateStorageCredential) (*AccountsStorageCredentialInfo, error) {
	return a.impl.Update(ctx, request)
}

type ArtifactAllowlistsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockArtifactAllowlistsInterface instead.
	WithImpl(impl ArtifactAllowlistsService) ArtifactAllowlistsInterface

	// Impl returns low-level ArtifactAllowlists API implementation
	// Deprecated: use MockArtifactAllowlistsInterface instead.
	Impl() ArtifactAllowlistsService

	// Get an artifact allowlist.
	//
	// Get the artifact allowlist of a certain artifact type. The caller must be a
	// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	Get(ctx context.Context, request GetArtifactAllowlistRequest) (*ArtifactAllowlistInfo, error)

	// Get an artifact allowlist.
	//
	// Get the artifact allowlist of a certain artifact type. The caller must be a
	// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	GetByArtifactType(ctx context.Context, artifactType ArtifactType) (*ArtifactAllowlistInfo, error)

	// Set an artifact allowlist.
	//
	// Set the artifact allowlist of a certain artifact type. The whole artifact
	// allowlist is replaced with the new allowlist. The caller must be a metastore
	// admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
	Update(ctx context.Context, request SetArtifactAllowlist) (*ArtifactAllowlistInfo, error)
}

func NewArtifactAllowlists(client *client.DatabricksClient) *ArtifactAllowlistsAPI {
	return &ArtifactAllowlistsAPI{
		impl: &artifactAllowlistsImpl{
			client: client,
		},
	}
}

// In Databricks Runtime 13.3 and above, you can add libraries and init scripts
// to the `allowlist` in UC so that users can leverage these artifacts on
// compute configured with shared access mode.
type ArtifactAllowlistsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(ArtifactAllowlistsService)
	impl ArtifactAllowlistsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockArtifactAllowlistsInterface instead.
func (a *ArtifactAllowlistsAPI) WithImpl(impl ArtifactAllowlistsService) ArtifactAllowlistsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level ArtifactAllowlists API implementation
// Deprecated: use MockArtifactAllowlistsInterface instead.
func (a *ArtifactAllowlistsAPI) Impl() ArtifactAllowlistsService {
	return a.impl
}

// Get an artifact allowlist.
//
// Get the artifact allowlist of a certain artifact type. The caller must be a
// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
func (a *ArtifactAllowlistsAPI) Get(ctx context.Context, request GetArtifactAllowlistRequest) (*ArtifactAllowlistInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get an artifact allowlist.
//
// Get the artifact allowlist of a certain artifact type. The caller must be a
// metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
func (a *ArtifactAllowlistsAPI) GetByArtifactType(ctx context.Context, artifactType ArtifactType) (*ArtifactAllowlistInfo, error) {
	return a.impl.Get(ctx, GetArtifactAllowlistRequest{
		ArtifactType: artifactType,
	})
}

// Set an artifact allowlist.
//
// Set the artifact allowlist of a certain artifact type. The whole artifact
// allowlist is replaced with the new allowlist. The caller must be a metastore
// admin or have the **MANAGE ALLOWLIST** privilege on the metastore.
func (a *ArtifactAllowlistsAPI) Update(ctx context.Context, request SetArtifactAllowlist) (*ArtifactAllowlistInfo, error) {
	return a.impl.Update(ctx, request)
}

type CatalogsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockCatalogsInterface instead.
	WithImpl(impl CatalogsService) CatalogsInterface

	// Impl returns low-level Catalogs API implementation
	// Deprecated: use MockCatalogsInterface instead.
	Impl() CatalogsService

	// Create a catalog.
	//
	// Creates a new catalog instance in the parent metastore if the caller is a
	// metastore admin or has the **CREATE_CATALOG** privilege.
	Create(ctx context.Context, request CreateCatalog) (*CatalogInfo, error)

	// Delete a catalog.
	//
	// Deletes the catalog that matches the supplied name. The caller must be a
	// metastore admin or the owner of the catalog.
	Delete(ctx context.Context, request DeleteCatalogRequest) error

	// Delete a catalog.
	//
	// Deletes the catalog that matches the supplied name. The caller must be a
	// metastore admin or the owner of the catalog.
	DeleteByName(ctx context.Context, name string) error

	// Get a catalog.
	//
	// Gets the specified catalog in a metastore. The caller must be a metastore
	// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
	// privilege set for their account.
	Get(ctx context.Context, request GetCatalogRequest) (*CatalogInfo, error)

	// Get a catalog.
	//
	// Gets the specified catalog in a metastore. The caller must be a metastore
	// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
	// privilege set for their account.
	GetByName(ctx context.Context, name string) (*CatalogInfo, error)

	// List catalogs.
	//
	// Gets an array of catalogs in the metastore. If the caller is the metastore
	// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
	// caller (or for which the caller has the **USE_CATALOG** privilege) will be
	// retrieved. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[CatalogInfo]

	// List catalogs.
	//
	// Gets an array of catalogs in the metastore. If the caller is the metastore
	// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
	// caller (or for which the caller has the **USE_CATALOG** privilege) will be
	// retrieved. There is no guarantee of a specific ordering of the elements in
	// the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]CatalogInfo, error)

	// Update a catalog.
	//
	// Updates the catalog that matches the supplied name. The caller must be either
	// the owner of the catalog, or a metastore admin (when changing the owner field
	// of the catalog).
	Update(ctx context.Context, request UpdateCatalog) (*CatalogInfo, error)
}

func NewCatalogs(client *client.DatabricksClient) *CatalogsAPI {
	return &CatalogsAPI{
		impl: &catalogsImpl{
			client: client,
		},
	}
}

// A catalog is the first layer of Unity Catalog’s three-level namespace.
// It’s used to organize your data assets. Users can see all catalogs on which
// they have been assigned the USE_CATALOG data permission.
//
// In Unity Catalog, admins and data stewards manage users and their access to
// data centrally across all of the workspaces in a Databricks account. Users in
// different workspaces can share access to the same data, depending on
// privileges granted centrally in Unity Catalog.
type CatalogsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(CatalogsService)
	impl CatalogsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockCatalogsInterface instead.
func (a *CatalogsAPI) WithImpl(impl CatalogsService) CatalogsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Catalogs API implementation
// Deprecated: use MockCatalogsInterface instead.
func (a *CatalogsAPI) Impl() CatalogsService {
	return a.impl
}

// Create a catalog.
//
// Creates a new catalog instance in the parent metastore if the caller is a
// metastore admin or has the **CREATE_CATALOG** privilege.
func (a *CatalogsAPI) Create(ctx context.Context, request CreateCatalog) (*CatalogInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a catalog.
//
// Deletes the catalog that matches the supplied name. The caller must be a
// metastore admin or the owner of the catalog.
func (a *CatalogsAPI) Delete(ctx context.Context, request DeleteCatalogRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a catalog.
//
// Deletes the catalog that matches the supplied name. The caller must be a
// metastore admin or the owner of the catalog.
func (a *CatalogsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteCatalogRequest{
		Name: name,
	})
}

// Get a catalog.
//
// Gets the specified catalog in a metastore. The caller must be a metastore
// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
// privilege set for their account.
func (a *CatalogsAPI) Get(ctx context.Context, request GetCatalogRequest) (*CatalogInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a catalog.
//
// Gets the specified catalog in a metastore. The caller must be a metastore
// admin, the owner of the catalog, or a user that has the **USE_CATALOG**
// privilege set for their account.
func (a *CatalogsAPI) GetByName(ctx context.Context, name string) (*CatalogInfo, error) {
	return a.impl.Get(ctx, GetCatalogRequest{
		Name: name,
	})
}

// List catalogs.
//
// Gets an array of catalogs in the metastore. If the caller is the metastore
// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
// caller (or for which the caller has the **USE_CATALOG** privilege) will be
// retrieved. There is no guarantee of a specific ordering of the elements in
// the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *CatalogsAPI) List(ctx context.Context) listing.Iterator[CatalogInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListCatalogsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListCatalogsResponse) []CatalogInfo {
		return resp.Catalogs
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List catalogs.
//
// Gets an array of catalogs in the metastore. If the caller is the metastore
// admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the
// caller (or for which the caller has the **USE_CATALOG** privilege) will be
// retrieved. There is no guarantee of a specific ordering of the elements in
// the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *CatalogsAPI) ListAll(ctx context.Context) ([]CatalogInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[CatalogInfo](ctx, iterator)
}

// Update a catalog.
//
// Updates the catalog that matches the supplied name. The caller must be either
// the owner of the catalog, or a metastore admin (when changing the owner field
// of the catalog).
func (a *CatalogsAPI) Update(ctx context.Context, request UpdateCatalog) (*CatalogInfo, error) {
	return a.impl.Update(ctx, request)
}

type ConnectionsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockConnectionsInterface instead.
	WithImpl(impl ConnectionsService) ConnectionsInterface

	// Impl returns low-level Connections API implementation
	// Deprecated: use MockConnectionsInterface instead.
	Impl() ConnectionsService

	// Create a connection.
	//
	// Creates a new connection
	//
	// Creates a new connection to an external data source. It allows users to
	// specify connection details and configurations for interaction with the
	// external server.
	Create(ctx context.Context, request CreateConnection) (*ConnectionInfo, error)

	// Delete a connection.
	//
	// Deletes the connection that matches the supplied name.
	Delete(ctx context.Context, request DeleteConnectionRequest) error

	// Delete a connection.
	//
	// Deletes the connection that matches the supplied name.
	DeleteByName(ctx context.Context, name string) error

	// Get a connection.
	//
	// Gets a connection from it's name.
	Get(ctx context.Context, request GetConnectionRequest) (*ConnectionInfo, error)

	// Get a connection.
	//
	// Gets a connection from it's name.
	GetByName(ctx context.Context, name string) (*ConnectionInfo, error)

	// List connections.
	//
	// List all connections.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[ConnectionInfo]

	// List connections.
	//
	// List all connections.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]ConnectionInfo, error)

	// ConnectionInfoNameToFullNameMap calls [ConnectionsAPI.ListAll] and creates a map of results with [ConnectionInfo].Name as key and [ConnectionInfo].FullName as value.
	//
	// Returns an error if there's more than one [ConnectionInfo] with the same .Name.
	//
	// Note: All [ConnectionInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	ConnectionInfoNameToFullNameMap(ctx context.Context) (map[string]string, error)

	// Update a connection.
	//
	// Updates the connection that matches the supplied name.
	Update(ctx context.Context, request UpdateConnection) (*ConnectionInfo, error)
}

func NewConnections(client *client.DatabricksClient) *ConnectionsAPI {
	return &ConnectionsAPI{
		impl: &connectionsImpl{
			client: client,
		},
	}
}

// Connections allow for creating a connection to an external data source.
//
// A connection is an abstraction of an external data source that can be
// connected from Databricks Compute. Creating a connection object is the first
// step to managing external data sources within Unity Catalog, with the second
// step being creating a data object (catalog, schema, or table) using the
// connection. Data objects derived from a connection can be written to or read
// from similar to other Unity Catalog data objects based on cloud storage.
// Users may create different types of connections with each connection having a
// unique set of configuration options to support credential management and
// other settings.
type ConnectionsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(ConnectionsService)
	impl ConnectionsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockConnectionsInterface instead.
func (a *ConnectionsAPI) WithImpl(impl ConnectionsService) ConnectionsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Connections API implementation
// Deprecated: use MockConnectionsInterface instead.
func (a *ConnectionsAPI) Impl() ConnectionsService {
	return a.impl
}

// Create a connection.
//
// # Creates a new connection
//
// Creates a new connection to an external data source. It allows users to
// specify connection details and configurations for interaction with the
// external server.
func (a *ConnectionsAPI) Create(ctx context.Context, request CreateConnection) (*ConnectionInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a connection.
//
// Deletes the connection that matches the supplied name.
func (a *ConnectionsAPI) Delete(ctx context.Context, request DeleteConnectionRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a connection.
//
// Deletes the connection that matches the supplied name.
func (a *ConnectionsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteConnectionRequest{
		Name: name,
	})
}

// Get a connection.
//
// Gets a connection from it's name.
func (a *ConnectionsAPI) Get(ctx context.Context, request GetConnectionRequest) (*ConnectionInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a connection.
//
// Gets a connection from it's name.
func (a *ConnectionsAPI) GetByName(ctx context.Context, name string) (*ConnectionInfo, error) {
	return a.impl.Get(ctx, GetConnectionRequest{
		Name: name,
	})
}

// List connections.
//
// List all connections.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConnectionsAPI) List(ctx context.Context) listing.Iterator[ConnectionInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListConnectionsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListConnectionsResponse) []ConnectionInfo {
		return resp.Connections
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List connections.
//
// List all connections.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConnectionsAPI) ListAll(ctx context.Context) ([]ConnectionInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[ConnectionInfo](ctx, iterator)
}

// ConnectionInfoNameToFullNameMap calls [ConnectionsAPI.ListAll] and creates a map of results with [ConnectionInfo].Name as key and [ConnectionInfo].FullName as value.
//
// Returns an error if there's more than one [ConnectionInfo] with the same .Name.
//
// Note: All [ConnectionInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ConnectionsAPI) ConnectionInfoNameToFullNameMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

// Update a connection.
//
// Updates the connection that matches the supplied name.
func (a *ConnectionsAPI) Update(ctx context.Context, request UpdateConnection) (*ConnectionInfo, error) {
	return a.impl.Update(ctx, request)
}

type ExternalLocationsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockExternalLocationsInterface instead.
	WithImpl(impl ExternalLocationsService) ExternalLocationsInterface

	// Impl returns low-level ExternalLocations API implementation
	// Deprecated: use MockExternalLocationsInterface instead.
	Impl() ExternalLocationsService

	// Create an external location.
	//
	// Creates a new external location entry in the metastore. The caller must be a
	// metastore admin or have the **CREATE_EXTERNAL_LOCATION** privilege on both
	// the metastore and the associated storage credential.
	Create(ctx context.Context, request CreateExternalLocation) (*ExternalLocationInfo, error)

	// Delete an external location.
	//
	// Deletes the specified external location from the metastore. The caller must
	// be the owner of the external location.
	Delete(ctx context.Context, request DeleteExternalLocationRequest) error

	// Delete an external location.
	//
	// Deletes the specified external location from the metastore. The caller must
	// be the owner of the external location.
	DeleteByName(ctx context.Context, name string) error

	// Get an external location.
	//
	// Gets an external location from the metastore. The caller must be either a
	// metastore admin, the owner of the external location, or a user that has some
	// privilege on the external location.
	Get(ctx context.Context, request GetExternalLocationRequest) (*ExternalLocationInfo, error)

	// Get an external location.
	//
	// Gets an external location from the metastore. The caller must be either a
	// metastore admin, the owner of the external location, or a user that has some
	// privilege on the external location.
	GetByName(ctx context.Context, name string) (*ExternalLocationInfo, error)

	// List external locations.
	//
	// Gets an array of external locations (__ExternalLocationInfo__ objects) from
	// the metastore. The caller must be a metastore admin, the owner of the
	// external location, or a user that has some privilege on the external
	// location. For unpaginated request, there is no guarantee of a specific
	// ordering of the elements in the array. For paginated request, elements are
	// ordered by their name.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListExternalLocationsRequest) listing.Iterator[ExternalLocationInfo]

	// List external locations.
	//
	// Gets an array of external locations (__ExternalLocationInfo__ objects) from
	// the metastore. The caller must be a metastore admin, the owner of the
	// external location, or a user that has some privilege on the external
	// location. For unpaginated request, there is no guarantee of a specific
	// ordering of the elements in the array. For paginated request, elements are
	// ordered by their name.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListExternalLocationsRequest) ([]ExternalLocationInfo, error)

	// Update an external location.
	//
	// Updates an external location in the metastore. The caller must be the owner
	// of the external location, or be a metastore admin. In the second case, the
	// admin can only update the name of the external location.
	Update(ctx context.Context, request UpdateExternalLocation) (*ExternalLocationInfo, error)
}

func NewExternalLocations(client *client.DatabricksClient) *ExternalLocationsAPI {
	return &ExternalLocationsAPI{
		impl: &externalLocationsImpl{
			client: client,
		},
	}
}

// An external location is an object that combines a cloud storage path with a
// storage credential that authorizes access to the cloud storage path. Each
// external location is subject to Unity Catalog access-control policies that
// control which users and groups can access the credential. If a user does not
// have access to an external location in Unity Catalog, the request fails and
// Unity Catalog does not attempt to authenticate to your cloud tenant on the
// user’s behalf.
//
// Databricks recommends using external locations rather than using storage
// credentials directly.
//
// To create external locations, you must be a metastore admin or a user with
// the **CREATE_EXTERNAL_LOCATION** privilege.
type ExternalLocationsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(ExternalLocationsService)
	impl ExternalLocationsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockExternalLocationsInterface instead.
func (a *ExternalLocationsAPI) WithImpl(impl ExternalLocationsService) ExternalLocationsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level ExternalLocations API implementation
// Deprecated: use MockExternalLocationsInterface instead.
func (a *ExternalLocationsAPI) Impl() ExternalLocationsService {
	return a.impl
}

// Create an external location.
//
// Creates a new external location entry in the metastore. The caller must be a
// metastore admin or have the **CREATE_EXTERNAL_LOCATION** privilege on both
// the metastore and the associated storage credential.
func (a *ExternalLocationsAPI) Create(ctx context.Context, request CreateExternalLocation) (*ExternalLocationInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete an external location.
//
// Deletes the specified external location from the metastore. The caller must
// be the owner of the external location.
func (a *ExternalLocationsAPI) Delete(ctx context.Context, request DeleteExternalLocationRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete an external location.
//
// Deletes the specified external location from the metastore. The caller must
// be the owner of the external location.
func (a *ExternalLocationsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteExternalLocationRequest{
		Name: name,
	})
}

// Get an external location.
//
// Gets an external location from the metastore. The caller must be either a
// metastore admin, the owner of the external location, or a user that has some
// privilege on the external location.
func (a *ExternalLocationsAPI) Get(ctx context.Context, request GetExternalLocationRequest) (*ExternalLocationInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get an external location.
//
// Gets an external location from the metastore. The caller must be either a
// metastore admin, the owner of the external location, or a user that has some
// privilege on the external location.
func (a *ExternalLocationsAPI) GetByName(ctx context.Context, name string) (*ExternalLocationInfo, error) {
	return a.impl.Get(ctx, GetExternalLocationRequest{
		Name: name,
	})
}

// List external locations.
//
// Gets an array of external locations (__ExternalLocationInfo__ objects) from
// the metastore. The caller must be a metastore admin, the owner of the
// external location, or a user that has some privilege on the external
// location. For unpaginated request, there is no guarantee of a specific
// ordering of the elements in the array. For paginated request, elements are
// ordered by their name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ExternalLocationsAPI) List(ctx context.Context, request ListExternalLocationsRequest) listing.Iterator[ExternalLocationInfo] {

	getNextPage := func(ctx context.Context, req ListExternalLocationsRequest) (*ListExternalLocationsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListExternalLocationsResponse) []ExternalLocationInfo {
		return resp.ExternalLocations
	}
	getNextReq := func(resp *ListExternalLocationsResponse) *ListExternalLocationsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List external locations.
//
// Gets an array of external locations (__ExternalLocationInfo__ objects) from
// the metastore. The caller must be a metastore admin, the owner of the
// external location, or a user that has some privilege on the external
// location. For unpaginated request, there is no guarantee of a specific
// ordering of the elements in the array. For paginated request, elements are
// ordered by their name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ExternalLocationsAPI) ListAll(ctx context.Context, request ListExternalLocationsRequest) ([]ExternalLocationInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[ExternalLocationInfo, int](ctx, iterator, request.MaxResults)

}

// Update an external location.
//
// Updates an external location in the metastore. The caller must be the owner
// of the external location, or be a metastore admin. In the second case, the
// admin can only update the name of the external location.
func (a *ExternalLocationsAPI) Update(ctx context.Context, request UpdateExternalLocation) (*ExternalLocationInfo, error) {
	return a.impl.Update(ctx, request)
}

type FunctionsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockFunctionsInterface instead.
	WithImpl(impl FunctionsService) FunctionsInterface

	// Impl returns low-level Functions API implementation
	// Deprecated: use MockFunctionsInterface instead.
	Impl() FunctionsService

	// Create a function.
	//
	// Creates a new function
	//
	// The user must have the following permissions in order for the function to be
	// created: - **USE_CATALOG** on the function's parent catalog - **USE_SCHEMA**
	// and **CREATE_FUNCTION** on the function's parent schema
	Create(ctx context.Context, request CreateFunctionRequest) (*FunctionInfo, error)

	// Delete a function.
	//
	// Deletes the function that matches the supplied name. For the deletion to
	// succeed, the user must satisfy one of the following conditions: - Is the
	// owner of the function's parent catalog - Is the owner of the function's
	// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
	// Is the owner of the function itself and have both the **USE_CATALOG**
	// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
	// parent schema
	Delete(ctx context.Context, request DeleteFunctionRequest) error

	// Delete a function.
	//
	// Deletes the function that matches the supplied name. For the deletion to
	// succeed, the user must satisfy one of the following conditions: - Is the
	// owner of the function's parent catalog - Is the owner of the function's
	// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
	// Is the owner of the function itself and have both the **USE_CATALOG**
	// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
	// parent schema
	DeleteByName(ctx context.Context, name string) error

	// Get a function.
	//
	// Gets a function from within a parent catalog and schema. For the fetch to
	// succeed, the user must satisfy one of the following requirements: - Is a
	// metastore admin - Is an owner of the function's parent catalog - Have the
	// **USE_CATALOG** privilege on the function's parent catalog and be the owner
	// of the function - Have the **USE_CATALOG** privilege on the function's parent
	// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
	// the **EXECUTE** privilege on the function itself
	Get(ctx context.Context, request GetFunctionRequest) (*FunctionInfo, error)

	// Get a function.
	//
	// Gets a function from within a parent catalog and schema. For the fetch to
	// succeed, the user must satisfy one of the following requirements: - Is a
	// metastore admin - Is an owner of the function's parent catalog - Have the
	// **USE_CATALOG** privilege on the function's parent catalog and be the owner
	// of the function - Have the **USE_CATALOG** privilege on the function's parent
	// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
	// the **EXECUTE** privilege on the function itself
	GetByName(ctx context.Context, name string) (*FunctionInfo, error)

	// List functions.
	//
	// List functions within the specified parent catalog and schema. If the user is
	// a metastore admin, all functions are returned in the output list. Otherwise,
	// the user must have the **USE_CATALOG** privilege on the catalog and the
	// **USE_SCHEMA** privilege on the schema, and the output list contains only
	// functions for which either the user has the **EXECUTE** privilege or the user
	// is the owner. For unpaginated request, there is no guarantee of a specific
	// ordering of the elements in the array. For paginated request, elements are
	// ordered by their name.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListFunctionsRequest) listing.Iterator[FunctionInfo]

	// List functions.
	//
	// List functions within the specified parent catalog and schema. If the user is
	// a metastore admin, all functions are returned in the output list. Otherwise,
	// the user must have the **USE_CATALOG** privilege on the catalog and the
	// **USE_SCHEMA** privilege on the schema, and the output list contains only
	// functions for which either the user has the **EXECUTE** privilege or the user
	// is the owner. For unpaginated request, there is no guarantee of a specific
	// ordering of the elements in the array. For paginated request, elements are
	// ordered by their name.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListFunctionsRequest) ([]FunctionInfo, error)

	// FunctionInfoNameToFullNameMap calls [FunctionsAPI.ListAll] and creates a map of results with [FunctionInfo].Name as key and [FunctionInfo].FullName as value.
	//
	// Returns an error if there's more than one [FunctionInfo] with the same .Name.
	//
	// Note: All [FunctionInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	FunctionInfoNameToFullNameMap(ctx context.Context, request ListFunctionsRequest) (map[string]string, error)

	// Update a function.
	//
	// Updates the function that matches the supplied name. Only the owner of the
	// function can be updated. If the user is not a metastore admin, the user must
	// be a member of the group that is the new function owner. - Is a metastore
	// admin - Is the owner of the function's parent catalog - Is the owner of the
	// function's parent schema and has the **USE_CATALOG** privilege on its parent
	// catalog - Is the owner of the function itself and has the **USE_CATALOG**
	// privilege on its parent catalog as well as the **USE_SCHEMA** privilege on
	// the function's parent schema.
	Update(ctx context.Context, request UpdateFunction) (*FunctionInfo, error)
}

func NewFunctions(client *client.DatabricksClient) *FunctionsAPI {
	return &FunctionsAPI{
		impl: &functionsImpl{
			client: client,
		},
	}
}

// Functions implement User-Defined Functions (UDFs) in Unity Catalog.
//
// The function implementation can be any SQL expression or Query, and it can be
// invoked wherever a table reference is allowed in a query. In Unity Catalog, a
// function resides at the same level as a table, so it can be referenced with
// the form __catalog_name__.__schema_name__.__function_name__.
type FunctionsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(FunctionsService)
	impl FunctionsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockFunctionsInterface instead.
func (a *FunctionsAPI) WithImpl(impl FunctionsService) FunctionsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Functions API implementation
// Deprecated: use MockFunctionsInterface instead.
func (a *FunctionsAPI) Impl() FunctionsService {
	return a.impl
}

// Create a function.
//
// # Creates a new function
//
// The user must have the following permissions in order for the function to be
// created: - **USE_CATALOG** on the function's parent catalog - **USE_SCHEMA**
// and **CREATE_FUNCTION** on the function's parent schema
func (a *FunctionsAPI) Create(ctx context.Context, request CreateFunctionRequest) (*FunctionInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a function.
//
// Deletes the function that matches the supplied name. For the deletion to
// succeed, the user must satisfy one of the following conditions: - Is the
// owner of the function's parent catalog - Is the owner of the function's
// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
// Is the owner of the function itself and have both the **USE_CATALOG**
// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
// parent schema
func (a *FunctionsAPI) Delete(ctx context.Context, request DeleteFunctionRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a function.
//
// Deletes the function that matches the supplied name. For the deletion to
// succeed, the user must satisfy one of the following conditions: - Is the
// owner of the function's parent catalog - Is the owner of the function's
// parent schema and have the **USE_CATALOG** privilege on its parent catalog -
// Is the owner of the function itself and have both the **USE_CATALOG**
// privilege on its parent catalog and the **USE_SCHEMA** privilege on its
// parent schema
func (a *FunctionsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteFunctionRequest{
		Name: name,
	})
}

// Get a function.
//
// Gets a function from within a parent catalog and schema. For the fetch to
// succeed, the user must satisfy one of the following requirements: - Is a
// metastore admin - Is an owner of the function's parent catalog - Have the
// **USE_CATALOG** privilege on the function's parent catalog and be the owner
// of the function - Have the **USE_CATALOG** privilege on the function's parent
// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
// the **EXECUTE** privilege on the function itself
func (a *FunctionsAPI) Get(ctx context.Context, request GetFunctionRequest) (*FunctionInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a function.
//
// Gets a function from within a parent catalog and schema. For the fetch to
// succeed, the user must satisfy one of the following requirements: - Is a
// metastore admin - Is an owner of the function's parent catalog - Have the
// **USE_CATALOG** privilege on the function's parent catalog and be the owner
// of the function - Have the **USE_CATALOG** privilege on the function's parent
// catalog, the **USE_SCHEMA** privilege on the function's parent schema, and
// the **EXECUTE** privilege on the function itself
func (a *FunctionsAPI) GetByName(ctx context.Context, name string) (*FunctionInfo, error) {
	return a.impl.Get(ctx, GetFunctionRequest{
		Name: name,
	})
}

// List functions.
//
// List functions within the specified parent catalog and schema. If the user is
// a metastore admin, all functions are returned in the output list. Otherwise,
// the user must have the **USE_CATALOG** privilege on the catalog and the
// **USE_SCHEMA** privilege on the schema, and the output list contains only
// functions for which either the user has the **EXECUTE** privilege or the user
// is the owner. For unpaginated request, there is no guarantee of a specific
// ordering of the elements in the array. For paginated request, elements are
// ordered by their name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *FunctionsAPI) List(ctx context.Context, request ListFunctionsRequest) listing.Iterator[FunctionInfo] {

	getNextPage := func(ctx context.Context, req ListFunctionsRequest) (*ListFunctionsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListFunctionsResponse) []FunctionInfo {
		return resp.Functions
	}
	getNextReq := func(resp *ListFunctionsResponse) *ListFunctionsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List functions.
//
// List functions within the specified parent catalog and schema. If the user is
// a metastore admin, all functions are returned in the output list. Otherwise,
// the user must have the **USE_CATALOG** privilege on the catalog and the
// **USE_SCHEMA** privilege on the schema, and the output list contains only
// functions for which either the user has the **EXECUTE** privilege or the user
// is the owner. For unpaginated request, there is no guarantee of a specific
// ordering of the elements in the array. For paginated request, elements are
// ordered by their name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *FunctionsAPI) ListAll(ctx context.Context, request ListFunctionsRequest) ([]FunctionInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[FunctionInfo, int](ctx, iterator, request.MaxResults)

}

// FunctionInfoNameToFullNameMap calls [FunctionsAPI.ListAll] and creates a map of results with [FunctionInfo].Name as key and [FunctionInfo].FullName as value.
//
// Returns an error if there's more than one [FunctionInfo] with the same .Name.
//
// Note: All [FunctionInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *FunctionsAPI) FunctionInfoNameToFullNameMap(ctx context.Context, request ListFunctionsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

// Update a function.
//
// Updates the function that matches the supplied name. Only the owner of the
// function can be updated. If the user is not a metastore admin, the user must
// be a member of the group that is the new function owner. - Is a metastore
// admin - Is the owner of the function's parent catalog - Is the owner of the
// function's parent schema and has the **USE_CATALOG** privilege on its parent
// catalog - Is the owner of the function itself and has the **USE_CATALOG**
// privilege on its parent catalog as well as the **USE_SCHEMA** privilege on
// the function's parent schema.
func (a *FunctionsAPI) Update(ctx context.Context, request UpdateFunction) (*FunctionInfo, error) {
	return a.impl.Update(ctx, request)
}

type GrantsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockGrantsInterface instead.
	WithImpl(impl GrantsService) GrantsInterface

	// Impl returns low-level Grants API implementation
	// Deprecated: use MockGrantsInterface instead.
	Impl() GrantsService

	// Get permissions.
	//
	// Gets the permissions for a securable.
	Get(ctx context.Context, request GetGrantRequest) (*PermissionsList, error)

	// Get permissions.
	//
	// Gets the permissions for a securable.
	GetBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*PermissionsList, error)

	// Get effective permissions.
	//
	// Gets the effective permissions for a securable.
	GetEffective(ctx context.Context, request GetEffectiveRequest) (*EffectivePermissionsList, error)

	// Get effective permissions.
	//
	// Gets the effective permissions for a securable.
	GetEffectiveBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*EffectivePermissionsList, error)

	// Update permissions.
	//
	// Updates the permissions for a securable.
	Update(ctx context.Context, request UpdatePermissions) (*PermissionsList, error)
}

func NewGrants(client *client.DatabricksClient) *GrantsAPI {
	return &GrantsAPI{
		impl: &grantsImpl{
			client: client,
		},
	}
}

// In Unity Catalog, data is secure by default. Initially, users have no access
// to data in a metastore. Access can be granted by either a metastore admin,
// the owner of an object, or the owner of the catalog or schema that contains
// the object. Securable objects in Unity Catalog are hierarchical and
// privileges are inherited downward.
//
// Securable objects in Unity Catalog are hierarchical and privileges are
// inherited downward. This means that granting a privilege on the catalog
// automatically grants the privilege to all current and future objects within
// the catalog. Similarly, privileges granted on a schema are inherited by all
// current and future objects within that schema.
type GrantsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(GrantsService)
	impl GrantsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockGrantsInterface instead.
func (a *GrantsAPI) WithImpl(impl GrantsService) GrantsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Grants API implementation
// Deprecated: use MockGrantsInterface instead.
func (a *GrantsAPI) Impl() GrantsService {
	return a.impl
}

// Get permissions.
//
// Gets the permissions for a securable.
func (a *GrantsAPI) Get(ctx context.Context, request GetGrantRequest) (*PermissionsList, error) {
	return a.impl.Get(ctx, request)
}

// Get permissions.
//
// Gets the permissions for a securable.
func (a *GrantsAPI) GetBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*PermissionsList, error) {
	return a.impl.Get(ctx, GetGrantRequest{
		SecurableType: securableType,
		FullName:      fullName,
	})
}

// Get effective permissions.
//
// Gets the effective permissions for a securable.
func (a *GrantsAPI) GetEffective(ctx context.Context, request GetEffectiveRequest) (*EffectivePermissionsList, error) {
	return a.impl.GetEffective(ctx, request)
}

// Get effective permissions.
//
// Gets the effective permissions for a securable.
func (a *GrantsAPI) GetEffectiveBySecurableTypeAndFullName(ctx context.Context, securableType SecurableType, fullName string) (*EffectivePermissionsList, error) {
	return a.impl.GetEffective(ctx, GetEffectiveRequest{
		SecurableType: securableType,
		FullName:      fullName,
	})
}

// Update permissions.
//
// Updates the permissions for a securable.
func (a *GrantsAPI) Update(ctx context.Context, request UpdatePermissions) (*PermissionsList, error) {
	return a.impl.Update(ctx, request)
}

type LakehouseMonitorsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockLakehouseMonitorsInterface instead.
	WithImpl(impl LakehouseMonitorsService) LakehouseMonitorsInterface

	// Impl returns low-level LakehouseMonitors API implementation
	// Deprecated: use MockLakehouseMonitorsInterface instead.
	Impl() LakehouseMonitorsService

	// Cancel refresh.
	//
	// Cancel an active monitor refresh for the given refresh ID.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	CancelRefresh(ctx context.Context, request CancelRefreshRequest) error

	// Create a table monitor.
	//
	// Creates a new monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog, have
	// **USE_SCHEMA** on the table's parent schema, and have **SELECT** access on
	// the table 2. have **USE_CATALOG** on the table's parent catalog, be an owner
	// of the table's parent schema, and have **SELECT** access on the table. 3.
	// have the following permissions: - **USE_CATALOG** on the table's parent
	// catalog - **USE_SCHEMA** on the table's parent schema - be an owner of the
	// table.
	//
	// Workspace assets, such as the dashboard, will be created in the workspace
	// where this call was made.
	Create(ctx context.Context, request CreateMonitor) (*MonitorInfo, error)

	// Delete a table monitor.
	//
	// Deletes a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	//
	// Note that the metric tables and dashboard will not be deleted as part of this
	// call; those assets must be manually cleaned up (if desired).
	Delete(ctx context.Context, request DeleteLakehouseMonitorRequest) error

	// Delete a table monitor.
	//
	// Deletes a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	//
	// Note that the metric tables and dashboard will not be deleted as part of this
	// call; those assets must be manually cleaned up (if desired).
	DeleteByFullName(ctx context.Context, fullName string) error

	// Get a table monitor.
	//
	// Gets a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// The returned information includes configuration values, as well as
	// information on assets created by the monitor. Some information (e.g.,
	// dashboard) may be filtered out if the caller is in a different workspace than
	// where the monitor was created.
	Get(ctx context.Context, request GetLakehouseMonitorRequest) (*MonitorInfo, error)

	// Get a table monitor.
	//
	// Gets a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// The returned information includes configuration values, as well as
	// information on assets created by the monitor. Some information (e.g.,
	// dashboard) may be filtered out if the caller is in a different workspace than
	// where the monitor was created.
	GetByFullName(ctx context.Context, fullName string) (*MonitorInfo, error)

	// Get refresh.
	//
	// Gets info about a specific monitor refresh using the given refresh ID.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	GetRefresh(ctx context.Context, request GetRefreshRequest) (*MonitorRefreshInfo, error)

	// Get refresh.
	//
	// Gets info about a specific monitor refresh using the given refresh ID.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	GetRefreshByFullNameAndRefreshId(ctx context.Context, fullName string, refreshId string) (*MonitorRefreshInfo, error)

	// List refreshes.
	//
	// Gets an array containing the history of the most recent refreshes (up to 25)
	// for this table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	ListRefreshes(ctx context.Context, request ListRefreshesRequest) ([]MonitorRefreshInfo, error)

	// List refreshes.
	//
	// Gets an array containing the history of the most recent refreshes (up to 25)
	// for this table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
	// **SELECT** privilege on the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	ListRefreshesByFullName(ctx context.Context, fullName string) ([]MonitorRefreshInfo, error)

	// Queue a metric refresh for a monitor.
	//
	// Queues a metric refresh on the monitor for the specified table. The refresh
	// will execute in the background.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created.
	RunRefresh(ctx context.Context, request RunRefreshRequest) (*MonitorRefreshInfo, error)

	// Update a table monitor.
	//
	// Updates a monitor for the specified table.
	//
	// The caller must either: 1. be an owner of the table's parent catalog 2. have
	// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
	// parent schema 3. have the following permissions: - **USE_CATALOG** on the
	// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
	// owner of the table.
	//
	// Additionally, the call must be made from the workspace where the monitor was
	// created, and the caller must be the original creator of the monitor.
	//
	// Certain configuration fields, such as output asset identifiers, cannot be
	// updated.
	Update(ctx context.Context, request UpdateMonitor) (*MonitorInfo, error)
}

func NewLakehouseMonitors(client *client.DatabricksClient) *LakehouseMonitorsAPI {
	return &LakehouseMonitorsAPI{
		impl: &lakehouseMonitorsImpl{
			client: client,
		},
	}
}

// A monitor computes and monitors data or model quality metrics for a table
// over time. It generates metrics tables and a dashboard that you can use to
// monitor table health and set alerts.
//
// Most write operations require the user to be the owner of the table (or its
// parent schema or parent catalog). Viewing the dashboard, computed metrics, or
// monitor configuration only requires the user to have **SELECT** privileges on
// the table (along with **USE_SCHEMA** and **USE_CATALOG**).
type LakehouseMonitorsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(LakehouseMonitorsService)
	impl LakehouseMonitorsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockLakehouseMonitorsInterface instead.
func (a *LakehouseMonitorsAPI) WithImpl(impl LakehouseMonitorsService) LakehouseMonitorsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level LakehouseMonitors API implementation
// Deprecated: use MockLakehouseMonitorsInterface instead.
func (a *LakehouseMonitorsAPI) Impl() LakehouseMonitorsService {
	return a.impl
}

// Cancel refresh.
//
// Cancel an active monitor refresh for the given refresh ID.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
// owner of the table
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *LakehouseMonitorsAPI) CancelRefresh(ctx context.Context, request CancelRefreshRequest) error {
	return a.impl.CancelRefresh(ctx, request)
}

// Create a table monitor.
//
// Creates a new monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog, have
// **USE_SCHEMA** on the table's parent schema, and have **SELECT** access on
// the table 2. have **USE_CATALOG** on the table's parent catalog, be an owner
// of the table's parent schema, and have **SELECT** access on the table. 3.
// have the following permissions: - **USE_CATALOG** on the table's parent
// catalog - **USE_SCHEMA** on the table's parent schema - be an owner of the
// table.
//
// Workspace assets, such as the dashboard, will be created in the workspace
// where this call was made.
func (a *LakehouseMonitorsAPI) Create(ctx context.Context, request CreateMonitor) (*MonitorInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a table monitor.
//
// Deletes a monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
// owner of the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
//
// Note that the metric tables and dashboard will not be deleted as part of this
// call; those assets must be manually cleaned up (if desired).
func (a *LakehouseMonitorsAPI) Delete(ctx context.Context, request DeleteLakehouseMonitorRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a table monitor.
//
// Deletes a monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
// owner of the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
//
// Note that the metric tables and dashboard will not be deleted as part of this
// call; those assets must be manually cleaned up (if desired).
func (a *LakehouseMonitorsAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.impl.Delete(ctx, DeleteLakehouseMonitorRequest{
		FullName: fullName,
	})
}

// Get a table monitor.
//
// Gets a monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// The returned information includes configuration values, as well as
// information on assets created by the monitor. Some information (e.g.,
// dashboard) may be filtered out if the caller is in a different workspace than
// where the monitor was created.
func (a *LakehouseMonitorsAPI) Get(ctx context.Context, request GetLakehouseMonitorRequest) (*MonitorInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a table monitor.
//
// Gets a monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema. 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// The returned information includes configuration values, as well as
// information on assets created by the monitor. Some information (e.g.,
// dashboard) may be filtered out if the caller is in a different workspace than
// where the monitor was created.
func (a *LakehouseMonitorsAPI) GetByFullName(ctx context.Context, fullName string) (*MonitorInfo, error) {
	return a.impl.Get(ctx, GetLakehouseMonitorRequest{
		FullName: fullName,
	})
}

// Get refresh.
//
// Gets info about a specific monitor refresh using the given refresh ID.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *LakehouseMonitorsAPI) GetRefresh(ctx context.Context, request GetRefreshRequest) (*MonitorRefreshInfo, error) {
	return a.impl.GetRefresh(ctx, request)
}

// Get refresh.
//
// Gets info about a specific monitor refresh using the given refresh ID.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *LakehouseMonitorsAPI) GetRefreshByFullNameAndRefreshId(ctx context.Context, fullName string, refreshId string) (*MonitorRefreshInfo, error) {
	return a.impl.GetRefresh(ctx, GetRefreshRequest{
		FullName:  fullName,
		RefreshId: refreshId,
	})
}

// List refreshes.
//
// Gets an array containing the history of the most recent refreshes (up to 25)
// for this table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *LakehouseMonitorsAPI) ListRefreshes(ctx context.Context, request ListRefreshesRequest) ([]MonitorRefreshInfo, error) {
	return a.impl.ListRefreshes(ctx, request)
}

// List refreshes.
//
// Gets an array containing the history of the most recent refreshes (up to 25)
// for this table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema -
// **SELECT** privilege on the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *LakehouseMonitorsAPI) ListRefreshesByFullName(ctx context.Context, fullName string) ([]MonitorRefreshInfo, error) {
	return a.impl.ListRefreshes(ctx, ListRefreshesRequest{
		FullName: fullName,
	})
}

// Queue a metric refresh for a monitor.
//
// Queues a metric refresh on the monitor for the specified table. The refresh
// will execute in the background.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
// owner of the table
//
// Additionally, the call must be made from the workspace where the monitor was
// created.
func (a *LakehouseMonitorsAPI) RunRefresh(ctx context.Context, request RunRefreshRequest) (*MonitorRefreshInfo, error) {
	return a.impl.RunRefresh(ctx, request)
}

// Update a table monitor.
//
// Updates a monitor for the specified table.
//
// The caller must either: 1. be an owner of the table's parent catalog 2. have
// **USE_CATALOG** on the table's parent catalog and be an owner of the table's
// parent schema 3. have the following permissions: - **USE_CATALOG** on the
// table's parent catalog - **USE_SCHEMA** on the table's parent schema - be an
// owner of the table.
//
// Additionally, the call must be made from the workspace where the monitor was
// created, and the caller must be the original creator of the monitor.
//
// Certain configuration fields, such as output asset identifiers, cannot be
// updated.
func (a *LakehouseMonitorsAPI) Update(ctx context.Context, request UpdateMonitor) (*MonitorInfo, error) {
	return a.impl.Update(ctx, request)
}

type MetastoresInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockMetastoresInterface instead.
	WithImpl(impl MetastoresService) MetastoresInterface

	// Impl returns low-level Metastores API implementation
	// Deprecated: use MockMetastoresInterface instead.
	Impl() MetastoresService

	// Create an assignment.
	//
	// Creates a new metastore assignment. If an assignment for the same
	// __workspace_id__ exists, it will be overwritten by the new __metastore_id__
	// and __default_catalog_name__. The caller must be an account admin.
	Assign(ctx context.Context, request CreateMetastoreAssignment) error

	// Create a metastore.
	//
	// Creates a new metastore based on a provided name and optional storage root
	// path. By default (if the __owner__ field is not set), the owner of the new
	// metastore is the user calling the __createMetastore__ API. If the __owner__
	// field is set to the empty string (**""**), the ownership is assigned to the
	// System User instead.
	Create(ctx context.Context, request CreateMetastore) (*MetastoreInfo, error)

	// Get metastore assignment for workspace.
	//
	// Gets the metastore assignment for the workspace being accessed.
	Current(ctx context.Context) (*MetastoreAssignment, error)

	// Delete a metastore.
	//
	// Deletes a metastore. The caller must be a metastore admin.
	Delete(ctx context.Context, request DeleteMetastoreRequest) error

	// Delete a metastore.
	//
	// Deletes a metastore. The caller must be a metastore admin.
	DeleteById(ctx context.Context, id string) error

	// Get a metastore.
	//
	// Gets a metastore that matches the supplied ID. The caller must be a metastore
	// admin to retrieve this info.
	Get(ctx context.Context, request GetMetastoreRequest) (*MetastoreInfo, error)

	// Get a metastore.
	//
	// Gets a metastore that matches the supplied ID. The caller must be a metastore
	// admin to retrieve this info.
	GetById(ctx context.Context, id string) (*MetastoreInfo, error)

	// List metastores.
	//
	// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
	// caller must be an admin to retrieve this info. There is no guarantee of a
	// specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context) listing.Iterator[MetastoreInfo]

	// List metastores.
	//
	// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
	// caller must be an admin to retrieve this info. There is no guarantee of a
	// specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context) ([]MetastoreInfo, error)

	// MetastoreInfoNameToMetastoreIdMap calls [MetastoresAPI.ListAll] and creates a map of results with [MetastoreInfo].Name as key and [MetastoreInfo].MetastoreId as value.
	//
	// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
	//
	// Note: All [MetastoreInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	MetastoreInfoNameToMetastoreIdMap(ctx context.Context) (map[string]string, error)

	// GetByName calls [MetastoresAPI.MetastoreInfoNameToMetastoreIdMap] and returns a single [MetastoreInfo].
	//
	// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
	//
	// Note: All [MetastoreInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*MetastoreInfo, error)

	// Get a metastore summary.
	//
	// Gets information about a metastore. This summary includes the storage
	// credential, the cloud vendor, the cloud region, and the global metastore ID.
	Summary(ctx context.Context) (*GetMetastoreSummaryResponse, error)

	// Delete an assignment.
	//
	// Deletes a metastore assignment. The caller must be an account administrator.
	Unassign(ctx context.Context, request UnassignRequest) error

	// Delete an assignment.
	//
	// Deletes a metastore assignment. The caller must be an account administrator.
	UnassignByWorkspaceId(ctx context.Context, workspaceId int64) error

	// Update a metastore.
	//
	// Updates information for a specific metastore. The caller must be a metastore
	// admin. If the __owner__ field is set to the empty string (**""**), the
	// ownership is updated to the System User.
	Update(ctx context.Context, request UpdateMetastore) (*MetastoreInfo, error)

	// Update an assignment.
	//
	// Updates a metastore assignment. This operation can be used to update
	// __metastore_id__ or __default_catalog_name__ for a specified Workspace, if
	// the Workspace is already assigned a metastore. The caller must be an account
	// admin to update __metastore_id__; otherwise, the caller can be a Workspace
	// admin.
	UpdateAssignment(ctx context.Context, request UpdateMetastoreAssignment) error
}

func NewMetastores(client *client.DatabricksClient) *MetastoresAPI {
	return &MetastoresAPI{
		impl: &metastoresImpl{
			client: client,
		},
	}
}

// A metastore is the top-level container of objects in Unity Catalog. It stores
// data assets (tables and views) and the permissions that govern access to
// them. Databricks account admins can create metastores and assign them to
// Databricks workspaces to control which workloads use each metastore. For a
// workspace to use Unity Catalog, it must have a Unity Catalog metastore
// attached.
//
// Each metastore is configured with a root storage location in a cloud storage
// account. This storage location is used for metadata and managed tables data.
//
// NOTE: This metastore is distinct from the metastore included in Databricks
// workspaces created before Unity Catalog was released. If your workspace
// includes a legacy Hive metastore, the data in that metastore is available in
// a catalog named hive_metastore.
type MetastoresAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(MetastoresService)
	impl MetastoresService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockMetastoresInterface instead.
func (a *MetastoresAPI) WithImpl(impl MetastoresService) MetastoresInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Metastores API implementation
// Deprecated: use MockMetastoresInterface instead.
func (a *MetastoresAPI) Impl() MetastoresService {
	return a.impl
}

// Create an assignment.
//
// Creates a new metastore assignment. If an assignment for the same
// __workspace_id__ exists, it will be overwritten by the new __metastore_id__
// and __default_catalog_name__. The caller must be an account admin.
func (a *MetastoresAPI) Assign(ctx context.Context, request CreateMetastoreAssignment) error {
	return a.impl.Assign(ctx, request)
}

// Create a metastore.
//
// Creates a new metastore based on a provided name and optional storage root
// path. By default (if the __owner__ field is not set), the owner of the new
// metastore is the user calling the __createMetastore__ API. If the __owner__
// field is set to the empty string (**""**), the ownership is assigned to the
// System User instead.
func (a *MetastoresAPI) Create(ctx context.Context, request CreateMetastore) (*MetastoreInfo, error) {
	return a.impl.Create(ctx, request)
}

// Get metastore assignment for workspace.
//
// Gets the metastore assignment for the workspace being accessed.
func (a *MetastoresAPI) Current(ctx context.Context) (*MetastoreAssignment, error) {
	return a.impl.Current(ctx)
}

// Delete a metastore.
//
// Deletes a metastore. The caller must be a metastore admin.
func (a *MetastoresAPI) Delete(ctx context.Context, request DeleteMetastoreRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a metastore.
//
// Deletes a metastore. The caller must be a metastore admin.
func (a *MetastoresAPI) DeleteById(ctx context.Context, id string) error {
	return a.impl.Delete(ctx, DeleteMetastoreRequest{
		Id: id,
	})
}

// Get a metastore.
//
// Gets a metastore that matches the supplied ID. The caller must be a metastore
// admin to retrieve this info.
func (a *MetastoresAPI) Get(ctx context.Context, request GetMetastoreRequest) (*MetastoreInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a metastore.
//
// Gets a metastore that matches the supplied ID. The caller must be a metastore
// admin to retrieve this info.
func (a *MetastoresAPI) GetById(ctx context.Context, id string) (*MetastoreInfo, error) {
	return a.impl.Get(ctx, GetMetastoreRequest{
		Id: id,
	})
}

// List metastores.
//
// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
// caller must be an admin to retrieve this info. There is no guarantee of a
// specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *MetastoresAPI) List(ctx context.Context) listing.Iterator[MetastoreInfo] {
	request := struct{}{}

	getNextPage := func(ctx context.Context, req struct{}) (*ListMetastoresResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx)
	}
	getItems := func(resp *ListMetastoresResponse) []MetastoreInfo {
		return resp.Metastores
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List metastores.
//
// Gets an array of the available metastores (as __MetastoreInfo__ objects). The
// caller must be an admin to retrieve this info. There is no guarantee of a
// specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *MetastoresAPI) ListAll(ctx context.Context) ([]MetastoreInfo, error) {
	iterator := a.List(ctx)
	return listing.ToSlice[MetastoreInfo](ctx, iterator)
}

// MetastoreInfoNameToMetastoreIdMap calls [MetastoresAPI.ListAll] and creates a map of results with [MetastoreInfo].Name as key and [MetastoreInfo].MetastoreId as value.
//
// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
//
// Note: All [MetastoreInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *MetastoresAPI) MetastoreInfoNameToMetastoreIdMap(ctx context.Context) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.MetastoreId
	}
	return mapping, nil
}

// GetByName calls [MetastoresAPI.MetastoreInfoNameToMetastoreIdMap] and returns a single [MetastoreInfo].
//
// Returns an error if there's more than one [MetastoreInfo] with the same .Name.
//
// Note: All [MetastoreInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *MetastoresAPI) GetByName(ctx context.Context, name string) (*MetastoreInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx)
	if err != nil {
		return nil, err
	}
	tmp := map[string][]MetastoreInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("MetastoreInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of MetastoreInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Get a metastore summary.
//
// Gets information about a metastore. This summary includes the storage
// credential, the cloud vendor, the cloud region, and the global metastore ID.
func (a *MetastoresAPI) Summary(ctx context.Context) (*GetMetastoreSummaryResponse, error) {
	return a.impl.Summary(ctx)
}

// Delete an assignment.
//
// Deletes a metastore assignment. The caller must be an account administrator.
func (a *MetastoresAPI) Unassign(ctx context.Context, request UnassignRequest) error {
	return a.impl.Unassign(ctx, request)
}

// Delete an assignment.
//
// Deletes a metastore assignment. The caller must be an account administrator.
func (a *MetastoresAPI) UnassignByWorkspaceId(ctx context.Context, workspaceId int64) error {
	return a.impl.Unassign(ctx, UnassignRequest{
		WorkspaceId: workspaceId,
	})
}

// Update a metastore.
//
// Updates information for a specific metastore. The caller must be a metastore
// admin. If the __owner__ field is set to the empty string (**""**), the
// ownership is updated to the System User.
func (a *MetastoresAPI) Update(ctx context.Context, request UpdateMetastore) (*MetastoreInfo, error) {
	return a.impl.Update(ctx, request)
}

// Update an assignment.
//
// Updates a metastore assignment. This operation can be used to update
// __metastore_id__ or __default_catalog_name__ for a specified Workspace, if
// the Workspace is already assigned a metastore. The caller must be an account
// admin to update __metastore_id__; otherwise, the caller can be a Workspace
// admin.
func (a *MetastoresAPI) UpdateAssignment(ctx context.Context, request UpdateMetastoreAssignment) error {
	return a.impl.UpdateAssignment(ctx, request)
}

type ModelVersionsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockModelVersionsInterface instead.
	WithImpl(impl ModelVersionsService) ModelVersionsInterface

	// Impl returns low-level ModelVersions API implementation
	// Deprecated: use MockModelVersionsInterface instead.
	Impl() ModelVersionsService

	// Delete a Model Version.
	//
	// Deletes a model version from the specified registered model. Any aliases
	// assigned to the model version will also be deleted.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Delete(ctx context.Context, request DeleteModelVersionRequest) error

	// Delete a Model Version.
	//
	// Deletes a model version from the specified registered model. Any aliases
	// assigned to the model version will also be deleted.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteByFullNameAndVersion(ctx context.Context, fullName string, version int) error

	// Get a Model Version.
	//
	// Get a model version.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the parent registered model. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema.
	Get(ctx context.Context, request GetModelVersionRequest) (*RegisteredModelInfo, error)

	// Get a Model Version.
	//
	// Get a model version.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the parent registered model. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema.
	GetByFullNameAndVersion(ctx context.Context, fullName string, version int) (*RegisteredModelInfo, error)

	// Get Model Version By Alias.
	//
	// Get a model version by alias.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByAlias(ctx context.Context, request GetByAliasRequest) (*ModelVersionInfo, error)

	// Get Model Version By Alias.
	//
	// Get a model version by alias.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) (*ModelVersionInfo, error)

	// List Model Versions.
	//
	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListModelVersionsRequest) listing.Iterator[ModelVersionInfo]

	// List Model Versions.
	//
	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListModelVersionsRequest) ([]ModelVersionInfo, error)

	// List Model Versions.
	//
	// List model versions. You can list model versions under a particular schema,
	// or list all model versions in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the model versions. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// parent registered model to recieve the model versions in the response. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	ListByFullName(ctx context.Context, fullName string) (*ListModelVersionsResponse, error)

	// Update a Model Version.
	//
	// Updates the specified model version.
	//
	// The caller must be a metastore admin or an owner of the parent registered
	// model. For the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// Currently only the comment of the model version can be updated.
	Update(ctx context.Context, request UpdateModelVersionRequest) (*ModelVersionInfo, error)
}

func NewModelVersions(client *client.DatabricksClient) *ModelVersionsAPI {
	return &ModelVersionsAPI{
		impl: &modelVersionsImpl{
			client: client,
		},
	}
}

// Databricks provides a hosted version of MLflow Model Registry in Unity
// Catalog. Models in Unity Catalog provide centralized access control,
// auditing, lineage, and discovery of ML models across Databricks workspaces.
//
// This API reference documents the REST endpoints for managing model versions
// in Unity Catalog. For more details, see the [registered models API
// docs](/api/workspace/registeredmodels).
type ModelVersionsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(ModelVersionsService)
	impl ModelVersionsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockModelVersionsInterface instead.
func (a *ModelVersionsAPI) WithImpl(impl ModelVersionsService) ModelVersionsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level ModelVersions API implementation
// Deprecated: use MockModelVersionsInterface instead.
func (a *ModelVersionsAPI) Impl() ModelVersionsService {
	return a.impl
}

// Delete a Model Version.
//
// Deletes a model version from the specified registered model. Any aliases
// assigned to the model version will also be deleted.
//
// The caller must be a metastore admin or an owner of the parent registered
// model. For the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *ModelVersionsAPI) Delete(ctx context.Context, request DeleteModelVersionRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a Model Version.
//
// Deletes a model version from the specified registered model. Any aliases
// assigned to the model version will also be deleted.
//
// The caller must be a metastore admin or an owner of the parent registered
// model. For the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *ModelVersionsAPI) DeleteByFullNameAndVersion(ctx context.Context, fullName string, version int) error {
	return a.impl.Delete(ctx, DeleteModelVersionRequest{
		FullName: fullName,
		Version:  version,
	})
}

// Get a Model Version.
//
// Get a model version.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the parent registered model. For the latter case, the caller
// must also be the owner or have the **USE_CATALOG** privilege on the parent
// catalog and the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) Get(ctx context.Context, request GetModelVersionRequest) (*RegisteredModelInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a Model Version.
//
// Get a model version.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the parent registered model. For the latter case, the caller
// must also be the owner or have the **USE_CATALOG** privilege on the parent
// catalog and the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) GetByFullNameAndVersion(ctx context.Context, fullName string, version int) (*RegisteredModelInfo, error) {
	return a.impl.Get(ctx, GetModelVersionRequest{
		FullName: fullName,
		Version:  version,
	})
}

// Get Model Version By Alias.
//
// Get a model version by alias.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) GetByAlias(ctx context.Context, request GetByAliasRequest) (*ModelVersionInfo, error) {
	return a.impl.GetByAlias(ctx, request)
}

// Get Model Version By Alias.
//
// Get a model version by alias.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *ModelVersionsAPI) GetByAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) (*ModelVersionInfo, error) {
	return a.impl.GetByAlias(ctx, GetByAliasRequest{
		FullName: fullName,
		Alias:    alias,
	})
}

// List Model Versions.
//
// List model versions. You can list model versions under a particular schema,
// or list all model versions in the current metastore.
//
// The returned models are filtered based on the privileges of the calling user.
// For example, the metastore admin is able to list all the model versions. A
// regular user needs to be the owner or have the **EXECUTE** privilege on the
// parent registered model to recieve the model versions in the response. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
//
// There is no guarantee of a specific ordering of the elements in the response.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ModelVersionsAPI) List(ctx context.Context, request ListModelVersionsRequest) listing.Iterator[ModelVersionInfo] {

	getNextPage := func(ctx context.Context, req ListModelVersionsRequest) (*ListModelVersionsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListModelVersionsResponse) []ModelVersionInfo {
		return resp.ModelVersions
	}
	getNextReq := func(resp *ListModelVersionsResponse) *ListModelVersionsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List Model Versions.
//
// List model versions. You can list model versions under a particular schema,
// or list all model versions in the current metastore.
//
// The returned models are filtered based on the privileges of the calling user.
// For example, the metastore admin is able to list all the model versions. A
// regular user needs to be the owner or have the **EXECUTE** privilege on the
// parent registered model to recieve the model versions in the response. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
//
// There is no guarantee of a specific ordering of the elements in the response.
//
// This method is generated by Databricks SDK Code Generator.
func (a *ModelVersionsAPI) ListAll(ctx context.Context, request ListModelVersionsRequest) ([]ModelVersionInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[ModelVersionInfo, int](ctx, iterator, request.MaxResults)

}

// List Model Versions.
//
// List model versions. You can list model versions under a particular schema,
// or list all model versions in the current metastore.
//
// The returned models are filtered based on the privileges of the calling user.
// For example, the metastore admin is able to list all the model versions. A
// regular user needs to be the owner or have the **EXECUTE** privilege on the
// parent registered model to recieve the model versions in the response. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
//
// There is no guarantee of a specific ordering of the elements in the response.
func (a *ModelVersionsAPI) ListByFullName(ctx context.Context, fullName string) (*ListModelVersionsResponse, error) {
	return a.impl.List(ctx, ListModelVersionsRequest{
		FullName: fullName,
	})
}

// Update a Model Version.
//
// Updates the specified model version.
//
// The caller must be a metastore admin or an owner of the parent registered
// model. For the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
//
// Currently only the comment of the model version can be updated.
func (a *ModelVersionsAPI) Update(ctx context.Context, request UpdateModelVersionRequest) (*ModelVersionInfo, error) {
	return a.impl.Update(ctx, request)
}

type OnlineTablesInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockOnlineTablesInterface instead.
	WithImpl(impl OnlineTablesService) OnlineTablesInterface

	// Impl returns low-level OnlineTables API implementation
	// Deprecated: use MockOnlineTablesInterface instead.
	Impl() OnlineTablesService

	// Create an Online Table.
	//
	// Create a new Online Table.
	Create(ctx context.Context, request ViewData) (*OnlineTable, error)

	// Delete an Online Table.
	//
	// Delete an online table. Warning: This will delete all the data in the online
	// table. If the source Delta table was deleted or modified since this Online
	// Table was created, this will lose the data forever!
	Delete(ctx context.Context, request DeleteOnlineTableRequest) error

	// Delete an Online Table.
	//
	// Delete an online table. Warning: This will delete all the data in the online
	// table. If the source Delta table was deleted or modified since this Online
	// Table was created, this will lose the data forever!
	DeleteByName(ctx context.Context, name string) error

	// Get an Online Table.
	//
	// Get information about an existing online table and its status.
	Get(ctx context.Context, request GetOnlineTableRequest) (*OnlineTable, error)

	// Get an Online Table.
	//
	// Get information about an existing online table and its status.
	GetByName(ctx context.Context, name string) (*OnlineTable, error)
}

func NewOnlineTables(client *client.DatabricksClient) *OnlineTablesAPI {
	return &OnlineTablesAPI{
		impl: &onlineTablesImpl{
			client: client,
		},
	}
}

// Online tables provide lower latency and higher QPS access to data from Delta
// tables.
type OnlineTablesAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(OnlineTablesService)
	impl OnlineTablesService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockOnlineTablesInterface instead.
func (a *OnlineTablesAPI) WithImpl(impl OnlineTablesService) OnlineTablesInterface {
	a.impl = impl
	return a
}

// Impl returns low-level OnlineTables API implementation
// Deprecated: use MockOnlineTablesInterface instead.
func (a *OnlineTablesAPI) Impl() OnlineTablesService {
	return a.impl
}

// Create an Online Table.
//
// Create a new Online Table.
func (a *OnlineTablesAPI) Create(ctx context.Context, request ViewData) (*OnlineTable, error) {
	return a.impl.Create(ctx, request)
}

// Delete an Online Table.
//
// Delete an online table. Warning: This will delete all the data in the online
// table. If the source Delta table was deleted or modified since this Online
// Table was created, this will lose the data forever!
func (a *OnlineTablesAPI) Delete(ctx context.Context, request DeleteOnlineTableRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete an Online Table.
//
// Delete an online table. Warning: This will delete all the data in the online
// table. If the source Delta table was deleted or modified since this Online
// Table was created, this will lose the data forever!
func (a *OnlineTablesAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteOnlineTableRequest{
		Name: name,
	})
}

// Get an Online Table.
//
// Get information about an existing online table and its status.
func (a *OnlineTablesAPI) Get(ctx context.Context, request GetOnlineTableRequest) (*OnlineTable, error) {
	return a.impl.Get(ctx, request)
}

// Get an Online Table.
//
// Get information about an existing online table and its status.
func (a *OnlineTablesAPI) GetByName(ctx context.Context, name string) (*OnlineTable, error) {
	return a.impl.Get(ctx, GetOnlineTableRequest{
		Name: name,
	})
}

type RegisteredModelsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockRegisteredModelsInterface instead.
	WithImpl(impl RegisteredModelsService) RegisteredModelsInterface

	// Impl returns low-level RegisteredModels API implementation
	// Deprecated: use MockRegisteredModelsInterface instead.
	Impl() RegisteredModelsService

	// Create a Registered Model.
	//
	// Creates a new registered model in Unity Catalog.
	//
	// File storage for model versions in the registered model will be located in
	// the default location which is specified by the parent schema, or the parent
	// catalog, or the Metastore.
	//
	// For registered model creation to succeed, the user must satisfy the following
	// conditions: - The caller must be a metastore admin, or be the owner of the
	// parent catalog and schema, or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
	// caller must have the **CREATE MODEL** or **CREATE FUNCTION** privilege on the
	// parent schema.
	Create(ctx context.Context, request CreateRegisteredModelRequest) (*RegisteredModelInfo, error)

	// Delete a Registered Model.
	//
	// Deletes a registered model and all its model versions from the specified
	// parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Delete(ctx context.Context, request DeleteRegisteredModelRequest) error

	// Delete a Registered Model.
	//
	// Deletes a registered model and all its model versions from the specified
	// parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Delete a Registered Model Alias.
	//
	// Deletes a registered model alias.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteAlias(ctx context.Context, request DeleteAliasRequest) error

	// Delete a Registered Model Alias.
	//
	// Deletes a registered model alias.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	DeleteAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) error

	// Get a Registered Model.
	//
	// Get a registered model.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	Get(ctx context.Context, request GetRegisteredModelRequest) (*RegisteredModelInfo, error)

	// Get a Registered Model.
	//
	// Get a registered model.
	//
	// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
	// privilege on) the registered model. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	GetByFullName(ctx context.Context, fullName string) (*RegisteredModelInfo, error)

	// List Registered Models.
	//
	// List registered models. You can list registered models under a particular
	// schema, or list all registered models in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the registered models. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// registered model to recieve the registered models in the response. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListRegisteredModelsRequest) listing.Iterator[RegisteredModelInfo]

	// List Registered Models.
	//
	// List registered models. You can list registered models under a particular
	// schema, or list all registered models in the current metastore.
	//
	// The returned models are filtered based on the privileges of the calling user.
	// For example, the metastore admin is able to list all the registered models. A
	// regular user needs to be the owner or have the **EXECUTE** privilege on the
	// registered model to recieve the registered models in the response. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the response.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListRegisteredModelsRequest) ([]RegisteredModelInfo, error)

	// RegisteredModelInfoNameToFullNameMap calls [RegisteredModelsAPI.ListAll] and creates a map of results with [RegisteredModelInfo].Name as key and [RegisteredModelInfo].FullName as value.
	//
	// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
	//
	// Note: All [RegisteredModelInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	RegisteredModelInfoNameToFullNameMap(ctx context.Context, request ListRegisteredModelsRequest) (map[string]string, error)

	// GetByName calls [RegisteredModelsAPI.RegisteredModelInfoNameToFullNameMap] and returns a single [RegisteredModelInfo].
	//
	// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
	//
	// Note: All [RegisteredModelInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*RegisteredModelInfo, error)

	// Set a Registered Model Alias.
	//
	// Set an alias on the specified registered model.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	SetAlias(ctx context.Context, request SetRegisteredModelAliasRequest) (*RegisteredModelAlias, error)

	// Update a Registered Model.
	//
	// Updates the specified registered model.
	//
	// The caller must be a metastore admin or an owner of the registered model. For
	// the latter case, the caller must also be the owner or have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	//
	// Currently only the name, the owner or the comment of the registered model can
	// be updated.
	Update(ctx context.Context, request UpdateRegisteredModelRequest) (*RegisteredModelInfo, error)
}

func NewRegisteredModels(client *client.DatabricksClient) *RegisteredModelsAPI {
	return &RegisteredModelsAPI{
		impl: &registeredModelsImpl{
			client: client,
		},
	}
}

// Databricks provides a hosted version of MLflow Model Registry in Unity
// Catalog. Models in Unity Catalog provide centralized access control,
// auditing, lineage, and discovery of ML models across Databricks workspaces.
//
// An MLflow registered model resides in the third layer of Unity Catalog’s
// three-level namespace. Registered models contain model versions, which
// correspond to actual ML models (MLflow models). Creating new model versions
// currently requires use of the MLflow Python client. Once model versions are
// created, you can load them for batch inference using MLflow Python client
// APIs, or deploy them for real-time serving using Databricks Model Serving.
//
// All operations on registered models and model versions require USE_CATALOG
// permissions on the enclosing catalog and USE_SCHEMA permissions on the
// enclosing schema. In addition, the following additional privileges are
// required for various operations:
//
// * To create a registered model, users must additionally have the CREATE_MODEL
// permission on the target schema. * To view registered model or model version
// metadata, model version data files, or invoke a model version, users must
// additionally have the EXECUTE permission on the registered model * To update
// registered model or model version tags, users must additionally have APPLY
// TAG permissions on the registered model * To update other registered model or
// model version metadata (comments, aliases) create a new model version, or
// update permissions on the registered model, users must be owners of the
// registered model.
//
// Note: The securable type for models is "FUNCTION". When using REST APIs (e.g.
// tagging, grants) that specify a securable type, use "FUNCTION" as the
// securable type.
type RegisteredModelsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(RegisteredModelsService)
	impl RegisteredModelsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockRegisteredModelsInterface instead.
func (a *RegisteredModelsAPI) WithImpl(impl RegisteredModelsService) RegisteredModelsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level RegisteredModels API implementation
// Deprecated: use MockRegisteredModelsInterface instead.
func (a *RegisteredModelsAPI) Impl() RegisteredModelsService {
	return a.impl
}

// Create a Registered Model.
//
// Creates a new registered model in Unity Catalog.
//
// File storage for model versions in the registered model will be located in
// the default location which is specified by the parent schema, or the parent
// catalog, or the Metastore.
//
// For registered model creation to succeed, the user must satisfy the following
// conditions: - The caller must be a metastore admin, or be the owner of the
// parent catalog and schema, or have the **USE_CATALOG** privilege on the
// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
// caller must have the **CREATE MODEL** or **CREATE FUNCTION** privilege on the
// parent schema.
func (a *RegisteredModelsAPI) Create(ctx context.Context, request CreateRegisteredModelRequest) (*RegisteredModelInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a Registered Model.
//
// Deletes a registered model and all its model versions from the specified
// parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) Delete(ctx context.Context, request DeleteRegisteredModelRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a Registered Model.
//
// Deletes a registered model and all its model versions from the specified
// parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.impl.Delete(ctx, DeleteRegisteredModelRequest{
		FullName: fullName,
	})
}

// Delete a Registered Model Alias.
//
// Deletes a registered model alias.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) DeleteAlias(ctx context.Context, request DeleteAliasRequest) error {
	return a.impl.DeleteAlias(ctx, request)
}

// Delete a Registered Model Alias.
//
// Deletes a registered model alias.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) DeleteAliasByFullNameAndAlias(ctx context.Context, fullName string, alias string) error {
	return a.impl.DeleteAlias(ctx, DeleteAliasRequest{
		FullName: fullName,
		Alias:    alias,
	})
}

// Get a Registered Model.
//
// Get a registered model.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *RegisteredModelsAPI) Get(ctx context.Context, request GetRegisteredModelRequest) (*RegisteredModelInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a Registered Model.
//
// Get a registered model.
//
// The caller must be a metastore admin or an owner of (or have the **EXECUTE**
// privilege on) the registered model. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *RegisteredModelsAPI) GetByFullName(ctx context.Context, fullName string) (*RegisteredModelInfo, error) {
	return a.impl.Get(ctx, GetRegisteredModelRequest{
		FullName: fullName,
	})
}

// List Registered Models.
//
// List registered models. You can list registered models under a particular
// schema, or list all registered models in the current metastore.
//
// The returned models are filtered based on the privileges of the calling user.
// For example, the metastore admin is able to list all the registered models. A
// regular user needs to be the owner or have the **EXECUTE** privilege on the
// registered model to recieve the registered models in the response. For the
// latter case, the caller must also be the owner or have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema.
//
// There is no guarantee of a specific ordering of the elements in the response.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) List(ctx context.Context, request ListRegisteredModelsRequest) listing.Iterator[RegisteredModelInfo] {

	getNextPage := func(ctx context.Context, req ListRegisteredModelsRequest) (*ListRegisteredModelsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListRegisteredModelsResponse) []RegisteredModelInfo {
		return resp.RegisteredModels
	}
	getNextReq := func(resp *ListRegisteredModelsResponse) *ListRegisteredModelsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List Registered Models.
//
// List registered models. You can list registered models under a particular
// schema, or list all registered models in the current metastore.
//
// The returned models are filtered based on the privileges of the calling user.
// For example, the metastore admin is able to list all the registered models. A
// regular user needs to be the owner or have the **EXECUTE** privilege on the
// registered model to recieve the registered models in the response. For the
// latter case, the caller must also be the owner or have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema.
//
// There is no guarantee of a specific ordering of the elements in the response.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) ListAll(ctx context.Context, request ListRegisteredModelsRequest) ([]RegisteredModelInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[RegisteredModelInfo, int](ctx, iterator, request.MaxResults)

}

// RegisteredModelInfoNameToFullNameMap calls [RegisteredModelsAPI.ListAll] and creates a map of results with [RegisteredModelInfo].Name as key and [RegisteredModelInfo].FullName as value.
//
// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
//
// Note: All [RegisteredModelInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) RegisteredModelInfoNameToFullNameMap(ctx context.Context, request ListRegisteredModelsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

// GetByName calls [RegisteredModelsAPI.RegisteredModelInfoNameToFullNameMap] and returns a single [RegisteredModelInfo].
//
// Returns an error if there's more than one [RegisteredModelInfo] with the same .Name.
//
// Note: All [RegisteredModelInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *RegisteredModelsAPI) GetByName(ctx context.Context, name string) (*RegisteredModelInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListRegisteredModelsRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]RegisteredModelInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("RegisteredModelInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of RegisteredModelInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Set a Registered Model Alias.
//
// Set an alias on the specified registered model.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *RegisteredModelsAPI) SetAlias(ctx context.Context, request SetRegisteredModelAliasRequest) (*RegisteredModelAlias, error) {
	return a.impl.SetAlias(ctx, request)
}

// Update a Registered Model.
//
// Updates the specified registered model.
//
// The caller must be a metastore admin or an owner of the registered model. For
// the latter case, the caller must also be the owner or have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
//
// Currently only the name, the owner or the comment of the registered model can
// be updated.
func (a *RegisteredModelsAPI) Update(ctx context.Context, request UpdateRegisteredModelRequest) (*RegisteredModelInfo, error) {
	return a.impl.Update(ctx, request)
}

type SchemasInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockSchemasInterface instead.
	WithImpl(impl SchemasService) SchemasInterface

	// Impl returns low-level Schemas API implementation
	// Deprecated: use MockSchemasInterface instead.
	Impl() SchemasService

	// Create a schema.
	//
	// Creates a new schema for catalog in the Metatastore. The caller must be a
	// metastore admin, or have the **CREATE_SCHEMA** privilege in the parent
	// catalog.
	Create(ctx context.Context, request CreateSchema) (*SchemaInfo, error)

	// Delete a schema.
	//
	// Deletes the specified schema from the parent catalog. The caller must be the
	// owner of the schema or an owner of the parent catalog.
	Delete(ctx context.Context, request DeleteSchemaRequest) error

	// Delete a schema.
	//
	// Deletes the specified schema from the parent catalog. The caller must be the
	// owner of the schema or an owner of the parent catalog.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Get a schema.
	//
	// Gets the specified schema within the metastore. The caller must be a
	// metastore admin, the owner of the schema, or a user that has the
	// **USE_SCHEMA** privilege on the schema.
	Get(ctx context.Context, request GetSchemaRequest) (*SchemaInfo, error)

	// Get a schema.
	//
	// Gets the specified schema within the metastore. The caller must be a
	// metastore admin, the owner of the schema, or a user that has the
	// **USE_SCHEMA** privilege on the schema.
	GetByFullName(ctx context.Context, fullName string) (*SchemaInfo, error)

	// List schemas.
	//
	// Gets an array of schemas for a catalog in the metastore. If the caller is the
	// metastore admin or the owner of the parent catalog, all schemas for the
	// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
	// for which the caller has the **USE_SCHEMA** privilege) will be retrieved. For
	// unpaginated request, there is no guarantee of a specific ordering of the
	// elements in the array. For paginated request, elements are ordered by their
	// name.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListSchemasRequest) listing.Iterator[SchemaInfo]

	// List schemas.
	//
	// Gets an array of schemas for a catalog in the metastore. If the caller is the
	// metastore admin or the owner of the parent catalog, all schemas for the
	// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
	// for which the caller has the **USE_SCHEMA** privilege) will be retrieved. For
	// unpaginated request, there is no guarantee of a specific ordering of the
	// elements in the array. For paginated request, elements are ordered by their
	// name.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListSchemasRequest) ([]SchemaInfo, error)

	// SchemaInfoNameToFullNameMap calls [SchemasAPI.ListAll] and creates a map of results with [SchemaInfo].Name as key and [SchemaInfo].FullName as value.
	//
	// Returns an error if there's more than one [SchemaInfo] with the same .Name.
	//
	// Note: All [SchemaInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	SchemaInfoNameToFullNameMap(ctx context.Context, request ListSchemasRequest) (map[string]string, error)

	// GetByName calls [SchemasAPI.SchemaInfoNameToFullNameMap] and returns a single [SchemaInfo].
	//
	// Returns an error if there's more than one [SchemaInfo] with the same .Name.
	//
	// Note: All [SchemaInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*SchemaInfo, error)

	// Update a schema.
	//
	// Updates a schema for a catalog. The caller must be the owner of the schema or
	// a metastore admin. If the caller is a metastore admin, only the __owner__
	// field can be changed in the update. If the __name__ field must be updated,
	// the caller must be a metastore admin or have the **CREATE_SCHEMA** privilege
	// on the parent catalog.
	Update(ctx context.Context, request UpdateSchema) (*SchemaInfo, error)
}

func NewSchemas(client *client.DatabricksClient) *SchemasAPI {
	return &SchemasAPI{
		impl: &schemasImpl{
			client: client,
		},
	}
}

// A schema (also called a database) is the second layer of Unity Catalog’s
// three-level namespace. A schema organizes tables, views and functions. To
// access (or list) a table or view in a schema, users must have the USE_SCHEMA
// data permission on the schema and its parent catalog, and they must have the
// SELECT permission on the table or view.
type SchemasAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(SchemasService)
	impl SchemasService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockSchemasInterface instead.
func (a *SchemasAPI) WithImpl(impl SchemasService) SchemasInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Schemas API implementation
// Deprecated: use MockSchemasInterface instead.
func (a *SchemasAPI) Impl() SchemasService {
	return a.impl
}

// Create a schema.
//
// Creates a new schema for catalog in the Metatastore. The caller must be a
// metastore admin, or have the **CREATE_SCHEMA** privilege in the parent
// catalog.
func (a *SchemasAPI) Create(ctx context.Context, request CreateSchema) (*SchemaInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a schema.
//
// Deletes the specified schema from the parent catalog. The caller must be the
// owner of the schema or an owner of the parent catalog.
func (a *SchemasAPI) Delete(ctx context.Context, request DeleteSchemaRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a schema.
//
// Deletes the specified schema from the parent catalog. The caller must be the
// owner of the schema or an owner of the parent catalog.
func (a *SchemasAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.impl.Delete(ctx, DeleteSchemaRequest{
		FullName: fullName,
	})
}

// Get a schema.
//
// Gets the specified schema within the metastore. The caller must be a
// metastore admin, the owner of the schema, or a user that has the
// **USE_SCHEMA** privilege on the schema.
func (a *SchemasAPI) Get(ctx context.Context, request GetSchemaRequest) (*SchemaInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a schema.
//
// Gets the specified schema within the metastore. The caller must be a
// metastore admin, the owner of the schema, or a user that has the
// **USE_SCHEMA** privilege on the schema.
func (a *SchemasAPI) GetByFullName(ctx context.Context, fullName string) (*SchemaInfo, error) {
	return a.impl.Get(ctx, GetSchemaRequest{
		FullName: fullName,
	})
}

// List schemas.
//
// Gets an array of schemas for a catalog in the metastore. If the caller is the
// metastore admin or the owner of the parent catalog, all schemas for the
// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
// for which the caller has the **USE_SCHEMA** privilege) will be retrieved. For
// unpaginated request, there is no guarantee of a specific ordering of the
// elements in the array. For paginated request, elements are ordered by their
// name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SchemasAPI) List(ctx context.Context, request ListSchemasRequest) listing.Iterator[SchemaInfo] {

	getNextPage := func(ctx context.Context, req ListSchemasRequest) (*ListSchemasResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListSchemasResponse) []SchemaInfo {
		return resp.Schemas
	}
	getNextReq := func(resp *ListSchemasResponse) *ListSchemasRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List schemas.
//
// Gets an array of schemas for a catalog in the metastore. If the caller is the
// metastore admin or the owner of the parent catalog, all schemas for the
// catalog will be retrieved. Otherwise, only schemas owned by the caller (or
// for which the caller has the **USE_SCHEMA** privilege) will be retrieved. For
// unpaginated request, there is no guarantee of a specific ordering of the
// elements in the array. For paginated request, elements are ordered by their
// name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SchemasAPI) ListAll(ctx context.Context, request ListSchemasRequest) ([]SchemaInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[SchemaInfo, int](ctx, iterator, request.MaxResults)

}

// SchemaInfoNameToFullNameMap calls [SchemasAPI.ListAll] and creates a map of results with [SchemaInfo].Name as key and [SchemaInfo].FullName as value.
//
// Returns an error if there's more than one [SchemaInfo] with the same .Name.
//
// Note: All [SchemaInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SchemasAPI) SchemaInfoNameToFullNameMap(ctx context.Context, request ListSchemasRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.FullName
	}
	return mapping, nil
}

// GetByName calls [SchemasAPI.SchemaInfoNameToFullNameMap] and returns a single [SchemaInfo].
//
// Returns an error if there's more than one [SchemaInfo] with the same .Name.
//
// Note: All [SchemaInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SchemasAPI) GetByName(ctx context.Context, name string) (*SchemaInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListSchemasRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]SchemaInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("SchemaInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of SchemaInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Update a schema.
//
// Updates a schema for a catalog. The caller must be the owner of the schema or
// a metastore admin. If the caller is a metastore admin, only the __owner__
// field can be changed in the update. If the __name__ field must be updated,
// the caller must be a metastore admin or have the **CREATE_SCHEMA** privilege
// on the parent catalog.
func (a *SchemasAPI) Update(ctx context.Context, request UpdateSchema) (*SchemaInfo, error) {
	return a.impl.Update(ctx, request)
}

type StorageCredentialsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockStorageCredentialsInterface instead.
	WithImpl(impl StorageCredentialsService) StorageCredentialsInterface

	// Impl returns low-level StorageCredentials API implementation
	// Deprecated: use MockStorageCredentialsInterface instead.
	Impl() StorageCredentialsService

	// Create a storage credential.
	//
	// Creates a new storage credential.
	Create(ctx context.Context, request CreateStorageCredential) (*StorageCredentialInfo, error)

	// Delete a credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	Delete(ctx context.Context, request DeleteStorageCredentialRequest) error

	// Delete a credential.
	//
	// Deletes a storage credential from the metastore. The caller must be an owner
	// of the storage credential.
	DeleteByName(ctx context.Context, name string) error

	// Get a credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have some permission on the
	// storage credential.
	Get(ctx context.Context, request GetStorageCredentialRequest) (*StorageCredentialInfo, error)

	// Get a credential.
	//
	// Gets a storage credential from the metastore. The caller must be a metastore
	// admin, the owner of the storage credential, or have some permission on the
	// storage credential.
	GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error)

	// List credentials.
	//
	// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
	// The array is limited to only those storage credentials the caller has
	// permission to access. If the caller is a metastore admin, retrieval of
	// credentials is unrestricted. For unpaginated request, there is no guarantee
	// of a specific ordering of the elements in the array. For paginated request,
	// elements are ordered by their name.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListStorageCredentialsRequest) listing.Iterator[StorageCredentialInfo]

	// List credentials.
	//
	// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
	// The array is limited to only those storage credentials the caller has
	// permission to access. If the caller is a metastore admin, retrieval of
	// credentials is unrestricted. For unpaginated request, there is no guarantee
	// of a specific ordering of the elements in the array. For paginated request,
	// elements are ordered by their name.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListStorageCredentialsRequest) ([]StorageCredentialInfo, error)

	// StorageCredentialInfoNameToIdMap calls [StorageCredentialsAPI.ListAll] and creates a map of results with [StorageCredentialInfo].Name as key and [StorageCredentialInfo].Id as value.
	//
	// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
	//
	// Note: All [StorageCredentialInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	StorageCredentialInfoNameToIdMap(ctx context.Context, request ListStorageCredentialsRequest) (map[string]string, error)

	// Update a credential.
	//
	// Updates a storage credential on the metastore.
	Update(ctx context.Context, request UpdateStorageCredential) (*StorageCredentialInfo, error)

	// Validate a storage credential.
	//
	// Validates a storage credential. At least one of __external_location_name__
	// and __url__ need to be provided. If only one of them is provided, it will be
	// used for validation. And if both are provided, the __url__ will be used for
	// validation, and __external_location_name__ will be ignored when checking
	// overlapping urls.
	//
	// Either the __storage_credential_name__ or the cloud-specific credential must
	// be provided.
	//
	// The caller must be a metastore admin or the storage credential owner or have
	// the **CREATE_EXTERNAL_LOCATION** privilege on the metastore and the storage
	// credential.
	Validate(ctx context.Context, request ValidateStorageCredential) (*ValidateStorageCredentialResponse, error)
}

func NewStorageCredentials(client *client.DatabricksClient) *StorageCredentialsAPI {
	return &StorageCredentialsAPI{
		impl: &storageCredentialsImpl{
			client: client,
		},
	}
}

// A storage credential represents an authentication and authorization mechanism
// for accessing data stored on your cloud tenant. Each storage credential is
// subject to Unity Catalog access-control policies that control which users and
// groups can access the credential. If a user does not have access to a storage
// credential in Unity Catalog, the request fails and Unity Catalog does not
// attempt to authenticate to your cloud tenant on the user’s behalf.
//
// Databricks recommends using external locations rather than using storage
// credentials directly.
//
// To create storage credentials, you must be a Databricks account admin. The
// account admin who creates the storage credential can delegate ownership to
// another user or group to manage permissions on it.
type StorageCredentialsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(StorageCredentialsService)
	impl StorageCredentialsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockStorageCredentialsInterface instead.
func (a *StorageCredentialsAPI) WithImpl(impl StorageCredentialsService) StorageCredentialsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level StorageCredentials API implementation
// Deprecated: use MockStorageCredentialsInterface instead.
func (a *StorageCredentialsAPI) Impl() StorageCredentialsService {
	return a.impl
}

// Create a storage credential.
//
// Creates a new storage credential.
func (a *StorageCredentialsAPI) Create(ctx context.Context, request CreateStorageCredential) (*StorageCredentialInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a credential.
//
// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *StorageCredentialsAPI) Delete(ctx context.Context, request DeleteStorageCredentialRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a credential.
//
// Deletes a storage credential from the metastore. The caller must be an owner
// of the storage credential.
func (a *StorageCredentialsAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteStorageCredentialRequest{
		Name: name,
	})
}

// Get a credential.
//
// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have some permission on the
// storage credential.
func (a *StorageCredentialsAPI) Get(ctx context.Context, request GetStorageCredentialRequest) (*StorageCredentialInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a credential.
//
// Gets a storage credential from the metastore. The caller must be a metastore
// admin, the owner of the storage credential, or have some permission on the
// storage credential.
func (a *StorageCredentialsAPI) GetByName(ctx context.Context, name string) (*StorageCredentialInfo, error) {
	return a.impl.Get(ctx, GetStorageCredentialRequest{
		Name: name,
	})
}

// List credentials.
//
// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
// The array is limited to only those storage credentials the caller has
// permission to access. If the caller is a metastore admin, retrieval of
// credentials is unrestricted. For unpaginated request, there is no guarantee
// of a specific ordering of the elements in the array. For paginated request,
// elements are ordered by their name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *StorageCredentialsAPI) List(ctx context.Context, request ListStorageCredentialsRequest) listing.Iterator[StorageCredentialInfo] {

	getNextPage := func(ctx context.Context, req ListStorageCredentialsRequest) (*ListStorageCredentialsResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListStorageCredentialsResponse) []StorageCredentialInfo {
		return resp.StorageCredentials
	}
	getNextReq := func(resp *ListStorageCredentialsResponse) *ListStorageCredentialsRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List credentials.
//
// Gets an array of storage credentials (as __StorageCredentialInfo__ objects).
// The array is limited to only those storage credentials the caller has
// permission to access. If the caller is a metastore admin, retrieval of
// credentials is unrestricted. For unpaginated request, there is no guarantee
// of a specific ordering of the elements in the array. For paginated request,
// elements are ordered by their name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *StorageCredentialsAPI) ListAll(ctx context.Context, request ListStorageCredentialsRequest) ([]StorageCredentialInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[StorageCredentialInfo, int](ctx, iterator, request.MaxResults)

}

// StorageCredentialInfoNameToIdMap calls [StorageCredentialsAPI.ListAll] and creates a map of results with [StorageCredentialInfo].Name as key and [StorageCredentialInfo].Id as value.
//
// Returns an error if there's more than one [StorageCredentialInfo] with the same .Name.
//
// Note: All [StorageCredentialInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *StorageCredentialsAPI) StorageCredentialInfoNameToIdMap(ctx context.Context, request ListStorageCredentialsRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.Id
	}
	return mapping, nil
}

// Update a credential.
//
// Updates a storage credential on the metastore.
func (a *StorageCredentialsAPI) Update(ctx context.Context, request UpdateStorageCredential) (*StorageCredentialInfo, error) {
	return a.impl.Update(ctx, request)
}

// Validate a storage credential.
//
// Validates a storage credential. At least one of __external_location_name__
// and __url__ need to be provided. If only one of them is provided, it will be
// used for validation. And if both are provided, the __url__ will be used for
// validation, and __external_location_name__ will be ignored when checking
// overlapping urls.
//
// Either the __storage_credential_name__ or the cloud-specific credential must
// be provided.
//
// The caller must be a metastore admin or the storage credential owner or have
// the **CREATE_EXTERNAL_LOCATION** privilege on the metastore and the storage
// credential.
func (a *StorageCredentialsAPI) Validate(ctx context.Context, request ValidateStorageCredential) (*ValidateStorageCredentialResponse, error) {
	return a.impl.Validate(ctx, request)
}

type SystemSchemasInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockSystemSchemasInterface instead.
	WithImpl(impl SystemSchemasService) SystemSchemasInterface

	// Impl returns low-level SystemSchemas API implementation
	// Deprecated: use MockSystemSchemasInterface instead.
	Impl() SystemSchemasService

	// Disable a system schema.
	//
	// Disables the system schema and removes it from the system catalog. The caller
	// must be an account admin or a metastore admin.
	Disable(ctx context.Context, request DisableRequest) error

	// Disable a system schema.
	//
	// Disables the system schema and removes it from the system catalog. The caller
	// must be an account admin or a metastore admin.
	DisableByMetastoreIdAndSchemaName(ctx context.Context, metastoreId string, schemaName DisableSchemaName) error

	// Enable a system schema.
	//
	// Enables the system schema and adds it to the system catalog. The caller must
	// be an account admin or a metastore admin.
	Enable(ctx context.Context, request EnableRequest) error

	// List system schemas.
	//
	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListSystemSchemasRequest) listing.Iterator[SystemSchemaInfo]

	// List system schemas.
	//
	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListSystemSchemasRequest) ([]SystemSchemaInfo, error)

	// List system schemas.
	//
	// Gets an array of system schemas for a metastore. The caller must be an
	// account admin or a metastore admin.
	ListByMetastoreId(ctx context.Context, metastoreId string) (*ListSystemSchemasResponse, error)
}

func NewSystemSchemas(client *client.DatabricksClient) *SystemSchemasAPI {
	return &SystemSchemasAPI{
		impl: &systemSchemasImpl{
			client: client,
		},
	}
}

// A system schema is a schema that lives within the system catalog. A system
// schema may contain information about customer usage of Unity Catalog such as
// audit-logs, billing-logs, lineage information, etc.
type SystemSchemasAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(SystemSchemasService)
	impl SystemSchemasService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockSystemSchemasInterface instead.
func (a *SystemSchemasAPI) WithImpl(impl SystemSchemasService) SystemSchemasInterface {
	a.impl = impl
	return a
}

// Impl returns low-level SystemSchemas API implementation
// Deprecated: use MockSystemSchemasInterface instead.
func (a *SystemSchemasAPI) Impl() SystemSchemasService {
	return a.impl
}

// Disable a system schema.
//
// Disables the system schema and removes it from the system catalog. The caller
// must be an account admin or a metastore admin.
func (a *SystemSchemasAPI) Disable(ctx context.Context, request DisableRequest) error {
	return a.impl.Disable(ctx, request)
}

// Disable a system schema.
//
// Disables the system schema and removes it from the system catalog. The caller
// must be an account admin or a metastore admin.
func (a *SystemSchemasAPI) DisableByMetastoreIdAndSchemaName(ctx context.Context, metastoreId string, schemaName DisableSchemaName) error {
	return a.impl.Disable(ctx, DisableRequest{
		MetastoreId: metastoreId,
		SchemaName:  schemaName,
	})
}

// Enable a system schema.
//
// Enables the system schema and adds it to the system catalog. The caller must
// be an account admin or a metastore admin.
func (a *SystemSchemasAPI) Enable(ctx context.Context, request EnableRequest) error {
	return a.impl.Enable(ctx, request)
}

// List system schemas.
//
// Gets an array of system schemas for a metastore. The caller must be an
// account admin or a metastore admin.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SystemSchemasAPI) List(ctx context.Context, request ListSystemSchemasRequest) listing.Iterator[SystemSchemaInfo] {

	getNextPage := func(ctx context.Context, req ListSystemSchemasRequest) (*ListSystemSchemasResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListSystemSchemasResponse) []SystemSchemaInfo {
		return resp.Schemas
	}

	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		nil)
	return iterator
}

// List system schemas.
//
// Gets an array of system schemas for a metastore. The caller must be an
// account admin or a metastore admin.
//
// This method is generated by Databricks SDK Code Generator.
func (a *SystemSchemasAPI) ListAll(ctx context.Context, request ListSystemSchemasRequest) ([]SystemSchemaInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSlice[SystemSchemaInfo](ctx, iterator)
}

// List system schemas.
//
// Gets an array of system schemas for a metastore. The caller must be an
// account admin or a metastore admin.
func (a *SystemSchemasAPI) ListByMetastoreId(ctx context.Context, metastoreId string) (*ListSystemSchemasResponse, error) {
	return a.impl.List(ctx, ListSystemSchemasRequest{
		MetastoreId: metastoreId,
	})
}

type TableConstraintsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockTableConstraintsInterface instead.
	WithImpl(impl TableConstraintsService) TableConstraintsInterface

	// Impl returns low-level TableConstraints API implementation
	// Deprecated: use MockTableConstraintsInterface instead.
	Impl() TableConstraintsService

	// Create a table constraint.
	//
	// Creates a new table constraint.
	//
	// For the table constraint creation to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if the new constraint is a
	// __ForeignKeyConstraint__, the user must have the **USE_CATALOG** privilege on
	// the referenced parent table's catalog, the **USE_SCHEMA** privilege on the
	// referenced parent table's schema, and be the owner of the referenced parent
	// table.
	Create(ctx context.Context, request CreateTableConstraint) (*TableConstraint, error)

	// Delete a table constraint.
	//
	// Deletes a table constraint.
	//
	// For the table constraint deletion to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if __cascade__ argument is **true**,
	// the user must have the following permissions on all of the child tables: the
	// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
	// privilege on the table's schema, and be the owner of the table.
	Delete(ctx context.Context, request DeleteTableConstraintRequest) error

	// Delete a table constraint.
	//
	// Deletes a table constraint.
	//
	// For the table constraint deletion to succeed, the user must satisfy both of
	// these conditions: - the user must have the **USE_CATALOG** privilege on the
	// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
	// schema, and be the owner of the table. - if __cascade__ argument is **true**,
	// the user must have the following permissions on all of the child tables: the
	// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
	// privilege on the table's schema, and be the owner of the table.
	DeleteByFullName(ctx context.Context, fullName string) error
}

func NewTableConstraints(client *client.DatabricksClient) *TableConstraintsAPI {
	return &TableConstraintsAPI{
		impl: &tableConstraintsImpl{
			client: client,
		},
	}
}

// Primary key and foreign key constraints encode relationships between fields
// in tables.
//
// Primary and foreign keys are informational only and are not enforced. Foreign
// keys must reference a primary key in another table. This primary key is the
// parent constraint of the foreign key and the table this primary key is on is
// the parent table of the foreign key. Similarly, the foreign key is the child
// constraint of its referenced primary key; the table of the foreign key is the
// child table of the primary key.
//
// You can declare primary keys and foreign keys as part of the table
// specification during table creation. You can also add or drop constraints on
// existing tables.
type TableConstraintsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(TableConstraintsService)
	impl TableConstraintsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockTableConstraintsInterface instead.
func (a *TableConstraintsAPI) WithImpl(impl TableConstraintsService) TableConstraintsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level TableConstraints API implementation
// Deprecated: use MockTableConstraintsInterface instead.
func (a *TableConstraintsAPI) Impl() TableConstraintsService {
	return a.impl
}

// Create a table constraint.
//
// Creates a new table constraint.
//
// For the table constraint creation to succeed, the user must satisfy both of
// these conditions: - the user must have the **USE_CATALOG** privilege on the
// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
// schema, and be the owner of the table. - if the new constraint is a
// __ForeignKeyConstraint__, the user must have the **USE_CATALOG** privilege on
// the referenced parent table's catalog, the **USE_SCHEMA** privilege on the
// referenced parent table's schema, and be the owner of the referenced parent
// table.
func (a *TableConstraintsAPI) Create(ctx context.Context, request CreateTableConstraint) (*TableConstraint, error) {
	return a.impl.Create(ctx, request)
}

// Delete a table constraint.
//
// Deletes a table constraint.
//
// For the table constraint deletion to succeed, the user must satisfy both of
// these conditions: - the user must have the **USE_CATALOG** privilege on the
// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
// schema, and be the owner of the table. - if __cascade__ argument is **true**,
// the user must have the following permissions on all of the child tables: the
// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
// privilege on the table's schema, and be the owner of the table.
func (a *TableConstraintsAPI) Delete(ctx context.Context, request DeleteTableConstraintRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a table constraint.
//
// Deletes a table constraint.
//
// For the table constraint deletion to succeed, the user must satisfy both of
// these conditions: - the user must have the **USE_CATALOG** privilege on the
// table's parent catalog, the **USE_SCHEMA** privilege on the table's parent
// schema, and be the owner of the table. - if __cascade__ argument is **true**,
// the user must have the following permissions on all of the child tables: the
// **USE_CATALOG** privilege on the table's catalog, the **USE_SCHEMA**
// privilege on the table's schema, and be the owner of the table.
func (a *TableConstraintsAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.impl.Delete(ctx, DeleteTableConstraintRequest{
		FullName: fullName,
	})
}

type TablesInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockTablesInterface instead.
	WithImpl(impl TablesService) TablesInterface

	// Impl returns low-level Tables API implementation
	// Deprecated: use MockTablesInterface instead.
	Impl() TablesService

	// Delete a table.
	//
	// Deletes a table from the specified parent catalog and schema. The caller must
	// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
	// parent catalog and be the owner of the parent schema, or be the owner of the
	// table and have the **USE_CATALOG** privilege on the parent catalog and the
	// **USE_SCHEMA** privilege on the parent schema.
	Delete(ctx context.Context, request DeleteTableRequest) error

	// Delete a table.
	//
	// Deletes a table from the specified parent catalog and schema. The caller must
	// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
	// parent catalog and be the owner of the parent schema, or be the owner of the
	// table and have the **USE_CATALOG** privilege on the parent catalog and the
	// **USE_SCHEMA** privilege on the parent schema.
	DeleteByFullName(ctx context.Context, fullName string) error

	// Get boolean reflecting if table exists.
	//
	// Gets if a table exists in the metastore for a specific catalog and schema.
	// The caller must satisfy one of the following requirements: * Be a metastore
	// admin * Be the owner of the parent catalog * Be the owner of the parent
	// schema and have the USE_CATALOG privilege on the parent catalog * Have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// SELECT privilege on the table. * Have BROWSE privilege on the parent catalog
	// * Have BROWSE privilege on the parent schema.
	Exists(ctx context.Context, request ExistsRequest) (*TableExistsResponse, error)

	// Get boolean reflecting if table exists.
	//
	// Gets if a table exists in the metastore for a specific catalog and schema.
	// The caller must satisfy one of the following requirements: * Be a metastore
	// admin * Be the owner of the parent catalog * Be the owner of the parent
	// schema and have the USE_CATALOG privilege on the parent catalog * Have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema, and either be the table owner or have the
	// SELECT privilege on the table. * Have BROWSE privilege on the parent catalog
	// * Have BROWSE privilege on the parent schema.
	ExistsByFullName(ctx context.Context, fullName string) (*TableExistsResponse, error)

	// Get a table.
	//
	// Gets a table from the metastore for a specific catalog and schema. The caller
	// must satisfy one of the following requirements: * Be a metastore admin * Be
	// the owner of the parent catalog * Be the owner of the parent schema and have
	// the USE_CATALOG privilege on the parent catalog * Have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema, and either be the table owner or have the SELECT privilege on
	// the table.
	Get(ctx context.Context, request GetTableRequest) (*TableInfo, error)

	// Get a table.
	//
	// Gets a table from the metastore for a specific catalog and schema. The caller
	// must satisfy one of the following requirements: * Be a metastore admin * Be
	// the owner of the parent catalog * Be the owner of the parent schema and have
	// the USE_CATALOG privilege on the parent catalog * Have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema, and either be the table owner or have the SELECT privilege on
	// the table.
	GetByFullName(ctx context.Context, fullName string) (*TableInfo, error)

	// List tables.
	//
	// Gets an array of all tables for the current metastore under the parent
	// catalog and schema. The caller must be a metastore admin or an owner of (or
	// have the **SELECT** privilege on) the table. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
	// guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListTablesRequest) listing.Iterator[TableInfo]

	// List tables.
	//
	// Gets an array of all tables for the current metastore under the parent
	// catalog and schema. The caller must be a metastore admin or an owner of (or
	// have the **SELECT** privilege on) the table. For the latter case, the caller
	// must also be the owner or have the **USE_CATALOG** privilege on the parent
	// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
	// guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListTablesRequest) ([]TableInfo, error)

	// TableInfoNameToTableIdMap calls [TablesAPI.ListAll] and creates a map of results with [TableInfo].Name as key and [TableInfo].TableId as value.
	//
	// Returns an error if there's more than one [TableInfo] with the same .Name.
	//
	// Note: All [TableInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	TableInfoNameToTableIdMap(ctx context.Context, request ListTablesRequest) (map[string]string, error)

	// GetByName calls [TablesAPI.TableInfoNameToTableIdMap] and returns a single [TableInfo].
	//
	// Returns an error if there's more than one [TableInfo] with the same .Name.
	//
	// Note: All [TableInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*TableInfo, error)

	// List table summaries.
	//
	// Gets an array of summaries for tables for a schema and catalog within the
	// metastore. The table summaries returned are either:
	//
	// * summaries for tables (within the current metastore and parent catalog and
	// schema), when the user is a metastore admin, or: * summaries for tables and
	// schemas (within the current metastore and parent catalog) for which the user
	// has ownership or the **SELECT** privilege on the table and ownership or
	// **USE_SCHEMA** privilege on the schema, provided that the user also has
	// ownership or the **USE_CATALOG** privilege on the parent catalog.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListSummaries(ctx context.Context, request ListSummariesRequest) listing.Iterator[TableSummary]

	// List table summaries.
	//
	// Gets an array of summaries for tables for a schema and catalog within the
	// metastore. The table summaries returned are either:
	//
	// * summaries for tables (within the current metastore and parent catalog and
	// schema), when the user is a metastore admin, or: * summaries for tables and
	// schemas (within the current metastore and parent catalog) for which the user
	// has ownership or the **SELECT** privilege on the table and ownership or
	// **USE_SCHEMA** privilege on the schema, provided that the user also has
	// ownership or the **USE_CATALOG** privilege on the parent catalog.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListSummariesAll(ctx context.Context, request ListSummariesRequest) ([]TableSummary, error)

	// Update a table owner.
	//
	// Change the owner of the table. The caller must be the owner of the parent
	// catalog, have the **USE_CATALOG** privilege on the parent catalog and be the
	// owner of the parent schema, or be the owner of the table and have the
	// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
	// privilege on the parent schema.
	Update(ctx context.Context, request UpdateTableRequest) error
}

func NewTables(client *client.DatabricksClient) *TablesAPI {
	return &TablesAPI{
		impl: &tablesImpl{
			client: client,
		},
	}
}

// A table resides in the third layer of Unity Catalog’s three-level
// namespace. It contains rows of data. To create a table, users must have
// CREATE_TABLE and USE_SCHEMA permissions on the schema, and they must have the
// USE_CATALOG permission on its parent catalog. To query a table, users must
// have the SELECT permission on the table, and they must have the USE_CATALOG
// permission on its parent catalog and the USE_SCHEMA permission on its parent
// schema.
//
// A table can be managed or external. From an API perspective, a __VIEW__ is a
// particular kind of table (rather than a managed or external table).
type TablesAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(TablesService)
	impl TablesService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockTablesInterface instead.
func (a *TablesAPI) WithImpl(impl TablesService) TablesInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Tables API implementation
// Deprecated: use MockTablesInterface instead.
func (a *TablesAPI) Impl() TablesService {
	return a.impl
}

// Delete a table.
//
// Deletes a table from the specified parent catalog and schema. The caller must
// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
// parent catalog and be the owner of the parent schema, or be the owner of the
// table and have the **USE_CATALOG** privilege on the parent catalog and the
// **USE_SCHEMA** privilege on the parent schema.
func (a *TablesAPI) Delete(ctx context.Context, request DeleteTableRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a table.
//
// Deletes a table from the specified parent catalog and schema. The caller must
// be the owner of the parent catalog, have the **USE_CATALOG** privilege on the
// parent catalog and be the owner of the parent schema, or be the owner of the
// table and have the **USE_CATALOG** privilege on the parent catalog and the
// **USE_SCHEMA** privilege on the parent schema.
func (a *TablesAPI) DeleteByFullName(ctx context.Context, fullName string) error {
	return a.impl.Delete(ctx, DeleteTableRequest{
		FullName: fullName,
	})
}

// Get boolean reflecting if table exists.
//
// Gets if a table exists in the metastore for a specific catalog and schema.
// The caller must satisfy one of the following requirements: * Be a metastore
// admin * Be the owner of the parent catalog * Be the owner of the parent
// schema and have the USE_CATALOG privilege on the parent catalog * Have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema, and either be the table owner or have the
// SELECT privilege on the table. * Have BROWSE privilege on the parent catalog
// * Have BROWSE privilege on the parent schema.
func (a *TablesAPI) Exists(ctx context.Context, request ExistsRequest) (*TableExistsResponse, error) {
	return a.impl.Exists(ctx, request)
}

// Get boolean reflecting if table exists.
//
// Gets if a table exists in the metastore for a specific catalog and schema.
// The caller must satisfy one of the following requirements: * Be a metastore
// admin * Be the owner of the parent catalog * Be the owner of the parent
// schema and have the USE_CATALOG privilege on the parent catalog * Have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema, and either be the table owner or have the
// SELECT privilege on the table. * Have BROWSE privilege on the parent catalog
// * Have BROWSE privilege on the parent schema.
func (a *TablesAPI) ExistsByFullName(ctx context.Context, fullName string) (*TableExistsResponse, error) {
	return a.impl.Exists(ctx, ExistsRequest{
		FullName: fullName,
	})
}

// Get a table.
//
// Gets a table from the metastore for a specific catalog and schema. The caller
// must satisfy one of the following requirements: * Be a metastore admin * Be
// the owner of the parent catalog * Be the owner of the parent schema and have
// the USE_CATALOG privilege on the parent catalog * Have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema, and either be the table owner or have the SELECT privilege on
// the table.
func (a *TablesAPI) Get(ctx context.Context, request GetTableRequest) (*TableInfo, error) {
	return a.impl.Get(ctx, request)
}

// Get a table.
//
// Gets a table from the metastore for a specific catalog and schema. The caller
// must satisfy one of the following requirements: * Be a metastore admin * Be
// the owner of the parent catalog * Be the owner of the parent schema and have
// the USE_CATALOG privilege on the parent catalog * Have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema, and either be the table owner or have the SELECT privilege on
// the table.
func (a *TablesAPI) GetByFullName(ctx context.Context, fullName string) (*TableInfo, error) {
	return a.impl.Get(ctx, GetTableRequest{
		FullName: fullName,
	})
}

// List tables.
//
// Gets an array of all tables for the current metastore under the parent
// catalog and schema. The caller must be a metastore admin or an owner of (or
// have the **SELECT** privilege on) the table. For the latter case, the caller
// must also be the owner or have the **USE_CATALOG** privilege on the parent
// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
// guarantee of a specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) List(ctx context.Context, request ListTablesRequest) listing.Iterator[TableInfo] {

	getNextPage := func(ctx context.Context, req ListTablesRequest) (*ListTablesResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListTablesResponse) []TableInfo {
		return resp.Tables
	}
	getNextReq := func(resp *ListTablesResponse) *ListTablesRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List tables.
//
// Gets an array of all tables for the current metastore under the parent
// catalog and schema. The caller must be a metastore admin or an owner of (or
// have the **SELECT** privilege on) the table. For the latter case, the caller
// must also be the owner or have the **USE_CATALOG** privilege on the parent
// catalog and the **USE_SCHEMA** privilege on the parent schema. There is no
// guarantee of a specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) ListAll(ctx context.Context, request ListTablesRequest) ([]TableInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[TableInfo, int](ctx, iterator, request.MaxResults)

}

// TableInfoNameToTableIdMap calls [TablesAPI.ListAll] and creates a map of results with [TableInfo].Name as key and [TableInfo].TableId as value.
//
// Returns an error if there's more than one [TableInfo] with the same .Name.
//
// Note: All [TableInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) TableInfoNameToTableIdMap(ctx context.Context, request ListTablesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.TableId
	}
	return mapping, nil
}

// GetByName calls [TablesAPI.TableInfoNameToTableIdMap] and returns a single [TableInfo].
//
// Returns an error if there's more than one [TableInfo] with the same .Name.
//
// Note: All [TableInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) GetByName(ctx context.Context, name string) (*TableInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListTablesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]TableInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("TableInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of TableInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// List table summaries.
//
// Gets an array of summaries for tables for a schema and catalog within the
// metastore. The table summaries returned are either:
//
// * summaries for tables (within the current metastore and parent catalog and
// schema), when the user is a metastore admin, or: * summaries for tables and
// schemas (within the current metastore and parent catalog) for which the user
// has ownership or the **SELECT** privilege on the table and ownership or
// **USE_SCHEMA** privilege on the schema, provided that the user also has
// ownership or the **USE_CATALOG** privilege on the parent catalog.
//
// There is no guarantee of a specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) ListSummaries(ctx context.Context, request ListSummariesRequest) listing.Iterator[TableSummary] {

	getNextPage := func(ctx context.Context, req ListSummariesRequest) (*ListTableSummariesResponse, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.ListSummaries(ctx, req)
	}
	getItems := func(resp *ListTableSummariesResponse) []TableSummary {
		return resp.Tables
	}
	getNextReq := func(resp *ListTableSummariesResponse) *ListSummariesRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List table summaries.
//
// Gets an array of summaries for tables for a schema and catalog within the
// metastore. The table summaries returned are either:
//
// * summaries for tables (within the current metastore and parent catalog and
// schema), when the user is a metastore admin, or: * summaries for tables and
// schemas (within the current metastore and parent catalog) for which the user
// has ownership or the **SELECT** privilege on the table and ownership or
// **USE_SCHEMA** privilege on the schema, provided that the user also has
// ownership or the **USE_CATALOG** privilege on the parent catalog.
//
// There is no guarantee of a specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *TablesAPI) ListSummariesAll(ctx context.Context, request ListSummariesRequest) ([]TableSummary, error) {
	iterator := a.ListSummaries(ctx, request)
	return listing.ToSliceN[TableSummary, int](ctx, iterator, request.MaxResults)

}

// Update a table owner.
//
// Change the owner of the table. The caller must be the owner of the parent
// catalog, have the **USE_CATALOG** privilege on the parent catalog and be the
// owner of the parent schema, or be the owner of the table and have the
// **USE_CATALOG** privilege on the parent catalog and the **USE_SCHEMA**
// privilege on the parent schema.
func (a *TablesAPI) Update(ctx context.Context, request UpdateTableRequest) error {
	return a.impl.Update(ctx, request)
}

type VolumesInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockVolumesInterface instead.
	WithImpl(impl VolumesService) VolumesInterface

	// Impl returns low-level Volumes API implementation
	// Deprecated: use MockVolumesInterface instead.
	Impl() VolumesService

	// Create a Volume.
	//
	// Creates a new volume.
	//
	// The user could create either an external volume or a managed volume. An
	// external volume will be created in the specified external location, while a
	// managed volume will be located in the default location which is specified by
	// the parent schema, or the parent catalog, or the Metastore.
	//
	// For the volume creation to succeed, the user must satisfy following
	// conditions: - The caller must be a metastore admin, or be the owner of the
	// parent catalog and schema, or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
	// caller must have **CREATE VOLUME** privilege on the parent schema.
	//
	// For an external volume, following conditions also need to satisfy - The
	// caller must have **CREATE EXTERNAL VOLUME** privilege on the external
	// location. - There are no other tables, nor volumes existing in the specified
	// storage location. - The specified storage location is not under the location
	// of other tables, nor volumes, or catalogs or schemas.
	Create(ctx context.Context, request CreateVolumeRequestContent) (*VolumeInfo, error)

	// Delete a Volume.
	//
	// Deletes a volume from the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	Delete(ctx context.Context, request DeleteVolumeRequest) error

	// Delete a Volume.
	//
	// Deletes a volume from the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	DeleteByName(ctx context.Context, name string) error

	// List Volumes.
	//
	// Gets an array of volumes for the current metastore under the parent catalog
	// and schema.
	//
	// The returned volumes are filtered based on the privileges of the calling
	// user. For example, the metastore admin is able to list all the volumes. A
	// regular user needs to be the owner or have the **READ VOLUME** privilege on
	// the volume to recieve the volumes in the response. For the latter case, the
	// caller must also be the owner or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	List(ctx context.Context, request ListVolumesRequest) listing.Iterator[VolumeInfo]

	// List Volumes.
	//
	// Gets an array of volumes for the current metastore under the parent catalog
	// and schema.
	//
	// The returned volumes are filtered based on the privileges of the calling
	// user. For example, the metastore admin is able to list all the volumes. A
	// regular user needs to be the owner or have the **READ VOLUME** privilege on
	// the volume to recieve the volumes in the response. For the latter case, the
	// caller must also be the owner or have the **USE_CATALOG** privilege on the
	// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
	//
	// There is no guarantee of a specific ordering of the elements in the array.
	//
	// This method is generated by Databricks SDK Code Generator.
	ListAll(ctx context.Context, request ListVolumesRequest) ([]VolumeInfo, error)

	// VolumeInfoNameToVolumeIdMap calls [VolumesAPI.ListAll] and creates a map of results with [VolumeInfo].Name as key and [VolumeInfo].VolumeId as value.
	//
	// Returns an error if there's more than one [VolumeInfo] with the same .Name.
	//
	// Note: All [VolumeInfo] instances are loaded into memory before creating a map.
	//
	// This method is generated by Databricks SDK Code Generator.
	VolumeInfoNameToVolumeIdMap(ctx context.Context, request ListVolumesRequest) (map[string]string, error)

	// GetByName calls [VolumesAPI.VolumeInfoNameToVolumeIdMap] and returns a single [VolumeInfo].
	//
	// Returns an error if there's more than one [VolumeInfo] with the same .Name.
	//
	// Note: All [VolumeInfo] instances are loaded into memory before returning matching by name.
	//
	// This method is generated by Databricks SDK Code Generator.
	GetByName(ctx context.Context, name string) (*VolumeInfo, error)

	// Get a Volume.
	//
	// Gets a volume from the metastore for a specific catalog and schema.
	//
	// The caller must be a metastore admin or an owner of (or have the **READ
	// VOLUME** privilege on) the volume. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	Read(ctx context.Context, request ReadVolumeRequest) (*VolumeInfo, error)

	// Get a Volume.
	//
	// Gets a volume from the metastore for a specific catalog and schema.
	//
	// The caller must be a metastore admin or an owner of (or have the **READ
	// VOLUME** privilege on) the volume. For the latter case, the caller must also
	// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
	// the **USE_SCHEMA** privilege on the parent schema.
	ReadByName(ctx context.Context, name string) (*VolumeInfo, error)

	// Update a Volume.
	//
	// Updates the specified volume under the specified parent catalog and schema.
	//
	// The caller must be a metastore admin or an owner of the volume. For the
	// latter case, the caller must also be the owner or have the **USE_CATALOG**
	// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
	// parent schema.
	//
	// Currently only the name, the owner or the comment of the volume could be
	// updated.
	Update(ctx context.Context, request UpdateVolumeRequestContent) (*VolumeInfo, error)
}

func NewVolumes(client *client.DatabricksClient) *VolumesAPI {
	return &VolumesAPI{
		impl: &volumesImpl{
			client: client,
		},
	}
}

// Volumes are a Unity Catalog (UC) capability for accessing, storing,
// governing, organizing and processing files. Use cases include running machine
// learning on unstructured data such as image, audio, video, or PDF files,
// organizing data sets during the data exploration stages in data science,
// working with libraries that require access to the local file system on
// cluster machines, storing library and config files of arbitrary formats such
// as .whl or .txt centrally and providing secure access across workspaces to
// it, or transforming and querying non-tabular data files in ETL.
type VolumesAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(VolumesService)
	impl VolumesService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockVolumesInterface instead.
func (a *VolumesAPI) WithImpl(impl VolumesService) VolumesInterface {
	a.impl = impl
	return a
}

// Impl returns low-level Volumes API implementation
// Deprecated: use MockVolumesInterface instead.
func (a *VolumesAPI) Impl() VolumesService {
	return a.impl
}

// Create a Volume.
//
// Creates a new volume.
//
// The user could create either an external volume or a managed volume. An
// external volume will be created in the specified external location, while a
// managed volume will be located in the default location which is specified by
// the parent schema, or the parent catalog, or the Metastore.
//
// For the volume creation to succeed, the user must satisfy following
// conditions: - The caller must be a metastore admin, or be the owner of the
// parent catalog and schema, or have the **USE_CATALOG** privilege on the
// parent catalog and the **USE_SCHEMA** privilege on the parent schema. - The
// caller must have **CREATE VOLUME** privilege on the parent schema.
//
// For an external volume, following conditions also need to satisfy - The
// caller must have **CREATE EXTERNAL VOLUME** privilege on the external
// location. - There are no other tables, nor volumes existing in the specified
// storage location. - The specified storage location is not under the location
// of other tables, nor volumes, or catalogs or schemas.
func (a *VolumesAPI) Create(ctx context.Context, request CreateVolumeRequestContent) (*VolumeInfo, error) {
	return a.impl.Create(ctx, request)
}

// Delete a Volume.
//
// Deletes a volume from the specified parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the volume. For the
// latter case, the caller must also be the owner or have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema.
func (a *VolumesAPI) Delete(ctx context.Context, request DeleteVolumeRequest) error {
	return a.impl.Delete(ctx, request)
}

// Delete a Volume.
//
// Deletes a volume from the specified parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the volume. For the
// latter case, the caller must also be the owner or have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema.
func (a *VolumesAPI) DeleteByName(ctx context.Context, name string) error {
	return a.impl.Delete(ctx, DeleteVolumeRequest{
		Name: name,
	})
}

// List Volumes.
//
// Gets an array of volumes for the current metastore under the parent catalog
// and schema.
//
// The returned volumes are filtered based on the privileges of the calling
// user. For example, the metastore admin is able to list all the volumes. A
// regular user needs to be the owner or have the **READ VOLUME** privilege on
// the volume to recieve the volumes in the response. For the latter case, the
// caller must also be the owner or have the **USE_CATALOG** privilege on the
// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
//
// There is no guarantee of a specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) List(ctx context.Context, request ListVolumesRequest) listing.Iterator[VolumeInfo] {

	getNextPage := func(ctx context.Context, req ListVolumesRequest) (*ListVolumesResponseContent, error) {
		ctx = useragent.InContext(ctx, "sdk-feature", "pagination")
		return a.impl.List(ctx, req)
	}
	getItems := func(resp *ListVolumesResponseContent) []VolumeInfo {
		return resp.Volumes
	}
	getNextReq := func(resp *ListVolumesResponseContent) *ListVolumesRequest {
		if resp.NextPageToken == "" {
			return nil
		}
		request.PageToken = resp.NextPageToken
		return &request
	}
	iterator := listing.NewIterator(
		&request,
		getNextPage,
		getItems,
		getNextReq)
	return iterator
}

// List Volumes.
//
// Gets an array of volumes for the current metastore under the parent catalog
// and schema.
//
// The returned volumes are filtered based on the privileges of the calling
// user. For example, the metastore admin is able to list all the volumes. A
// regular user needs to be the owner or have the **READ VOLUME** privilege on
// the volume to recieve the volumes in the response. For the latter case, the
// caller must also be the owner or have the **USE_CATALOG** privilege on the
// parent catalog and the **USE_SCHEMA** privilege on the parent schema.
//
// There is no guarantee of a specific ordering of the elements in the array.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) ListAll(ctx context.Context, request ListVolumesRequest) ([]VolumeInfo, error) {
	iterator := a.List(ctx, request)
	return listing.ToSliceN[VolumeInfo, int](ctx, iterator, request.MaxResults)

}

// VolumeInfoNameToVolumeIdMap calls [VolumesAPI.ListAll] and creates a map of results with [VolumeInfo].Name as key and [VolumeInfo].VolumeId as value.
//
// Returns an error if there's more than one [VolumeInfo] with the same .Name.
//
// Note: All [VolumeInfo] instances are loaded into memory before creating a map.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) VolumeInfoNameToVolumeIdMap(ctx context.Context, request ListVolumesRequest) (map[string]string, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "name-to-id")
	mapping := map[string]string{}
	result, err := a.ListAll(ctx, request)
	if err != nil {
		return nil, err
	}
	for _, v := range result {
		key := v.Name
		_, duplicate := mapping[key]
		if duplicate {
			return nil, fmt.Errorf("duplicate .Name: %s", key)
		}
		mapping[key] = v.VolumeId
	}
	return mapping, nil
}

// GetByName calls [VolumesAPI.VolumeInfoNameToVolumeIdMap] and returns a single [VolumeInfo].
//
// Returns an error if there's more than one [VolumeInfo] with the same .Name.
//
// Note: All [VolumeInfo] instances are loaded into memory before returning matching by name.
//
// This method is generated by Databricks SDK Code Generator.
func (a *VolumesAPI) GetByName(ctx context.Context, name string) (*VolumeInfo, error) {
	ctx = useragent.InContext(ctx, "sdk-feature", "get-by-name")
	result, err := a.ListAll(ctx, ListVolumesRequest{})
	if err != nil {
		return nil, err
	}
	tmp := map[string][]VolumeInfo{}
	for _, v := range result {
		key := v.Name
		tmp[key] = append(tmp[key], v)
	}
	alternatives, ok := tmp[name]
	if !ok || len(alternatives) == 0 {
		return nil, fmt.Errorf("VolumeInfo named '%s' does not exist", name)
	}
	if len(alternatives) > 1 {
		return nil, fmt.Errorf("there are %d instances of VolumeInfo named '%s'", len(alternatives), name)
	}
	return &alternatives[0], nil
}

// Get a Volume.
//
// Gets a volume from the metastore for a specific catalog and schema.
//
// The caller must be a metastore admin or an owner of (or have the **READ
// VOLUME** privilege on) the volume. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *VolumesAPI) Read(ctx context.Context, request ReadVolumeRequest) (*VolumeInfo, error) {
	return a.impl.Read(ctx, request)
}

// Get a Volume.
//
// Gets a volume from the metastore for a specific catalog and schema.
//
// The caller must be a metastore admin or an owner of (or have the **READ
// VOLUME** privilege on) the volume. For the latter case, the caller must also
// be the owner or have the **USE_CATALOG** privilege on the parent catalog and
// the **USE_SCHEMA** privilege on the parent schema.
func (a *VolumesAPI) ReadByName(ctx context.Context, name string) (*VolumeInfo, error) {
	return a.impl.Read(ctx, ReadVolumeRequest{
		Name: name,
	})
}

// Update a Volume.
//
// Updates the specified volume under the specified parent catalog and schema.
//
// The caller must be a metastore admin or an owner of the volume. For the
// latter case, the caller must also be the owner or have the **USE_CATALOG**
// privilege on the parent catalog and the **USE_SCHEMA** privilege on the
// parent schema.
//
// Currently only the name, the owner or the comment of the volume could be
// updated.
func (a *VolumesAPI) Update(ctx context.Context, request UpdateVolumeRequestContent) (*VolumeInfo, error) {
	return a.impl.Update(ctx, request)
}

type WorkspaceBindingsInterface interface {
	// WithImpl could be used to override low-level API implementations for unit
	// testing purposes with [github.com/golang/mock] or other mocking frameworks.
	// Deprecated: use MockWorkspaceBindingsInterface instead.
	WithImpl(impl WorkspaceBindingsService) WorkspaceBindingsInterface

	// Impl returns low-level WorkspaceBindings API implementation
	// Deprecated: use MockWorkspaceBindingsInterface instead.
	Impl() WorkspaceBindingsService

	// Get catalog workspace bindings.
	//
	// Gets workspace bindings of the catalog. The caller must be a metastore admin
	// or an owner of the catalog.
	Get(ctx context.Context, request GetWorkspaceBindingRequest) (*CurrentWorkspaceBindings, error)

	// Get catalog workspace bindings.
	//
	// Gets workspace bindings of the catalog. The caller must be a metastore admin
	// or an owner of the catalog.
	GetByName(ctx context.Context, name string) (*CurrentWorkspaceBindings, error)

	// Get securable workspace bindings.
	//
	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	GetBindings(ctx context.Context, request GetBindingsRequest) (*WorkspaceBindingsResponse, error)

	// Get securable workspace bindings.
	//
	// Gets workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	GetBindingsBySecurableTypeAndSecurableName(ctx context.Context, securableType string, securableName string) (*WorkspaceBindingsResponse, error)

	// Update catalog workspace bindings.
	//
	// Updates workspace bindings of the catalog. The caller must be a metastore
	// admin or an owner of the catalog.
	Update(ctx context.Context, request UpdateWorkspaceBindings) (*CurrentWorkspaceBindings, error)

	// Update securable workspace bindings.
	//
	// Updates workspace bindings of the securable. The caller must be a metastore
	// admin or an owner of the securable.
	UpdateBindings(ctx context.Context, request UpdateWorkspaceBindingsParameters) (*WorkspaceBindingsResponse, error)
}

func NewWorkspaceBindings(client *client.DatabricksClient) *WorkspaceBindingsAPI {
	return &WorkspaceBindingsAPI{
		impl: &workspaceBindingsImpl{
			client: client,
		},
	}
}

// A securable in Databricks can be configured as __OPEN__ or __ISOLATED__. An
// __OPEN__ securable can be accessed from any workspace, while an __ISOLATED__
// securable can only be accessed from a configured list of workspaces. This API
// allows you to configure (bind) securables to workspaces.
//
// NOTE: The __isolation_mode__ is configured for the securable itself (using
// its Update method) and the workspace bindings are only consulted when the
// securable's __isolation_mode__ is set to __ISOLATED__.
//
// A securable's workspace bindings can be configured by a metastore admin or
// the owner of the securable.
//
// The original path (/api/2.1/unity-catalog/workspace-bindings/catalogs/{name})
// is deprecated. Please use the new path
// (/api/2.1/unity-catalog/bindings/{securable_type}/{securable_name}) which
// introduces the ability to bind a securable in READ_ONLY mode (catalogs only).
//
// Securables that support binding: - catalog
type WorkspaceBindingsAPI struct {
	// impl contains low-level REST API interface, that could be overridden
	// through WithImpl(WorkspaceBindingsService)
	impl WorkspaceBindingsService
}

// WithImpl could be used to override low-level API implementations for unit
// testing purposes with [github.com/golang/mock] or other mocking frameworks.
// Deprecated: use MockWorkspaceBindingsInterface instead.
func (a *WorkspaceBindingsAPI) WithImpl(impl WorkspaceBindingsService) WorkspaceBindingsInterface {
	a.impl = impl
	return a
}

// Impl returns low-level WorkspaceBindings API implementation
// Deprecated: use MockWorkspaceBindingsInterface instead.
func (a *WorkspaceBindingsAPI) Impl() WorkspaceBindingsService {
	return a.impl
}

// Get catalog workspace bindings.
//
// Gets workspace bindings of the catalog. The caller must be a metastore admin
// or an owner of the catalog.
func (a *WorkspaceBindingsAPI) Get(ctx context.Context, request GetWorkspaceBindingRequest) (*CurrentWorkspaceBindings, error) {
	return a.impl.Get(ctx, request)
}

// Get catalog workspace bindings.
//
// Gets workspace bindings of the catalog. The caller must be a metastore admin
// or an owner of the catalog.
func (a *WorkspaceBindingsAPI) GetByName(ctx context.Context, name string) (*CurrentWorkspaceBindings, error) {
	return a.impl.Get(ctx, GetWorkspaceBindingRequest{
		Name: name,
	})
}

// Get securable workspace bindings.
//
// Gets workspace bindings of the securable. The caller must be a metastore
// admin or an owner of the securable.
func (a *WorkspaceBindingsAPI) GetBindings(ctx context.Context, request GetBindingsRequest) (*WorkspaceBindingsResponse, error) {
	return a.impl.GetBindings(ctx, request)
}

// Get securable workspace bindings.
//
// Gets workspace bindings of the securable. The caller must be a metastore
// admin or an owner of the securable.
func (a *WorkspaceBindingsAPI) GetBindingsBySecurableTypeAndSecurableName(ctx context.Context, securableType string, securableName string) (*WorkspaceBindingsResponse, error) {
	return a.impl.GetBindings(ctx, GetBindingsRequest{
		SecurableType: securableType,
		SecurableName: securableName,
	})
}

// Update catalog workspace bindings.
//
// Updates workspace bindings of the catalog. The caller must be a metastore
// admin or an owner of the catalog.
func (a *WorkspaceBindingsAPI) Update(ctx context.Context, request UpdateWorkspaceBindings) (*CurrentWorkspaceBindings, error) {
	return a.impl.Update(ctx, request)
}

// Update securable workspace bindings.
//
// Updates workspace bindings of the securable. The caller must be a metastore
// admin or an owner of the securable.
func (a *WorkspaceBindingsAPI) UpdateBindings(ctx context.Context, request UpdateWorkspaceBindingsParameters) (*WorkspaceBindingsResponse, error) {
	return a.impl.UpdateBindings(ctx, request)
}
