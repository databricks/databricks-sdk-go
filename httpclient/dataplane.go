package httpclient

import (
	"fmt"
	"time"

	"github.com/databricks/databricks-sdk-go/credentials"
	"golang.org/x/oauth2"
)

type DataPlaneInfoKey struct {
	ServiceName string
	Path        string
}

// TODO: Replace by the DataPlaneInfo generated by SDK Generator in the package oauth2.
// This will be generated once the first service uses the annotation for the DataPlaneInfo.
type DataPlaneInfo struct {
	EndpointUrl          string
	AuthorizationDetails string
}

type DataPlaneData struct {
	DataPlaneInfo  *DataPlaneInfo
	Token          *credentials.OAuthToken
	ExpirationTime *time.Time
	InfoRefresher  func() (*DataPlaneInfo, error)
}

func (d *DataPlaneData) RefreshInfo() error {
	newInfo, err := d.InfoRefresher()
	if err != nil {
		return err
	}
	d.DataPlaneInfo = newInfo
	return nil
}

func (d *DataPlaneData) Expired() bool {
	return d.Token == nil || d.ExpirationTime == nil || time.Now().After(*d.ExpirationTime)
}

func (d *DataPlaneData) ExpiresIn(duration time.Duration) bool {
	return d.Token == nil || d.ExpirationTime == nil || time.Now().Add(duration).After(*d.ExpirationTime)
}

// TODO: Maybe add locks around the map?
type dataPlaneCache map[DataPlaneInfoKey]*DataPlaneData

// Refreshes the DataPlaneInfo
// This is only required if the backend updates the required permissions
// to call an endpoint, or the endpoint_url changes (which should be very rare).
// Calling this method also invalidates the token.
func (c *ApiClient) RefreshInfo(serviceName string,
	path string) error {
	key := DataPlaneInfoKey{
		ServiceName: serviceName,
		Path:        path,
	}
	data, ok := c.dataPlaneCache[key]
	if !ok {
		return fmt.Errorf("data not found for service %s and endpoint %s", serviceName, path)
	}
	err := data.RefreshInfo()
	if err != nil {
		return err
	}
	data.Token = nil
	data.ExpirationTime = nil
	return nil
}

func (c *ApiClient) GetOAuthTokenForDataPlane(
	serviceName string,
	path string,
	dataPlaneInfoGetter func() (*DataPlaneInfo, error),
	controlPlaneTokenProvider func() (*oauth2.Token, error)) (*credentials.OAuthToken, error) {
	key := DataPlaneInfoKey{
		ServiceName: serviceName,
		Path:        path,
	}
	data, ok := c.dataPlaneCache[key]
	if !ok {
		data = &DataPlaneData{
			InfoRefresher: dataPlaneInfoGetter,
		}
		data.RefreshInfo()
		c.dataPlaneCache[key] = data
	}
	if data.ExpiresIn(2 * time.Minute) {
		err := c.refreshToken(data, controlPlaneTokenProvider)
		if err != nil {
			return nil, err
		}
	}
	return data.Token, nil
}

func (c *ApiClient) refreshToken(data *DataPlaneData, controlPlaneTokenProvider func() (*oauth2.Token, error)) error {
	controlPlaneToken, err := controlPlaneTokenProvider()
	if err != nil {
		return err
	}
	newToken, err := c.GetOAuthToken(data.DataPlaneInfo.AuthorizationDetails, controlPlaneToken)
	if err != nil {
		return err
	}
	data.Token = newToken
	expirationTime := time.Now().Add(time.Second * time.Duration(newToken.ExpiresIn))
	data.ExpirationTime = &expirationTime
	return nil
}
